# 预处理器

之前用到过`#define`与`#include`指令，但没有深入讨论。这些指令（以及还没有学到的指令）都是由预处理器处理的。预处理器是一个小软件，它可以在编译前处理C程序。C语言（和C++语言）因为依赖预处理器而不同于其他的编程语言。



预处理器是一种强大的工具，但它同时也可能是许多难以发现的错误的根源。此外，预处理器也可能被错误地用来编写出一些几乎不可能读懂的程序。尽管有些C程序员十分依赖于预处理器，但是依然建议适度地使用它。



## 预处理器的工作原理

预处理器的行为是由预处理指令（由#字符开头的一些命令）控制的。之前已经遇见过其中两种指令，即`#define`和`#include`。



`#define`指令定义了一个宏——用来代表其他东西的一个名字，例如常量或常用的表达式。预处理器会通过将宏的名字和它的定义存储在一起来响应`#define`指令。当这个宏在后面的程序中使用到时，预处理器”扩展“宏，将宏替换为其定义值。



`#define`指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分”包含“进来。例如，代码行

```c
#include <stdio.h>
```

指示预处理器打开一个名字为`stdio.h`的文件，并将它的内容加到当前的程序中。（`stdio.h`包含了C语言标准输入/输出函数的原型。）



以下是预处理器在编译过程中的作用：

> C程序中可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。预处理器的输出是另一个C程序：原程序编辑后的版本，不再包含指令。预处理器的输出被直接交给编译器，编译器检查程序是否有错误，并将程序翻译为目标代码（机器指令）。



为了展现预处理器的作用，以之前的`celsius.c`为例，下面是源程序：

```c

#include <stdio.h>

#define FREEZING_PT 32.0f
#define SCALE_FACTOR (5.0f / 9.0f)

int main(void) {
    float fahrenheit,celsius;

    printf("Enter Fahrenheit temperature: ");
    scanf("%f",&fahrenheit);

    celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

    printf("Celsius equivalent: %.1f\n",celsius);
    return 0;
}
```

预处理结束后，程序是下面的样子：

```c
空行
空行
从stdio.h中引入的行
空行
空行
空行
空行
int main(void){
	 float fahrenheit,celsius;

    printf("Enter Fahrenheit temperature: ");
    scanf("%f",&fahrenheit);

    celsius = (fahrenheit - 32.0f) * (5.0f/9.0f);

    printf("Celsius equivalent: %.1f\n",celsius);
    return 0;
}
```

预处理器通过引入`stdio.h`的内容来响应`#define`指令。预处理器也删除了`#define`指令，并且替换了该文件中稍后出现在任何位置上的`FREEZING_PT`和`SCALE_FACTOR`。请注意预处理器并没有删除包含指令的行，而是简单地将它们替换为空。



## 预处理指令

大多数预处理指令都属于下面3种类型之一。

- 宏定义

  `#define`指令定义一个宏，`#undef`指令删除一个宏定义。

- 文件包含

  `#include`指令导致一个指定文件的内容被包含到程序中

- 条件编译

  `#if`、`#ifdef`、`#ifndef`、`#elif`、`else`和`#endif`指令可以根据预处理器可以测试的条件来确定是将一段文本块包含到程序中还是将其排除在程序之外。



剩下的`#error`、`#line`和`#pragma`指令是更特殊的指令，较少用到。



在进一步讨论之前，先来看几条适用于所有指令的规则。

- 指令都以`#`开始

  `#`符号不需要在一行的行首，只要它之前只有空白字符就行。在`#`后是指令名，接着是指令所需要的其他信息。

- 在指令的符号之间可以插入任意数量的空格或水平制表符。例如，下面的指令是合法的：

  ```c
  #	define	N	100
  ```

- 指令总在第一个换行符处结束，除非明确地指明要延续。如果想在下一行延续指令，必须在当前行的末尾使用`\`字符。例如，下面的指令定义了一个宏来表示硬盘的容量，按字节计算：

  ```C
  #define DISK_CAPACITY(SIDES *	\
  						TRACKS_PER_SIDE *	\
  						SECTORS_PER_TRACK	*	\
  						BYTE_PER_SECTOR)
  ```

- 指令可以出现在程序的任何地方。但我们通常将`#define`和`#include`指令放在文件的开始，其他指令则放在后面，甚至可以放在函数定义的中间。

- 注释可以与指令放在同一行。实际上，在宏定义的后面加一个注释来解释宏的定义是一种比较好的习惯：

  ```c
  #define FREEZING_PT 32.0f	// freezing point of water
  ```



## 宏定义

之前一直使用的宏被称为简单的宏，它们没有参数。预编译器还支持带参数的宏。本节先讨论简单的宏，然后再讨论带参数的宏。在分别讨论它们之后，再研究一下两者共同的特性。



### 简单的宏

简单的宏（C标准中称为对象式宏）的定义有如下格式：

```
[#define指令 (简单的宏)] #define 标识号 替换列表
```

替换列表是一系列的预处理记号，本章中提及“记号”时均指的是“预处理记号”。



宏的替换列表可以包括标识符、关键字、数值常量、字符常量、字符串字面量、操作符和排列。当预处理器遇到一个宏定义时，会做一个“标识符”代表“替换列表”的记录。在文件后面的内容中，不管标识符在哪里出现，预处理器都会用替换列表来代替它。



不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用=：

```c
#define N = 100		/** WRONG **/
...
int a[N];			/** becomes int a[=100] **/
```

在上面的例子中，错误地把N定义成两个记号（= 和 100）。



在宏定义的末尾使用分号结尾是另一个常见错误：

```c
#define N 100; 	// WRONG
...
int a[N];		// becomes int a[100;];
```

编译器可以检测到宏定义中绝大多数由多余符号所导致的错误。但是，编译器只会将每一个使用这个宏的地方标为错误，而不会直接找到错误的根源——宏定义本身，因为宏定义已经被预处理器删除了。



简单的宏主要用来定义那些被称为“明示常量”的对象。可以使用宏给数值、字符值和字符串值命名。

```c
#define STE_LEN 80
#define TRUE 1
#define FALSE 0
#define PI 3.14159
#define CR '\r'
#define EOS '\0'
#define MEM_ERR "Error: not enough memory"
```

使用`#define`来为常量命名有很多显著的优点：

- 程序更易读

  一个认真选择的名字可以帮助读者理解常量的意义

- 程序会更易于修改

- 可以帮助避免前后不一致或输入错误

- 对类型重命名

  之前的章节中，曾经通过重命名`int`创建了一个布尔类型：

  ```c
  #define BOOL int
  ```

  虽然有些程序员会使用宏定义的方式来实现此目的，但类型定义（7.5节）仍然是定义新类型的最佳方法。

- 控制条件编译

  如果将看到的那样，宏在控制条件编译中起重要的作用。例如，在程序中出现的下面这行宏定义可能表明需要将程序在“调试模式”下进行编译，并使用额外的语句输出调试信息：

  ```c
  #define DEBUG
  ```



### 带参数的宏

带参数的宏（也称为函数式宏）的定义有如下格式：

```
[#define指令 (带参数的宏)] #define标识符(X1,X2,...Xn)替换列表
```

在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏——其中`(X1,X2,...Xn)`是替换列表的一部分。



当预处理器遇到带参数的宏时，会将宏定义存储起来以便后面使用。在后面的程序中，如果任何地方出现了标识符(`Y1,Y2,...Yn`)格式的宏调用（其中`Y1,Y2,...Yn`是一系列记号），预处理器会使用替换列表替代——使用`Y1`替换`X1`，`Y2`替换`X2`，以此类推。



例如，假定我们定义了如下的宏：

```c
#define MAX(x,y)	((x)>(y)?(x):(y))
#define IS_EVEN(n) 	((n) % 2 == 0)
```

（宏定义中的圆括号比较多，后面将看到，这样做是有原因的。）如果后面的程序中有如下语句：

```c
i = MAX(j+k,m-n);
if(IS_EVEN(i)) i++;
```

预处理器会将这些行替换为：

```c
i = ((j+k) > (m-n) ? (j+k) : (m-n));
if(((i) %2 == 0)) i++;
```

如这个例子所示，带参数的宏经常用来作为简单的函数使用。MAX类似一个从两个值中选取较大值的函数，`IS_EVEN`则类似于一种当参数为偶数时返回1，否则返回0的函数。



下面的宏也类似于函数，但更为复杂：

```c
#define TOUPPER(c) ('a' <= (c) && (c) <= 'z' ? (c)-'a' + 'A' : (c))
```

这个宏检测字符c是否在`a`与`z`之间。如果在的话，这个宏会用c的值减去`a`再加上`A`，从而计算出c所对应的大写字母。如果c不在这个范围，就保留原来的c。(`<ctype.h>`头文件中提供了一个类似的函数`toupper`，它的可移植性更好。)



带参数的宏可以包含空的参数列表，如下例所示：

```c
#define getchar() getc(stdin)
```

空的参数列表不是必需的，但这样可以使`getchar`更像一个函数。（没错，这就是`<stdio.h>`中的`getchar`。后面的章节会看到，`getchar`经常实现为宏，也经常实现为函数。）



使用带参数的宏替代真正的函数有两个优点：

- 程序可能会稍微快些

  程序执行时调用函数通常会有些额外开销——存储上下文信息、复制参数的值等，而调用宏则没有这些运行开销。（C99的内联函数提供了一种不使用宏而避免这一开销的方法。）

- 宏更“通用”

  与函数的参数不同，宏的参数没有类型。因此，只要预处理器后的程序依然是合法的，宏可以接受任何类型的参数。例如，可以使用`MAX`宏从两个数中选出较大的一个，数的类型可以是`int`、`long`、`float`、`double`等。



但是带参数的宏也有一些缺点：

- 编译后的代码通常会变大。

  每一处宏调用都会导致插入宏的替换列表，由此导致程序的源代码增加（因此编译后的代码变大）。宏使用的越频繁，这种效果就越明显。当宏相互嵌套时，这个问题会相互叠加从而使程序更加复杂。

- 宏参数没有类型检查

  **当一个函数被调用时，编译器会检查每一个参数来确认它们是否是正确的类型。如果不是，要么将参数转换成正确的类型，要么由编译器产生一条出错消息。预处理器不会检查宏参数的类型，也不会进行类型转换。**

- 无法用一个指针来指向一个宏

  如之后将看到的，C语言允许指针指向函数，这在特定的编程条件下非常有用。宏会在预处理过程中被删除，所以不存在类似的“指向宏的指针”。因此，宏不能用于处理这些情况。

- 宏可能会不止一次地计算它的参数

  **函数对它的参数只会计算一次，而宏可能会计算两次甚至多次。如果参数有副作用，多次计算参数的值可能会产生不可预知的后果。考虑下面的例子，其中MAX的一个参数有副作用：**

  ```c
  n = MAX(i++;j);
  ```

  下面是这条语句在预处理之后的结果：

  ```c
  n = ((i++) > (j) ? (i++) : (j));
  ```

  **如果i大于j，那么i可能会被（错误地）增加两次，同时n可能被赋予错误的值。**



**由于多次计算宏的参数而导致的错误可能非常难于发现，因为宏调用和函数调用看起来是一样的。更糟糕的是，这类宏可能在大多数情况下可以正常工作，仅在特定参数有副作用时失效。为了自我保护，最好避免使用带副作用的参数。**



带参数的宏不仅适用于模拟函数调用，还经常用作需要重复书写的代码段模式。比如已经写烦了语句：

```c
printf("%d\n",i);
```

因为每次要显示一个整数i都要使用它，可以定义下面的宏，使显示整数变得简单些：

```c
#define PRINT_INT(n)	printf("%d\n",n)
```

一旦定义了`PRINT_INT`,预处理器会将这行：

```c
PRINT_INT(i/j);
```

转换为

```c
printf("%d\n",i/j);
```



###  #运算符

宏定义可以包含两个专用的运算符：`#`和`##`。编译器不会识别这两种运算符，它们会在预处理器时被执行。



`#`运算符将宏的一个参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。（`#`运算符所执行的操作可以理解为“字符串化”）。



`#`运算符有许多用途，这里只讨论其中的一种。假设我们决定在调试过程中使用`PRINT_INT`宏作为一个便捷的方法来输出整型变量或表达式的值。`#`运算符可以使`PRINT_INT`为每个输出的值添加标签。下面是改进后的`PRINT_INT`：

```c
#define PRINT_INT(n) printf(#n " = %d\n",n)
```

n之前的`#`运算符通知预处理器根据`PRINT_INT`的参数创建一个字符串字面量。因此，调用

```c
PRINT_INT(i/j);
```

会变为

```c
printf("i/j" " = %d\n",i/j);
```

从13.1节可知，C语言中相邻的字符串字面量会被合并。因此上面的语句等价于：

```c
printf("i/j = %d\n",i/j);
```

当程序执行时，`printf`函数会同时显示表达式`i/j`和它的值。例如，如果i是11，j是2的话，输出为：

```c
i/j = 5
```



### ##运算符

`##`运算符可以将两个记号（如标识符）“粘合”在一起，成为一个记号。（无需惊讶，`##`运算符被称为“记号粘合”。）如果其中一个操作数是宏参数，“粘合”会在形式参数被相应的实际参数替换后发生。例如下面的宏：

```c
#define MK_ID(n) i##n
```

当`MK_ID`被调用时（比如MK_ID(1)），预处理器首先使用实际参数（这个例子中是1）替换形式参数n。接着，预处理器将i和1合并成为一个记号(i1)。下面的声明使用MK_ID创建了3个标识符：

```c
int MK_ID(1),MK_ID(2),MK_ID(3);
```

预处理后这一声明变为：

```c
int i1,i2,i3;
```

`##`运算符不属于预处理器最经常使用的特性。实际上，想找到一些使用它的情况是比较困难的。为了找到一个有实际意义的`##`的应用，来重新思考前面提到过的`MAX`宏。如我们所见，当MAX的参数有副作用时会无法正常工作。一种解决方法是用MAX宏来写一个max函数。遗憾的是，仅一个max函数是不够的，我们可能需要一个实际参数是int值的max函数、一个实际参数为float值得max函数，等等。除了实际参数的类型和返回值的类型之外，这些函数都一样。因此，这样定义每一个函数似乎是个很蠢的做法。



解决的办法是定义一个宏，并使它展开后成为max函数的定义。宏只有一个参数type，表示实际参数和返回值的类型。这里还有个问题，如果我们用宏来创建多个max函数，程序将无法编译。（C语言不允许在同一个文件中出现两个同名的函数。）为了解决这个问题，我们用`##`运算符为每个版本的max函数构造不同的名字。下面是宏的形式：

```c
#define GENERIC_MAX(type)			\
type type##_max(type x,type y)		\
{									\
	return x > y? x: y;				\
}
```

注意，宏的定义中是如何将`type`和`_max`相连来形成新函数名的。



现在，假如我们需要一个针对`float`值的`max`函数。下面是使用`GENERIC_MAX`宏来定义这一函数的方法：

```c
GENERIC_MAX(float)
```

预处理器会将这行展开为下面的代码：

```c
float float_max(float x,float y){ return x > y? x:y;}
```



完整使用示例如下：

```c
/*
 * 定义一个通用的适用各个类型的比较大小的宏
 * 其中type为适用的类型
 */
#define GENERIC_MAX(type)			\
type type##_max(type x,type y)		\
{									\
    return x > y? x: y;				\
}

// 使用GENERIC宏定义一个针对float类型的max函数，此后就可以调用float_max函数了
GENERIC_MAX(float)

#include <stdio.h>

int main(void) {
    float x = 3.0f;
    float y = 4.0f;
    // 调用float_max函数比较float类型参数的大小
    float max = float_max(x,y);
    printf("%f",max);
    return 0;
}

```

### 宏的通用属性

现在我们已经讨论过了简单的宏和带参数的宏，我们来看一下它们都需要遵守的规则。

- 宏的替换列表可以包含对其他宏的调用。

  例如，可以用宏PI来定义宏TWO_PI:

  ```c
  #define PI 3.14159
  #define TWO_PI (2*PI)
  ```

  当预处理器在后面的程序中遇到TWO_PI时，会将它替换成(2*PI)。接着，预处理器会重新检查替换列表，看它是否包含其他宏的调用（在这个例子中，调用了宏PI）。预处理器会不断重新检查替换列表，直到把所有的宏名字都替换掉为止。

- 预处理器只会替换完整的记号，而不会替换记号的片断。因此，预处理器会忽略嵌在标识符、字符常量、字符串字面量之中的宏名。例如，假设程序含有如下代码行：

  ```c
  #define SIZE 256
  
  int BUFFER_SIZE;
  
  if(BUFFER_SIZE > SIZE)
  	puts("Error : SIZE exceeded");
  ```

  预处理后这些代码行会变为：

  ```c
  int BUFFER_SIZE;
  
  if(BUFFER_SIZE > 256)
  	puts("Error : SIZE exceeded");
  ```

  尽管标识符`BUFFER_SIZE`和字符串"Error : SIZE exceeded"都包含SIZE，但是它们没有被预处理影响。

- 宏定义的作用范围通常到这个宏的文件末尾。由于宏是由预处理器处理的，它们不遵从通常的作用域规则。定义在函数中的宏并不是仅在函数内起作用，而是作用到文件末尾

- 宏不可以被定义两遍，除非新的定义与旧的定义是一样的。小的间隔上的差异是允许的，但是宏的替换列表（和参数，如果有的话）中的记号都必须一致。

- 宏可以使用`#undef`指令“取消定义”。`undef`指令有如下形式：

  ```
  [#undef指令] #undef 标识符
  ```

  其中标识符是一个宏名。例如，指令

  ```c
  #undef N
  ```

  会删除宏N当前的定义。（如果N没有被定义成一个宏，`#undef`指令没有任何作用。）`#undef`指令的一个用途是取消宏的现有定义，以便于重新给出新的定义。



### 宏定义中的圆括号

在前面定义的宏的替换列表中有大量的圆括号。确实需要它们吗？答案是绝对需要。如果少用几个圆括号，宏有时可能会得到意想不到的（不希望的）结果。



对于在一个宏定义中哪里要加圆括号有两条规则要遵守。首先，如果宏的替换列表中有运算符，那么始终要将替换列表放在括号中：

```c
#define TWO_PI (2*3.14159)
```

其次，如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号中：

```c
#define SCALE(x) ((x)*10)
```

没有括号的话，将无法保证编译器会将替换列表和参数作为完整的表达式。编译器可能会不按我们期望的方式应用运算符的优先级和结合性规则。



为了展示为替换列表添加圆括号的重要性，考虑下面的宏定义，其中的替换列表没有添加圆括号：

```c
#define TWO_PI 2*3.14159
/* 需要给替换列表加圆括号 */
```

在预处理时，语句

```c
conversion_factor= 360/2*3.14159;
```

除法会在乘法之前执行，产生的结果并不是期望的结果。



当宏有参数时，仅给替换列表添加圆括号是不够的。参数的每一次出现都要添加圆括号。例如，假设SCALE定义如下：

```c
#define SCALE(x) (x*10)	/* 需要给x添加括号 */
```

在预处理过程中，语句

```c
j = SCALE(i+1);
```

变为

```c
j = (i+1*10);
```

由于乘法的优先级比加法高，这条语句等价于：

```c
j = i+10;
```

然而我们希望的是：

```c
j = (i+1)*10;
```



### 创建较长的宏

在创建较长的宏时，逗号运算符会十分有用。特别是可以使用逗号运算符来使替换列表包含一系列表达式。例如，下面的宏会读入一个字符串，再把字符串显示出来：

```c
#define ECHO(s)	(gets(s),puts(s))
```

`gets` 函数和`puts`函数的调用都是表达式，因此使用逗号运算符连接它们是合法的。我们甚至可以把ECHO宏当作一个函数来使用：

```c
ECHO(str);	/* 替换为(gets(str),puts(str)); */
```

如果不想在ECHO的定义中使用逗号运算符，我们还可以将gets函数和puts函数的调用放在花括号中形成复合语句：

```c
#define ECHO(s) {gets(s);puts(s);}
```

遗憾的是，这种方式可能会有问题。如果将这个ECHO宏用于下面的if语句：

```c
if(echo_flag)
	ECHO(str);
else
	gets(str);
```

将ECHO宏替换会得到下面的结果：

```c
if(echo_flag)
	{gets(str); puts(str);};
else
	gets(str);
```

编译器会将头两行作为完整的if语句：

```c
if(echo_flag)
	{gets(str);puts(str);}
```

编译器会将跟在后面的分号作为空语句，并且对else子句产生错误信息。因为它不属于任何if语句。只要不在ECHO宏后面加分号就可以解决这个问题。但是这样做会使程序看起来有点怪异。



逗号运算符可以解决ECHO宏的问题，但并不能解决所有宏的问题。假如一个宏需要包含一系列的语句，而不仅仅是一系列的表达式，这时逗号运算符就起不了作用了，因为它只能连接表达式，不能连接语句。解决的方法是将语句放在do循环中，并将条件设置为假（因此语句只会执行一次）：

```c
do{...}while{0}
```

注意，这个do语句是不完整的——后面还缺一个分号。为了看到这个技巧的的实际作用，让我们将它用于ECHO宏中：

```c
#define ECHO(s)			\
		do{				\
			gets(s);	\
			puts(s);	\
		}while(0)
```

当使用ECHO宏时，一定要加分号以使do语句完整：

```c
ECHO(str);
/* becomes do{gets(str);puts(str);} while(0);	*/
```

### 预定义宏

C语言有一些预定义宏，每个宏表示一个整数常量或字符串字面量。如下表所示，这些宏提供了当前编译或编译器本身的信息。



预定义宏：

| 名字       | 描述                                       |
| ---------- | ------------------------------------------ |
| `__LINE__` | 被编译的文件中的行号                       |
| `__FILE__` | 被编译的文件名                             |
| `__DATE__` | 编译的日期（格式“Mmm dd yyyy”）            |
| `__TIME__` | 编译的时间（格式"hh:mm:ss"）               |
| `__STDC__` | 如果编译器符合C标准（C89或C99），那么值为1 |

`__DATE__`宏和`__TIME__`宏指明程序编译的时间。例如，假设程序以下面的语句开始：

```c
printf("Wacky Windows (c) 2010 Wacky Software, Inc.\n");
printf("Compiled on %s at %s\n",__DATE__,__TIME__);
```

每次程序开始执行时，程序都会显示类似下面的两行：

```c
Wacky Windows (c) 2010 Wacky Software, Inc.
Compiled on Dec 23 2010 at 22:18:48
```

这样的信息可以帮助区分同一个程序的不同版本。



我们可以使用`__LINE__`宏和`__FILE__`宏来找到错误。考虑被零除的定位问题。当C程序因为被零除而导致终止时，通常没有信息指明哪条除法运算导致错误。下面的宏可以帮助查明错误的根源：

```c
#define CHECK_ZERO(divisor)		\
	if(divisor == 0)			\
		printf("*** Attempt to divide by zero on line %d "	\
				"of file %s	***\n",__LINE__,__FILE__)
```

CHECK_ZERO宏应该在除法运算前被调用：

```c
CHECK_ZERO(j);
k = i / j;
```

如果j是0，会显示出如下的信息：

```
*** Attempt to divide by zero on line 9 of file foo.c	***
```

类似这样的错误检测的宏非常有用。实际上，C语言库提供了一个通用的、用于错误检测的宏——assert宏。



如果编译器符合C标准（C89或C99），`__STDC__`宏存在且值为1。通过让预处理器测试这个宏，程序可以在早于C89标准的编译器下编译通过。



### C99中新增的预定义宏

C99中新增了几个预定义宏：

| 名字                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `__STDC_HOSTED__`        | 如果是托管式实现，值为1；如果是独立式实现，值为0             |
| `__STDC_VERSION__`       | 支持的C标准版本                                              |
| `__STDC_IEC_559__`       | 如果支持IEC 60559浮点算术运算，则值为1                       |
| `__STDC_IEC_559_COMPLEX` | 如果IEC 60559复数算术运算，则值为1                           |
| `__STDC_ISO_10646__`     | 如果wchar_t的值与指定年月的ISO 10646标准相匹配，则值为yyyymmL |



### 空的宏参数

C99允许宏调用中的任意或所有参数为空。当然这样的调用需要有和一般调用一样多的逗号（这样容易看出哪些参数被省略了）。



在大多数情况下，实际参数为空的效果是显而易见的。如果替换列表中出现相应的形式参数名，那么只要在替换列表中不出现实际参数即可，不需要作替换。例如：

```c
#define ADD(x,y) (x+y)
```

经过预处理之后，语句：

```c
i = ADD(j,k);
```

变成

```c
i = (j+k);
```

而赋值语句：

```c
i = ADD(,k);
```

则变为：

```c
i = (+k);
```

当空参数是`#`或`##`运算符的操作数时，用法有特殊规定。如果空的实际参数被`#`运算符“字符串化”，则结果为“”（空字符串）：

```c
#define MK_STR(x) #x
...
char empty_string[] = MK_STR();
```

预处理之后，上面的声明变成：

```c
char empty_string[] = "";
```

如果`##`运算符之后的一个实际参数为空，它将会被不可见的“位置标记”记号代替。把原始的记号与位置标记记号相连接，得到的还是原始的记号（位置标记记号消失了）。如果连接两个位置标记记号，得到的是一个位置标记记号。宏扩展完成后，位置标记记号从程序中消失。

考虑下面的例子：

```c
#define JOIN(x,y,z) x##y##z
...
int JOIN(a,b,c),JOIN(a,b,),JOIN(a,,c),JOIN(,,c);
```

预处理之后，声明变成：

```c
int abc,ab,ac,c;
```

漏掉的参数由位置标记记号代替，这些记号在与非空参数相连接之后消失。`JOIN`宏的3个参数可以同时为空，这样得到的结果为空。



### 参数个数可变的宏

在C89中，如果宏有参数，那么参数的个数是固定的。在C99中，这个条件被适当放宽了，允许宏有可变长度的参数列表。这个特性对于函数来说早就有了，所以应用于宏也不足为奇。



宏具有可变参数个数的主要原因是：它可以将参数传递给具有可变参数个数的函数，如`printf`和`scanf`。下面给出几个例子：

```c
#define TEST(condition,...)	((condition)?\
	printf("Passed test:%s\n",#condition):\
	printf(__VA_ARGS__))
```

`...`记号（省略号）出现在宏参数列表的最后，前面是普通参数。`__VA_ARGS__`是一个专用的标识符，只能出现在具有可变参数个数的宏的替换列表中，代表所有与省略号相对应的参数。（至少有一个与省略号对应的参数，但该参数可以为空。）宏TEST至少要有两个参数，第一个参数匹配condition，剩下的匹配省略号。



下面的这个例子说明了TEST的使用方法：

```c
TEST(voltage <= max_voltage,
		"Voltage %d exceeds %d\n",voltage,max_voltage);
```

预处理器将会产生如下的输出：

```c
((voltage <= max_voltage)?
	printf("Passed test:%s\n","voltage <= max_voltage"):
	printf("Voltage %d exceeds %d\n",voltage,max_voltage);
```

如果voltage不大于max_voltage，程序执行时将显示如下信息：

```
Passed test: voltage <= max_voltage
```

否则，将分别显示voltage和max_voltage的值：

```
voltage 125 exceeds 120
```



### `__func__`标识符

C99的另一个新特性是`__func__`标识符。`__func__`与预处理器无关，所以实际上与本章内容不相干。但是，与许多预处理器特性一样，它也有助于调试，所以在这里一并讨论。



每一个函数都可以访问`__func__`标识符，它的行为很像一个存储当前正在执行的函数的名字的字符串变量。其作用相当于在函数体的一开始包含如下声明：

```c
static const char __func__[] = "function-name";
```

其中`function-name`是函数名。这个标识符的存在使得我们可以写出如下的调试宏：

```c
#define FUNCTION_CALLED() printf("%s called\n",__func__);
#define FUNCTION_RETURNS() printf("%s returns\n",__func__);
```

对这些宏的调用可以放在函数体中，以跟踪函数的调用：

```c
void f(void)
{
	FUNCTION_CALLED();
	...
	FUNCTION_RETURNS();
}
```

`__func__`的另一个用法：作为参数传递给函数，让函数知道调用它的函数的名字。



## 条件编译

C语言的预处理器可以识别大量用于支持条件编译的指令。条件编译是指根据预处理器所执行的测试结果来包含或排除程序的片断。



### #if指令和#endif指令

假如正在调试一个程序。想要程序显示出特定变量的值，因此将printf函数调用添加到程序中重要的部分。一旦找到错误，经常需要保留这些printf函数调用，以便日后使用。条件编译允许我们保留这些调用，但是让编译器忽略它们。



下面是我们需要采取的方式。首先定义一个宏，并给它一个非零的值：

```c
#define DEBUG 1
```

宏的名字不重要。接下来，我们要在每组printf函数调用的前后加上`#if`和`#endif`：

```c
#if DEBUG
printf("Value of i: %d\n",i);
printf("Value of j: %d\n",j);
#endif
```

在预处理过程中，`#if`指令会测试`DEBUG`的值。由于DEBUG的值不是0，因此预处理器会将这两个`printf` 函数调用保留在程序中（但`#if`和`endif`行会消失）。如果我们将`DEBUG`的值改为0并重新编译程序，预处理器则会将这4行空间都删除。编译器不会看到这些`printf`函数调用，所以这些调用就不会在目标代码中占用空间，也不会在程序运行时消耗时间。我们可以将`#if-#endif`保留在最终的程序中，这样如果程序在运行时出现问题，可以（通过将DEBUG改为1并重新编译来）继续产生诊断信息。



值得注意的是，`#if`指令会把没有定义过的标识符当作是值为0的宏对待。因此，如果省略`DEBUG`的定义，测试

```c
#if DEBUG
```

会失败（但不会产生出错信息），而测试

```c
#if !DEBUG
```

会成功。



### defined运算符

14.3节中介绍过运算符`#`和`##`，还有一个专用于预处理器的运算符——`defined`。当`defined`应用于标识符时，如果标识符是一个定义过的宏则返回1，否则返回0。`defined`运算符通常与`#if`指令结合使用，可以这样写：

```c
#if defined(DEBUG)
...
#endif
```

仅当`DEBUG`被定义成宏时，`#if`和`#endif`之间的代码会被保留在程序中。`DEBUG`两侧的括号不是必需的，因此可以简单写成：

```c
#if defined DEBUG
```

由于`defined`运算符仅检测`DEBUG`是否有定义，所以不需要给`DEBUG`赋值：

```c
#define DEBUG
```



### #ifdef指令和#ifndef指令

`#ifdef`指令测试一个标识符是否已定义为宏：

```c
#ifdef 标识符
```

严格地说，并不需要`#ifdef`，因为可以结合`#if`指令和`defined`运算符来得到相同的效果。换言之，指令

```
#ifdef 标识符
```

等价于：

```
#if defined(标识符)
```



`#ifddef`指令和`#ifdef`指令类似，但测试的是标识符是否没有被定义为宏：

```
#ifndef 标识符
```

指令

```c
#ifndef 标识符
```

等价于

```c
#if !defined(标识符)
```



### #elif指令和#else指令

`#if`指令、`#ifdef`指令和`#ifndef`指令可以像普通的`if`语句那样嵌套使用。当发生嵌套时，最好随着嵌套层次的增加而增加缩进。一些程序员会对每一个`#endif`都加注释，来指明对应的`#if`指令测试哪个条件：

```c
#if DEBUG
...
#endif	/* DEBUG */
```

这种方法有助于更方便地找到`#if`指令的起始位置。



为了提供更多的便利，预处理器还支持`#elif`和`#else`指令：

```c
[#elif指令] #elif 常量表达式
[#else指令] #else
```



`elif`指令和`#else`指令可以与`#if`指令、`#ifdef`指令和`#ifndef`指令结合使用，来测试一系列条件：

```c
#if 表达式1
当表达式非0时需要包含的代码
#elif 表达上2
当表达式1为0但表达式非0时需要包含的代码
#else
其他情况下需要包含的代码
#endif
```

虽然上面的例子使用了`#if`指令，但`#ifdef`指令或`#infdef`指令也可以这样使用。在`#if`指令和`#endif`指令之间可以有任意多个`#elif`指令，但最多只能有一个`#else`指令。



### 使用条件编译

条件编译对于调试是非常方便的，但它的应用并不仅限于此。下面是其他常见的应用：

- 编写在多台机器或多种操作系统之间可移植的程序

  下面的例子会根据`WIN32`、`MAC_OS`或LINUX是否被定义为宏，而将三组代码之一包含到程序中:

  ```c
  #if defined(WIN32)
  ...
  #elif defined(MAC_OS)
  ...
  #elif defined(LINUX)
  ...
  #endif
  ```

  一个程序中可以包含许多这样的`#if`指令。在程序的开头会定义这些宏之一（而且只有一个），由此选择了一个特定的操作系统。例如，定义LINUX宏可以指明程序将运行在Linux操作系统下。

- 编写可以用不同的编译器编译的程序

  不同的编译器可以用于识别不同的C语言版本，这些版本之间会有一些差异。一些会接受标准C，另外一些则不会。一些版本会提供针对特定机器的语言扩展；有些版本则没有，或者提供不同的扩展集。条件编译可以使程序适应于不同的编译器。考虑一下为以前的非标准编译器编写程序的问题。`__STDC__`宏允许预处理器检测编译器是否支持标准(C89或C99)；如果不支持，则可能必须修改程序的某些方面，尤其是有可能必须用老式的函数声明替代函数原型。对于每一处函数声明，可以使用下面的代码：

  ```c
  #if __STDC__
  函数原型
  #else
  老式的函数声明
  #endif
  ```

- 为宏提供默认定义

  条件编译使我们可以检测一个宏当前是否已经被定义了，如果没有，则提供一个默认的定义。例如，如果宏`BUFFER_SIZE`此前没有被定义的话，下面的代码会给出定义：

  ```c
  #ifndef BUFFER_SIZE
  #define BUFFER_SIZE 256
  #endif
  ```



## 其他指令

最后，简要地了解一下`#error`指令、`#line`指令和`#pragma`指令。与前面讨论过的指令相比，这些指令更专业，使用频率也低得多。



### #error指令

`#error`指令有如下格式：

```
[#error 指令] #error 消息
```

其中，消息是任意的记号序列。如果预处理器遇到`#error`指令，它会显示一条包含消息的出错消息。对于不同的编译器，出错消息的具体形式也可能会不一样。格式可能类似：

```
Error directive: 消息
```

或者

```
#error 消息
```

遇到`#error`指令预示着程序中出现了严重的错误，有些编译器会立即终止编译而不再检测其他错误。



`#error`指令通常与条件编译指令一起用于检测正常编译过程中不应出现的情况。例如，假定我们需要确保一个程序无法在一台`int`类型不能存储100000的机器上编译。最大允许的int值用`INT_MAX`宏表示，所以我们需要做的就是当`INT_MAX`宏小于100000时调用`#error`指令：

```c
#if INT_MAX < 100000
#error int type is too small
#endif
```

如果试图在一台以16位存储整数的机器上编译这个程序，将产生一条出错消息：

```
Error directive: int type is too small
```

`#error`指令通常出现在`#if-#elif-#else`序列中的`#else`部分：

```c
#if defined(WIN32)
...
#elif defined(MAC_OS)
...
#elif defined(LINUX)
...
#else
#error No operating system specified
#endif
```

