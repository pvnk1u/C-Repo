# 预处理器

之前用到过`#define`与`#include`指令，但没有深入讨论。这些指令（以及还没有学到的指令）都是由预处理器处理的。预处理器是一个小软件，它可以在编译前处理C程序。C语言（和C++语言）因为依赖预处理器而不同于其他的编程语言。



预处理器是一种强大的工具，但它同时也可能是许多难以发现的错误的根源。此外，预处理器也可能被错误地用来编写出一些几乎不可能读懂的程序。尽管有些C程序员十分依赖于预处理器，但是依然建议适度地使用它。



## 预处理器的工作原理

预处理器的行为是由预处理指令（由#字符开头的一些命令）控制的。之前已经遇见过其中两种指令，即`#define`和`#include`。



`#define`指令定义了一个宏——用来代表其他东西的一个名字，例如常量或常用的表达式。预处理器会通过将宏的名字和它的定义存储在一起来响应`#define`指令。当这个宏在后面的程序中使用到时，预处理器”扩展“宏，将宏替换为其定义值。



`#define`指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分”包含“进来。例如，代码行

```c
#include <stdio.h>
```

指示预处理器打开一个名字为`stdio.h`的文件，并将它的内容加到当前的程序中。（`stdio.h`包含了C语言标准输入/输出函数的原型。）



以下是预处理器在编译过程中的作用：

> C程序中可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。预处理器的输出是另一个C程序：原程序编辑后的版本，不再包含指令。预处理器的输出被直接交给编译器，编译器检查程序是否有错误，并将程序翻译为目标代码（机器指令）。



为了展现预处理器的作用，以之前的`celsius.c`为例，下面是源程序：

```c

#include <stdio.h>

#define FREEZING_PT 32.0f
#define SCALE_FACTOR (5.0f / 9.0f)

int main(void) {
    float fahrenheit,celsius;

    printf("Enter Fahrenheit temperature: ");
    scanf("%f",&fahrenheit);

    celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

    printf("Celsius equivalent: %.1f\n",celsius);
    return 0;
}
```

预处理结束后，程序是下面的样子：

```c
空行
空行
从stdio.h中引入的行
空行
空行
空行
空行
int main(void){
	 float fahrenheit,celsius;

    printf("Enter Fahrenheit temperature: ");
    scanf("%f",&fahrenheit);

    celsius = (fahrenheit - 32.0f) * (5.0f/9.0f);

    printf("Celsius equivalent: %.1f\n",celsius);
    return 0;
}
```

预处理器通过引入`stdio.h`的内容来响应`#define`指令。预处理器也删除了`#define`指令，并且替换了该文件中稍后出现在任何位置上的`FREEZING_PT`和`SCALE_FACTOR`。请注意预处理器并没有删除包含指令的行，而是简单地将它们替换为空。



## 预处理指令

大多数预处理指令都属于下面3种类型之一。

- 宏定义

  `#define`指令定义一个宏，`#undef`指令删除一个宏定义。

- 文件包含

  `#include`指令导致一个指定文件的内容被包含到程序中

- 条件编译

  `#if`、`#ifdef`、`#ifndef`、`#elif`、`else`和`#endif`指令可以根据预处理器可以测试的条件来确定是将一段文本块包含到程序中还是将其排除在程序之外。



剩下的`#error`、`#line`和`#pragma`指令是更特殊的指令，较少用到。



在进一步讨论之前，先来看几条适用于所有指令的规则。

- 指令都以`#`开始

  `#`符号不需要在一行的行首，只要它之前只有空白字符就行。在`#`后是指令名，接着是指令所需要的其他信息。

- 在指令的符号之间可以插入任意数量的空格或水平制表符。例如，下面的指令是合法的：

  ```c
  #	define	N	100
  ```

- 指令总在第一个换行符处结束，除非明确地指明要延续。如果想在下一行延续指令，必须在当前行的末尾使用`\`字符。例如，下面的指令定义了一个宏来表示硬盘的容量，按字节计算：

  ```C
  #define DISK_CAPACITY(SIDES *	\
  						TRACKS_PER_SIDE *	\
  						SECTORS_PER_TRACK	*	\
  						BYTE_PER_SECTOR)
  ```

- 指令可以出现在程序的任何地方。但我们通常将`#define`和`#include`指令放在文件的开始，其他指令则放在后面，甚至可以放在函数定义的中间。

- 注释可以与指令放在同一行。实际上，在宏定义的后面加一个注释来解释宏的定义是一种比较好的习惯：

  ```c
  #define FREEZING_PT 32.0f	// freezing point of water
  ```



## 宏定义

之前一直使用的宏被称为简单的宏，它们没有参数。预编译器还支持带参数的宏。本节先讨论简单的宏，然后再讨论带参数的宏。在分别讨论它们之后，再研究一下两者共同的特性。



### 简单的宏

简单的宏（C标准中称为对象式宏）的定义有如下格式：

```
[#define指令 (简单的宏)] #define 标识号 替换列表
```

替换列表是一系列的预处理记号，本章中提及“记号”时均指的是“预处理记号”。



宏的替换列表可以包括标识符、关键字、数值常量、字符常量、字符串字面量、操作符和排列。当预处理器遇到一个宏定义时，会做一个“标识符”代表“替换列表”的记录。在文件后面的内容中，不管标识符在哪里出现，预处理器都会用替换列表来代替它。



不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用=：

```c
#define N = 100		/** WRONG **/
...
int a[N];			/** becomes int a[=100] **/
```

在上面的例子中，错误地把N定义成两个记号（= 和 100）。



在宏定义的末尾使用分号结尾是另一个常见错误：

```c
#define N 100; 	// WRONG
...
int a[N];		// becomes int a[100;];
```

编译器可以检测到宏定义中绝大多数由多余符号所导致的错误。但是，编译器只会将每一个使用这个宏的地方标为错误，而不会直接找到错误的根源——宏定义本身，因为宏定义已经被预处理器删除了。



简单的宏主要用来定义那些被称为“明示常量”的对象。可以使用宏给数值、字符值和字符串值命名。

```c
#define STE_LEN 80
#define TRUE 1
#define FALSE 0
#define PI 3.14159
#define CR '\r'
#define EOS '\0'
#define MEM_ERR "Error: not enough memory"
```

使用`#define`来为常量命名有很多显著的优点：

- 程序更易读

  一个认真选择的名字可以帮助读者理解常量的意义

- 程序会更易于修改

- 可以帮助避免前后不一致或输入错误

- 对类型重命名

  之前的章节中，曾经通过重命名`int`创建了一个布尔类型：

  ```c
  #define BOOL int
  ```

  虽然有些程序员会使用宏定义的方式来实现此目的，但类型定义（7.5节）仍然是定义新类型的最佳方法。

- 控制条件编译

  如果将看到的那样，宏在控制条件编译中起重要的作用。例如，在程序中出现的下面这行宏定义可能表明需要将程序在“调试模式”下进行编译，并使用额外的语句输出调试信息：

  ```c
  #define DEBUG
  ```



### 带参数的宏

