# 预处理器

之前用到过`#define`与`#include`指令，但没有深入讨论。这些指令（以及还没有学到的指令）都是由预处理器处理的。预处理器是一个小软件，它可以在编译前处理C程序。C语言（和C++语言）因为依赖预处理器而不同于其他的编程语言。



预处理器是一种强大的工具，但它同时也可能是许多难以发现的错误的根源。此外，预处理器也可能被错误地用来编写出一些几乎不可能读懂的程序。尽管有些C程序员十分依赖于预处理器，但是依然建议适度地使用它。



## 预处理器的工作原理

预处理器的行为是由预处理指令（由#字符开头的一些命令）控制的。之前已经遇见过其中两种指令，即`#define`和`#include`。



`#define`指令定义了一个宏——用来代表其他东西的一个名字，例如常量或常用的表达式。预处理器会通过将宏的名字和它的定义存储在一起来响应`#define`指令。当这个宏在后面的程序中使用到时，预处理器”扩展“宏，将宏替换为其定义值。



`#define`指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分”包含“进来。例如，代码行

```c
#include <stdio.h>
```

指示预处理器打开一个名字为`stdio.h`的文件，并将它的内容加到当前的程序中。（`stdio.h`包含了C语言标准输入/输出函数的原型。）



以下是预处理器在编译过程中的作用：

> C程序中可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。预处理器的输出是另一个C程序：原程序编辑后的版本，不再包含指令。预处理器的输出被直接交给编译器，编译器检查程序是否有错误，并将程序翻译为目标代码（机器指令）。



为了展现预处理器的作用，以之前的`celsius.c`为例，下面是源程序：

```c

#include <stdio.h>

#define FREEZING_PT 32.0f
#define SCALE_FACTOR (5.0f / 9.0f)

int main(void) {
    float fahrenheit,celsius;

    printf("Enter Fahrenheit temperature: ");
    scanf("%f",&fahrenheit);

    celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

    printf("Celsius equivalent: %.1f\n",celsius);
    return 0;
}
```

预处理结束后，程序是下面的样子：

```c
空行
空行
从stdio.h中引入的行
空行
空行
空行
空行
int main(void){
	 float fahrenheit,celsius;

    printf("Enter Fahrenheit temperature: ");
    scanf("%f",&fahrenheit);

    celsius = (fahrenheit - 32.0f) * (5.0f/9.0f);

    printf("Celsius equivalent: %.1f\n",celsius);
    return 0;
}
```

预处理器通过引入`stdio.h`的内容来响应`#define`指令。预处理器也删除了`#define`指令，并且替换了该文件中稍后出现在任何位置上的`FREEZING_PT`和`SCALE_FACTOR`。请注意预处理器并没有删除包含指令的行，而是简单地将它们替换为空。



## 预处理指令

大多数预处理指令都属于下面3种类型之一。

- 宏定义

  `#define`指令定义一个宏，`#undef`指令删除一个宏定义。

- 文件包含

  `#include`指令导致一个指定文件的内容被包含到程序中

- 条件编译

  `#if`、`#ifdef`、`#ifndef`、`#elif`、`else`和`#endif`指令可以根据预处理器可以测试的条件来确定是将一段文本块包含到程序中还是将其排除在程序之外。



剩下的`#error`、`#line`和`#pragma`指令是更特殊的指令，较少用到。



在进一步讨论之前，先来看几条适用于所有指令的规则。

- 指令都以`#`开始

  `#`符号不需要在一行的行首，只要它之前只有空白字符就行。在`#`后是指令名，接着是指令所需要的其他信息。

- 在指令的符号之间可以插入任意数量的空格或水平制表符。例如，下面的指令是合法的：

  ```c
  #	define	N	100
  ```

- 指令总在第一个换行符处结束，除非明确地指明要延续。如果想在下一行延续指令，必须在当前行的末尾使用`\`字符。例如，下面的指令定义了一个宏来表示硬盘的容量，按字节计算：

  ```C
  #define DISK_CAPACITY(SIDES *	\
  						TRACKS_PER_SIDE *	\
  						SECTORS_PER_TRACK	*	\
  						BYTE_PER_SECTOR)
  ```

- 指令可以出现在程序的任何地方。但我们通常将`#define`和`#include`指令放在文件的开始，其他指令则放在后面，甚至可以放在函数定义的中间。

- 注释可以与指令放在同一行。实际上，在宏定义的后面加一个注释来解释宏的定义是一种比较好的习惯：

  ```c
  #define FREEZING_PT 32.0f	// freezing point of water
  ```



## 宏定义

之前一直使用的宏被称为简单的宏，它们没有参数。预编译器还支持带参数的宏。本节先讨论简单的宏，然后再讨论带参数的宏。在分别讨论它们之后，再研究一下两者共同的特性。



### 简单的宏

简单的宏（C标准中称为对象式宏）的定义有如下格式：

```
[#define指令 (简单的宏)] #define 标识号 替换列表
```

替换列表是一系列的预处理记号，本章中提及“记号”时均指的是“预处理记号”。



宏的替换列表可以包括标识符、关键字、数值常量、字符常量、字符串字面量、操作符和排列。当预处理器遇到一个宏定义时，会做一个“标识符”代表“替换列表”的记录。在文件后面的内容中，不管标识符在哪里出现，预处理器都会用替换列表来代替它。



不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用=：

```c
#define N = 100		/** WRONG **/
...
int a[N];			/** becomes int a[=100] **/
```

在上面的例子中，错误地把N定义成两个记号（= 和 100）。



在宏定义的末尾使用分号结尾是另一个常见错误：

```c
#define N 100; 	// WRONG
...
int a[N];		// becomes int a[100;];
```

编译器可以检测到宏定义中绝大多数由多余符号所导致的错误。但是，编译器只会将每一个使用这个宏的地方标为错误，而不会直接找到错误的根源——宏定义本身，因为宏定义已经被预处理器删除了。



简单的宏主要用来定义那些被称为“明示常量”的对象。可以使用宏给数值、字符值和字符串值命名。

```c
#define STE_LEN 80
#define TRUE 1
#define FALSE 0
#define PI 3.14159
#define CR '\r'
#define EOS '\0'
#define MEM_ERR "Error: not enough memory"
```

使用`#define`来为常量命名有很多显著的优点：

- 程序更易读

  一个认真选择的名字可以帮助读者理解常量的意义

- 程序会更易于修改

- 可以帮助避免前后不一致或输入错误

- 对类型重命名

  之前的章节中，曾经通过重命名`int`创建了一个布尔类型：

  ```c
  #define BOOL int
  ```

  虽然有些程序员会使用宏定义的方式来实现此目的，但类型定义（7.5节）仍然是定义新类型的最佳方法。

- 控制条件编译

  如果将看到的那样，宏在控制条件编译中起重要的作用。例如，在程序中出现的下面这行宏定义可能表明需要将程序在“调试模式”下进行编译，并使用额外的语句输出调试信息：

  ```c
  #define DEBUG
  ```



### 带参数的宏

带参数的宏（也称为函数式宏）的定义有如下格式：

```
[#define指令 (带参数的宏)] #define标识符(X1,X2,...Xn)替换列表
```

在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏——其中`(X1,X2,...Xn)`是替换列表的一部分。



当预处理器遇到带参数的宏时，会将宏定义存储起来以便后面使用。在后面的程序中，如果任何地方出现了标识符(`Y1,Y2,...Yn`)格式的宏调用（其中`Y1,Y2,...Yn`是一系列记号），预处理器会使用替换列表替代——使用`Y1`替换`X1`，`Y2`替换`X2`，以此类推。



例如，假定我们定义了如下的宏：

```c
#define MAX(x,y)	((x)>(y)?(x):(y))
#define IS_EVEN(n) 	((n) % 2 == 0)
```

（宏定义中的圆括号比较多，后面将看到，这样做是有原因的。）如果后面的程序中有如下语句：

```c
i = MAX(j+k,m-n);
if(IS_EVEN(i)) i++;
```

预处理器会将这些行替换为：

```c
i = ((j+k) > (m-n) ? (j+k) : (m-n));
if(((i) %2 == 0)) i++;
```

如这个例子所示，带参数的宏经常用来作为简单的函数使用。MAX类似一个从两个值中选取较大值的函数，`IS_EVEN`则类似于一种当参数为偶数时返回1，否则返回0的函数。



下面的宏也类似于函数，但更为复杂：

```c
#define TOUPPER(c) ('a' <= (c) && (c) <= 'z' ? (c)-'a' + 'A' : (c))
```

这个宏检测字符c是否在`a`与`z`之间。如果在的话，这个宏会用c的值减去`a`再加上`A`，从而计算出c所对应的大写字母。如果c不在这个范围，就保留原来的c。(`<ctype.h>`头文件中提供了一个类似的函数`toupper`，它的可移植性更好。)



带参数的宏可以包含空的参数列表，如下例所示：

```c
#define getchar() getc(stdin)
```

空的参数列表不是必需的，但这样可以使`getchar`更像一个函数。（没错，这就是`<stdio.h>`中的`getchar`。后面的章节会看到，`getchar`经常实现为宏，也经常实现为函数。）



使用带参数的宏替代真正的函数有两个优点：

- 程序可能会稍微快些

  程序执行时调用函数通常会有些额外开销——存储上下文信息、复制参数的值等，而调用宏则没有这些运行开销。（C99的内联函数提供了一种不使用宏而避免这一开销的方法。）

- 宏更“通用”

  与函数的参数不同，宏的参数没有类型。因此，只要预处理器后的程序依然是合法的，宏可以接受任何类型的参数。例如，可以使用`MAX`宏从两个数中选出较大的一个，数的类型可以是`int`、`long`、`float`、`double`等。



但是带参数的宏也有一些缺点：

- 编译后的代码通常会变大。

  每一处宏调用都会导致插入宏的替换列表，由此导致程序的源代码增加（因此编译后的代码变大）。宏使用的越频繁，这种效果就越明显。当宏相互嵌套时，这个问题会相互叠加从而使程序更加复杂。

- 宏参数没有类型检查

  **当一个函数被调用时，编译器会检查每一个参数来确认它们是否是正确的类型。如果不是，要么将参数转换成正确的类型，要么由编译器产生一条出错消息。预处理器不会检查宏参数的类型，也不会进行类型转换。**

- 无法用一个指针来指向一个宏

  如之后将看到的，C语言允许指针指向函数，这在特定的编程条件下非常有用。宏会在预处理过程中被删除，所以不存在类似的“指向宏的指针”。因此，宏不能用于处理这些情况。

- 宏可能会不止一次地计算它的参数

  **函数对它的参数只会计算一次，而宏可能会计算两次甚至多次。如果参数有副作用，多次计算参数的值可能会产生不可预知的后果。考虑下面的例子，其中MAX的一个参数有副作用：**

  ```c
  n = MAX(i++;j);
  ```

  下面是这条语句在预处理之后的结果：

  ```c
  n = ((i++) > (j) ? (i++) : (j));
  ```

  **如果i大于j，那么i可能会被（错误地）增加两次，同时n可能被赋予错误的值。**



