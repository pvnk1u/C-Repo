到目前为止，我们所见的变量都只是标量：标量具有保存单一数据项的能力。C语言也支持聚合变量，这类变量可以存储一组一组的数值。在C语言中一共有两种聚合类型：数组和结构。



# 一维数组

数组是含有多个值数据值的数据结构，并且每个数据值都具有相同的数据类型。这些数据值称为元素，可以根据元素在数组中所处的位置把它们一个个地选出来。



最简单的数组类型就是一维数组，一维数组中的元素一个接一个地编排在单独一行内。



为了声明数组，需要指明数组元素的类型和数量。例如，为了声明数组a有10个int类型的元素，可以写成：

```c
int a[10];
```

数组的元素可以是任何类型，数组的长度可以用任何（整数）常量表达式指定。因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：

```c
#define N 10
...
int a[N];
```



## 数组下标

为了存取特定的数组元素，可以在写数组名的同时在后边加上一个用方括号围绕的整数值（地址偏移量）。数组元素始终从0开始，所以长度为n的数组元素的偏移量取值范围是从0到n-1。



形如a[i]的表达式是左值，所以数组元素可以像普通变量一样使用：

```c
a[0] = 1;
printf("%d\n",a[5]);
++a[i];
```

一般说来，如果数组包含T类型的元素，那么数组中的每个元素均视为T类型的变量。本例中，a[0]、a[5]和a[i]可以看作int类型变量。



数组和for循环结合在一起使用。许多程序所包含的for循环都是为了对数组中的每个元素执行一些操作。下面给出了在长度为N的数组上的一些常见操作示例。

```c
[惯用法] for(i=0;i<N;i++)
			a[i] = 0;			// 声明a数组
[惯用法] for(i=0;i<N;i++)
			scanf("%d",&a[i]);	// 将读取的数据写入a数组
[惯用法] for(i=0;i<N;i++)
			sum += a[i];		// 将a数组内的数相加
```

注意，在调用scanf函数读取数组元素时，就像对待普通变量一样，必须使用取地址符号&。



C语言不要求检查下标的范围。当下标超出范围时，程序可能执行不可预知的行为。下标超出范围的原因之一是：忘记了n元数组的索引是从0到n-1，而不是从1到n。下面的例子给出了由这种错误导致的奇异效果：

```c
int a[10],i;

for(i=1;i<=10;i++)
	a[i] = 0;
```

对于某些编译器来说，这个乍一看正确的for语句却产生了一个无限循环！当变量i的值变为10时，程序将数值0存储在a[10]中。但是a[10]这个元素并不存在，所以在元素a[9]后数值0立刻进入内存。如果内存中变量i放置在a[9]的后边（这是有可能的），那么变量i将会被重置为0，进而导致循环重新开始。



数组下标可以是任何整数表达式：

```c
a[i+j*10]=0；
```

表达式甚至可能会有副作用：

```c
i=0;
while(i<N)
	a[i++] = 0;
```

来追踪一下这段代码。在把变量i设置为0后，while语句判断变量i是否小于N。如果是，那么将数值0赋值给a[0]，随后i自增，然后重复循环。注意，a[++i]是不正确的，因为第一次循环体执行期间将会把0赋值给a[1]。



当数组下标有副作用时一定要注意。例如，下面这个循环想把数组b中的元素复制到数组a中，但它可能无法正常工作：

```c
i = 0;
while(i < N)
	a[i] = b[i++];
```

表达式a[i] = b[i++]访问并修改i的值，如第四章所述，这样会导致未定义的行为。当然，通过从下标中移走自增操作可以很容易避免此类问题的发生：

```c
for(i=0;i<N;i++)
	a[i] = b[i];
```



## 数组反向

第一个关于数组的程序要求用户录入一串数，然后按反向顺序输出这些数：

```
Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
In reverse order: 31 50 11 23 94 7 102 49 82 34
```

方法是在读入数时将其存储在一个数组中，然后反向遍历数组，一个接一个地显示出数组元素。换句话说，不会真的对数组中的元素进行反向。

```c

#include <stdio.h>

#define N 10

int main(void) {
    int a[N],i;

    printf("Enter %d numbers: ",N);
    for (i = 0;i< N;i++) {
        scanf("%d",&a[i]);
    }

    printf("In reverse order: ");
    for (i = N-1;i>=0;i--) {
        printf(" %d",a[i]);
    }
    printf("\n");
    return 0;
}
```

这个程序说明了宏和数组联合使用可以多么有效。如果以后需要改变数组的大小，只需要编辑N的定义并且重新编译程序就可以了，相关联的地方都不需要修改，连提示都是正确的。



## 数组初始化

像其他变量一样，数组也可以在声明时获得一个初始值。但是，数组初始化需要有些技巧，现在介绍一些，其他的留在后面介绍。



数组初始化式最常见的格式是一个用大括号括起来的常量表达式列表，常量表达式之间用逗号进行分隔：

```c
int a[10] = {1,2,3,4,5,6,7,8,9,10};
```

如果初始化式比数组短，那么数组中剩余的元素赋值为0：

```c
int a[10] = {1,2,3,4,5,6};
/* initial value of a is {1,2,3,4,5,6,0,0,0,0} */
```

利用这一特性，可以很容易地把数组初始化为全0：

```c
int a[10] = {0};
/* initial value of a is {0,0,0,0,0，0,0,0,0,0} */
```

初始化式完全为空是非法的，所以要在大括号内放上一个0。初始化式比要初始化的数组长也是非法的。



如果给定了初始化式，可以省略掉数组的长度：

```c
int a[] = {1,2,3,4,5,6,7,8,9,10};
```

编译器利用初始化式的长度来确定数组的大小。数组仍然有固定数量的元素（此例中为10），这跟明确地指定长度效果一样。



