到目前为止，我们所见的变量都只是标量：标量具有保存单一数据项的能力。C语言也支持聚合变量，这类变量可以存储一组一组的数值。在C语言中一共有两种聚合类型：数组和结构。



# 一维数组

数组是含有多个值数据值的数据结构，并且每个数据值都具有相同的数据类型。这些数据值称为元素，可以根据元素在数组中所处的位置把它们一个个地选出来。



最简单的数组类型就是一维数组，一维数组中的元素一个接一个地编排在单独一行内。



为了声明数组，需要指明数组元素的类型和数量。例如，为了声明数组a有10个int类型的元素，可以写成：

```c
int a[10];
```

数组的元素可以是任何类型，数组的长度可以用任何（整数）常量表达式指定。因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：

```c
#define N 10
...
int a[N];
```



## 数组下标

为了存取特定的数组元素，可以在写数组名的同时在后边加上一个用方括号围绕的整数值（地址偏移量）。数组元素始终从0开始，所以长度为n的数组元素的偏移量取值范围是从0到n-1。



形如a[i]的表达式是左值，所以数组元素可以像普通变量一样使用：

```c
a[0] = 1;
printf("%d\n",a[5]);
++a[i];
```

一般说来，如果数组包含T类型的元素，那么数组中的每个元素均视为T类型的变量。本例中，a[0]、a[5]和a[i]可以看作int类型变量。



数组和for循环结合在一起使用。许多程序所包含的for循环都是为了对数组中的每个元素执行一些操作。下面给出了在长度为N的数组上的一些常见操作示例。

```c
[惯用法] for(i=0;i<N;i++)
			a[i] = 0;			// 声明a数组
[惯用法] for(i=0;i<N;i++)
			scanf("%d",&a[i]);	// 将读取的数据写入a数组
[惯用法] for(i=0;i<N;i++)
			sum += a[i];		// 将a数组内的数相加
```

注意，在调用scanf函数读取数组元素时，就像对待普通变量一样，必须使用取地址符号&。



C语言不要求检查下标的范围。当下标超出范围时，程序可能执行不可预知的行为。下标超出范围的原因之一是：忘记了n元数组的索引是从0到n-1，而不是从1到n。下面的例子给出了由这种错误导致的奇异效果：

```c
int a[10],i;

for(i=1;i<=10;i++)
	a[i] = 0;
```

对于某些编译器来说，这个乍一看正确的for语句却产生了一个无限循环！当变量i的值变为10时，程序将数值0存储在a[10]中。但是a[10]这个元素并不存在，所以在元素a[9]后数值0立刻进入内存。如果内存中变量i放置在a[9]的后边（这是有可能的），那么变量i将会被重置为0，进而导致循环重新开始。



数组下标可以是任何整数表达式：

```c
a[i+j*10]=0；
```

表达式甚至可能会有副作用：

```c
i=0;
while(i<N)
	a[i++] = 0;
```

来追踪一下这段代码。在把变量i设置为0后，while语句判断变量i是否小于N。如果是，那么将数值0赋值给a[0]，随后i自增，然后重复循环。注意，a[++i]是不正确的，因为第一次循环体执行期间将会把0赋值给a[1]。



当数组下标有副作用时一定要注意。例如，下面这个循环想把数组b中的元素复制到数组a中，但它可能无法正常工作：

```c
i = 0;
while(i < N)
	a[i] = b[i++];
```

表达式a[i] = b[i++]访问并修改i的值，如第四章所述，这样会导致未定义的行为。当然，通过从下标中移走自增操作可以很容易避免此类问题的发生：

```c
for(i=0;i<N;i++)
	a[i] = b[i];
```

### 数组反向

第一个关于数组的程序要求用户录入一串数，然后按反向顺序输出这些数：

```
Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
In reverse order: 31 50 11 23 94 7 102 49 82 34
```

方法是在读入数时将其存储在一个数组中，然后反向遍历数组，一个接一个地显示出数组元素。换句话说，不会真的对数组中的元素进行反向。

```c

#include <stdio.h>

#define N 10

int main(void) {
    int a[N],i;

    printf("Enter %d numbers: ",N);
    for (i = 0;i< N;i++) {
        scanf("%d",&a[i]);
    }

    printf("In reverse order: ");
    for (i = N-1;i>=0;i--) {
        printf(" %d",a[i]);
    }
    printf("\n");
    return 0;
}
```

这个程序说明了宏和数组联合使用可以多么有效。如果以后需要改变数组的大小，只需要编辑N的定义并且重新编译程序就可以了，相关联的地方都不需要修改，连提示都是正确的。



## 数组初始化

像其他变量一样，数组也可以在声明时获得一个初始值。但是，数组初始化需要有些技巧，现在介绍一些，其他的留在后面介绍。



数组初始化式最常见的格式是一个用大括号括起来的常量表达式列表，常量表达式之间用逗号进行分隔：

```c
int a[10] = {1,2,3,4,5,6,7,8,9,10};
```

如果初始化式比数组短，那么数组中剩余的元素赋值为0：

```c
int a[10] = {1,2,3,4,5,6};
/* initial value of a is {1,2,3,4,5,6,0,0,0,0} */
```

利用这一特性，可以很容易地把数组初始化为全0：

```c
int a[10] = {0};
/* initial value of a is {0,0,0,0,0，0,0,0,0,0} */
```

初始化式完全为空是非法的，所以要在大括号内放上一个0。初始化式比要初始化的数组长也是非法的。



如果给定了初始化式，可以省略掉数组的长度：

```c
int a[] = {1,2,3,4,5,6,7,8,9,10};
```

编译器利用初始化式的长度来确定数组的大小。数组仍然有固定数量的元素（此例中为10），这跟明确地指定长度效果一样。



## 指定初始化式

经常有这样的情况：数组中只有相对较少的元素需要进行显式的初始化，而其他元素可以进行默认赋值。考虑下面这个例子：

```c
int a[15] = {0,0,29,0,0,0,0,0,0,7,0,0,0,0,48};
```

我们希望数组元素2为79，元素9为7，元素14为48，而其他元素为0。对于大数组，如果使用这种方式赋值，将是冗长和容易出错的（想象一下两个非0元素之间有200个0的情况）。



C99中的指定初始化式可以用于解决这一问题。上面的例子可以使用指定初始化式写为：

```c
int a[15] = {[2] = 29,[9]=7,[14]=48};
```

括号中的数字称为指示符。



除了可以使赋值变得更简短、更易读之外，指定初始化式还有一个优点：赋值的顺序不再是一个问题，我们也可以将先前的例子重新写为：

```c
int a[15] = {[14]=48,[9]=7,[2] = 29};
```



### 检查数中重复出现的数字

接下来这个程序用来检查数中是否有出现多于一次的数字。用户输入数后，程序显示信息Repeated digit或No Repeated digit：

```c
Enter a number: 28212
Repeated digit
```

数28212有一个重复的数字（即2），而9357这样的数则没有。



程序采用布尔值的数组跟踪数中出现的数字。名为digit_seen的数组元素的下标偏移量从0到9，对应于10个可能的数字。最初的时候，每个数组元素的值都为假。（digit_seen)的初始化式为{false}，这实际上只初始化了数组的第一个元素。但是，编译器会自动把其他元素初始化为0，而0跟false是相等的。



当给定数n时，程序一次一个地检查n的数字，并且把每次的数字存储在变量digit中，然后用这个数字作为数组digit_seen的下标索引。如果digit_seen[digit]为真，那么表示digit至少在n中出现了两次。另一方面，如果digit_seen[digit]为假，那么表示digit之前未出现过，因此程序会把digit_seen[digit]设置为真并且继续执行。

```c
#include <stdbool.h> // C99 only
#include <stdio.h>

int main(void) {
    bool digit_seen[10] = {false};
    int digit;
    long n;

    printf("Enter a number: ");
    scanf("%ld",&n);

    while (n > 0) {
        digit = n %10;
        if (digit_seen[digit])
            break;
        digit_seen[digit] = true;
        n /=10;
    }

    if (n > 0) {
        printf("Repeated digit\n");
    }else {
        printf("No repeated digit\n");
    }
    return 0;
}
```



这个程序用到了bool、true和false等名称，它们在C99的<stdbool.h>头中定义。如果使用的编译器不支持该头，需要自定义这些名称。一种做法是在main函数的上面加上下面几行：

```c
#define true 1
#define false 0
typedef int bool
```



注意，数n的类型为long，因此允许用户录入的最大数为2147483647（某些机器上可能更大）。



## 对数组使用sizeof运算符

**运算符sizeof可以确定数组的大小（字节数）。如果数组a有10个整数，那么sizeof(a)通常为40（假定每个整数占4个字节）。**



还可以用sizeof来计算数组元素（如a[0]）的大小。用数组的大小除以数组元素的大小可以得到数组的长度：

```c
sizeof(a) / sizeof(a[0])
```

当需要数组长度时，一些程序员采用上述这个表达式。例如，数组a的清零操作可以写成如下形式：

```c
for(i=0;i<sizeof(a) / sizeof(a[0]);i++)
	a[i] = 0;
```

如果使用这种方法，即使数组长度在日后需要改变，也不需要改变循环。当然，利用宏来表示数组的长度也有同样的好处，但是sizeof方法稍微好一些，因为不需要记忆宏的名字（有可能搞错）。



有些编译器会对表达式`i<sizeof(a) / sizeof(a[0])`给出一条警告消息，这稍微有点烦人。变量i的类型可能是int(有符号类型)，而sizeof返回的值类型为size_t（一种无符号类型）。如前面所说，把有符号整数和无符号整数相比较是很危险的，尽管在本例中这样做没问题（因为i和sizeof(a）/sizeof(a[0])都是非负值)。为了避免这一警告，可以把sizeof(a) / sizeof(a[0])强制转换为有符号整数：

```c
for(i=0;i<(int)(sizeof(a) / sizeof(a[0]));i++)    
	a[i] = 0;
```

表达式`(int)(sizeof(a) / sizeof(a[0]))`写起来不太方便，可以定义一个宏来表示它：

```c
#define SIZE((int)(sizeof(a)/ sizeof(a[0])))

for(i=0;i< SIZE;i++)
    a[0] = 0;
```

但是，返回来使用宏的话，sizeof的优势哪里去了呢？后面的章节将对这个问题进行回答（窍门是给宏加上“参数”，即带参数的宏）。
