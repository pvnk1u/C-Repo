到目前为止，我们所见的变量都只是标量：标量具有保存单一数据项的能力。C语言也支持聚合变量，这类变量可以存储一组一组的数值。在C语言中一共有两种聚合类型：数组和结构。



# 一维数组

数组是含有多个值数据值的数据结构，并且每个数据值都具有相同的数据类型。这些数据值称为元素，可以根据元素在数组中所处的位置把它们一个个地选出来。



最简单的数组类型就是一维数组，一维数组中的元素一个接一个地编排在单独一行内。



为了声明数组，需要指明数组元素的类型和数量。例如，为了声明数组a有10个int类型的元素，可以写成：

```c
int a[10];
```

数组的元素可以是任何类型，数组的长度可以用任何（整数）常量表达式指定。因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：

```c
#define N 10
...
int a[N];
```



## 数组下标

为了存取特定的数组元素，可以在写数组名的同时在后边加上一个用方括号围绕的整数值（地址偏移量）。数组元素始终从0开始，所以长度为n的数组元素的偏移量取值范围是从0到n-1。



形如a[i]的表达式是左值，所以数组元素可以像普通变量一样使用：

```c
a[0] = 1;
printf("%d\n",a[5]);
++a[i];
```

一般说来，如果数组包含T类型的元素，那么数组中的每个元素均视为T类型的变量。本例中，a[0]、a[5]和a[i]可以看作int类型变量。



数组和for循环结合在一起使用。许多程序所包含的for循环都是为了对数组中的每个元素执行一些操作。下面给出了在长度为N的数组上的一些常见操作示例。

```c
[惯用法] for(i=0;i<N;i++)
			a[i] = 0;			// 声明a数组
[惯用法] for(i=0;i<N;i++)
			scanf("%d",&a[i]);	// 将读取的数据写入a数组
[惯用法] for(i=0;i<N;i++)
			sum += a[i];		// 将a数组内的数相加
```

注意，在调用scanf函数读取数组元素时，就像对待普通变量一样，必须使用取地址符号&。



C语言不要求检查下标的范围。当下标超出范围时，程序可能执行不可预知的行为。下标超出范围的原因之一是：忘记了n元数组的索引是从0到n-1，而不是从1到n。下面的例子给出了由这种错误导致的奇异效果：

```c
int a[10],i;

for(i=1;i<=10;i++)
	a[i] = 0;
```

对于某些编译器来说，这个乍一看正确的for语句却产生了一个无限循环！当变量i的值变为10时，程序将数值0存储在a[10]中。但是a[10]这个元素并不存在，所以在元素a[9]后数值0立刻进入内存。如果内存中变量i放置在a[9]的后边（这是有可能的），那么变量i将会被重置为0，进而导致循环重新开始。



数组下标可以是任何整数表达式：

```c
a[i+j*10]=0；
```

表达式甚至可能会有副作用：

```c
i=0;
while(i<N)
	a[i++] = 0;
```

来追踪一下这段代码。在把变量i设置为0后，while语句判断变量i是否小于N。如果是，那么将数值0赋值给a[0]，随后i自增，然后重复循环。注意，a[++i]是不正确的，因为第一次循环体执行期间将会把0赋值给a[1]。



当数组下标有副作用时一定要注意。例如，下面这个循环想把数组b中的元素复制到数组a中，但它可能无法正常工作：

```c
i = 0;
while(i < N)
	a[i] = b[i++];
```

表达式a[i] = b[i++]访问并修改i的值，如第四章所述，这样会导致未定义的行为。当然，通过从下标中移走自增操作可以很容易避免此类问题的发生：

```c
for(i=0;i<N;i++)
	a[i] = b[i];
```

### 数组反向

第一个关于数组的程序要求用户录入一串数，然后按反向顺序输出这些数：

```
Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
In reverse order: 31 50 11 23 94 7 102 49 82 34
```

方法是在读入数时将其存储在一个数组中，然后反向遍历数组，一个接一个地显示出数组元素。换句话说，不会真的对数组中的元素进行反向。

```c

#include <stdio.h>

#define N 10

int main(void) {
    int a[N],i;

    printf("Enter %d numbers: ",N);
    for (i = 0;i< N;i++) {
        scanf("%d",&a[i]);
    }

    printf("In reverse order: ");
    for (i = N-1;i>=0;i--) {
        printf(" %d",a[i]);
    }
    printf("\n");
    return 0;
}
```

这个程序说明了宏和数组联合使用可以多么有效。如果以后需要改变数组的大小，只需要编辑N的定义并且重新编译程序就可以了，相关联的地方都不需要修改，连提示都是正确的。



## 数组初始化

像其他变量一样，数组也可以在声明时获得一个初始值。但是，数组初始化需要有些技巧，现在介绍一些，其他的留在后面介绍。



数组初始化式最常见的格式是一个用大括号括起来的常量表达式列表，常量表达式之间用逗号进行分隔：

```c
int a[10] = {1,2,3,4,5,6,7,8,9,10};
```

如果初始化式比数组短，那么数组中剩余的元素赋值为0：

```c
int a[10] = {1,2,3,4,5,6};
/* initial value of a is {1,2,3,4,5,6,0,0,0,0} */
```

利用这一特性，可以很容易地把数组初始化为全0：

```c
int a[10] = {0};
/* initial value of a is {0,0,0,0,0，0,0,0,0,0} */
```

初始化式完全为空是非法的，所以要在大括号内放上一个0。初始化式比要初始化的数组长也是非法的。



如果给定了初始化式，可以省略掉数组的长度：

```c
int a[] = {1,2,3,4,5,6,7,8,9,10};
```

编译器利用初始化式的长度来确定数组的大小。数组仍然有固定数量的元素（此例中为10），这跟明确地指定长度效果一样。



## 指定初始化式

经常有这样的情况：数组中只有相对较少的元素需要进行显式的初始化，而其他元素可以进行默认赋值。考虑下面这个例子：

```c
int a[15] = {0,0,29,0,0,0,0,0,0,7,0,0,0,0,48};
```

我们希望数组元素2为79，元素9为7，元素14为48，而其他元素为0。对于大数组，如果使用这种方式赋值，将是冗长和容易出错的（想象一下两个非0元素之间有200个0的情况）。



C99中的指定初始化式可以用于解决这一问题。上面的例子可以使用指定初始化式写为：

```c
int a[15] = {[2] = 29,[9]=7,[14]=48};
```

括号中的数字称为指示符。



除了可以使赋值变得更简短、更易读之外，指定初始化式还有一个优点：赋值的顺序不再是一个问题，我们也可以将先前的例子重新写为：

```c
int a[15] = {[14]=48,[9]=7,[2] = 29};
```



### 检查数中重复出现的数字

接下来这个程序用来检查数中是否有出现多于一次的数字。用户输入数后，程序显示信息Repeated digit或No Repeated digit：

```c
Enter a number: 28212
Repeated digit
```

数28212有一个重复的数字（即2），而9357这样的数则没有。



程序采用布尔值的数组跟踪数中出现的数字。名为digit_seen的数组元素的下标偏移量从0到9，对应于10个可能的数字。最初的时候，每个数组元素的值都为假。（digit_seen)的初始化式为{false}，这实际上只初始化了数组的第一个元素。但是，编译器会自动把其他元素初始化为0，而0跟false是相等的。



当给定数n时，程序一次一个地检查n的数字，并且把每次的数字存储在变量digit中，然后用这个数字作为数组digit_seen的下标索引。如果digit_seen[digit]为真，那么表示digit至少在n中出现了两次。另一方面，如果digit_seen[digit]为假，那么表示digit之前未出现过，因此程序会把digit_seen[digit]设置为真并且继续执行。

```c
#include <stdbool.h> // C99 only
#include <stdio.h>

int main(void) {
    bool digit_seen[10] = {false};
    int digit;
    long n;

    printf("Enter a number: ");
    scanf("%ld",&n);

    while (n > 0) {
        digit = n %10;
        if (digit_seen[digit])
            break;
        digit_seen[digit] = true;
        n /=10;
    }

    if (n > 0) {
        printf("Repeated digit\n");
    }else {
        printf("No repeated digit\n");
    }
    return 0;
}
```



这个程序用到了bool、true和false等名称，它们在C99的<stdbool.h>头中定义。如果使用的编译器不支持该头，需要自定义这些名称。一种做法是在main函数的上面加上下面几行：

```c
#define true 1
#define false 0
typedef int bool
```



注意，数n的类型为long，因此允许用户录入的最大数为2147483647（某些机器上可能更大）。



## 对数组使用sizeof运算符

**运算符sizeof可以确定数组的大小（字节数）。如果数组a有10个整数，那么sizeof(a)通常为40（假定每个整数占4个字节）。**



还可以用sizeof来计算数组元素（如a[0]）的大小。用数组的大小除以数组元素的大小可以得到数组的长度：

```c
sizeof(a) / sizeof(a[0])
```

当需要数组长度时，一些程序员采用上述这个表达式。例如，数组a的清零操作可以写成如下形式：

```c
for(i=0;i<sizeof(a) / sizeof(a[0]);i++)
	a[i] = 0;
```

如果使用这种方法，即使数组长度在日后需要改变，也不需要改变循环。当然，利用宏来表示数组的长度也有同样的好处，但是sizeof方法稍微好一些，因为不需要记忆宏的名字（有可能搞错）。



有些编译器会对表达式`i<sizeof(a) / sizeof(a[0])`给出一条警告消息，这稍微有点烦人。变量i的类型可能是int(有符号类型)，而sizeof返回的值类型为size_t（一种无符号类型）。如前面所说，把有符号整数和无符号整数相比较是很危险的，尽管在本例中这样做没问题（因为i和sizeof(a）/sizeof(a[0])都是非负值)。为了避免这一警告，可以把sizeof(a) / sizeof(a[0])强制转换为有符号整数：

```c
for(i=0;i<(int)(sizeof(a) / sizeof(a[0]));i++)    
	a[i] = 0;
```

表达式`(int)(sizeof(a) / sizeof(a[0]))`写起来不太方便，可以定义一个宏来表示它：

```c
#define SIZE((int)(sizeof(a)/ sizeof(a[0])))

for(i=0;i< SIZE;i++)
    a[0] = 0;
```

但是，返回来使用宏的话，sizeof的优势哪里去了呢？后面的章节将对这个问题进行回答（窍门是给宏加上“参数”，即带参数的宏）。



### 计算利息

下面这个程序显示一个表格，这个表格显示了在几年时间内100美元投资在不同利率下价值。用户输入利率和要投资的年数。投资总价值每年计算一次，表格将显示出在输入利率和紧随其后的4个更高的利率下投资的总价值。程序会话如下：

```
Enter interest rate: 6
Enter number of years: 5


Years     6     7     8     9    10
  1      106.00 107.00 108.00 109.00 110.00
  2      112.36 114.49 116.64 118.81 121.00
  3      119.10 122.50 125.97 129.50 133.10
  4      126.25 131.08 136.05 141.16 146.41
```

很明显地，可以使用for语句显示出第一行信息。第二行的显示有点小窍门，因为它的值要依赖于第一行的数。我们的解决方案是在计算第一行的数时把它们存储到数组中，然后使用数组中的这些值计算第二行的内容。当然，从第三行到最后一行可以重复这个过程。我们总共需要用到两个for语句，其中一个嵌套在另一个里面。外层循环将从1计数到用户要求的年数，内层循环将从利率的最低值递增到最高值。



```c
#include <stdio.h>

#define NUM_RATES ((int) (sizeof(value) / sizeof(value[0])))
#define INITIAL_BALANCE 100.00

int main(void) {
    int i,low_rate,num_years,year;
    double value[5];

    printf("Enter interest rate: ");
    scanf("%d",&low_rate);
    printf("Enter number of years: ");
    scanf("%d",&num_years);

    printf("\nYears");
    for (i = 0; i < NUM_RATES; ++i) {
        printf("%6d",low_rate+i);
        value[i] = INITIAL_BALANCE;
    }
    printf("\n");

    for (year = 1;year<num_years;year++) {
        printf("%3d     ",year);
        for (i = 0; i < NUM_RATES; ++i) {
            value[i] += (low_rate+i) / 100.0 *value[i];
            printf("%7.2f",value[i]);
        }
        printf("\n");
    }
    return 0;
}
```

注意，这里使用NUM_RATES控制两个for循环。如果以后改变数组value的大小，循环将会自动调整。



## 多维数组

数组可以有任意维数。例如，下面的声明产生一个二维数组（或者按数学上的术语称为矩阵）：

```c
int m[5][9];
```

数组m有5行9列。数组的行和列下标都从0开始索引。



为了访问i行j列的元素，需要写成`m[i][j]`的形式。表达式m[i]指明了数组的第i行，而`m[i][j]`则选择了此行中的第j个元素。



虽然我们以表格形式显示二维数组，但是实际上它们在计算机的内存中不是这样存储的。C语言是按照`行主序`存储数组的，也就是从第0行开始，接着第1行，依次类推。例如，下面显示了数组m的存储：

```
m[0][0] ->...-> m[0][8] -> m[1][0] ->....->m[1][8]->...->m[4][0]->...m[4][8]
```

通常我们会忽略这一细节，但有时它会对我们的代码有影响。



就像for循环和一维数组紧密结合一样，嵌套的for循环是处理多维数组的理想选择。例如，思考用作单位矩阵的数组的初始化问题。（数学中，单位矩阵在主对角线上的值为1，而其他地方的值为0，其中主对角线上行、列的索引值是完全相同的。）在某些系统方式中，我们需要访问数组中的每一个元素。一对嵌套的for循环可以很好地完成这项工作——一个循环遍历每一行，另一个循环遍历每一列：

```c
#define N 10

double ident[N][N];

int row,col;

for(row=0;row<N;row++)
	for(col=0;col<N;col++)
		if(row == col)
			ident[row][col] = 1.0;
		else
			ident[row][col] = 0.0;
```

和其他编程语言中的多维数组相比，C语言中的多维数组扮演的角色相对较弱，这主要是因为C语言为存储多维数据提供了更加灵活的方法：指针数组。



### 多维数组初始化

通过嵌套一维初始化式的方法可以产生二维数组的初始化式：

```c
int a[5][9] =  {{1,1,1,1,1,0,1,1,1},
				{0,1,0,1,0,1,0,1,0},
				{0,1,0,1,1,0,0,1,0},
				{1,1,0,1,0,0,0,1,0},
				{1,1,0,1,0,0,1,1,1}};
```

每一个内部初始化式提供了矩阵中一行的值。为高维数组构造初始化式可采用类似的方法。



C语言为多维数组提供了多种方法来缩写初始化式。

1. 如果初始化式没有大到足以填满整个多维数组，那么把数组中剩余的元素赋值为0。例如，下面的初始化式只填充了数组m的前三行，后面的两行将赋值为0：

   ```c
   int m[5][9] = {{1,1,1,1,1,0,1,1,1},
   			   {0,1,0,1,0,1,0,1,0},
   			   {0,1,0,1,1,0,0,1,0}};
   ```

2. 如果内层的列表没有大到足以填满数组的一行，那么把此行剩余的元素初始化为0：

   ```c
   int m[5][9] = {{1,1,1,1,1,0,1,1,1},
   			   {0,1,0,1,0,1,0,1},
   			   {0,1,0,1,1,0,0,1},
                  {1,1,0,1,0,0,0,1},
                  {1,1,0,1,0,0,1,1,1}};
   ```



C99的指定初始化式对多维数组也有效。例如，可以这样创建2*2的单位矩阵：

```c
double ident[2][2] = {[0][0]=1.0,[1][1]=1.0}
```

像通常一样，没有指定值的元素都默认置为0。



### 常量数组

无论一维数组还是多维数组，都可以通过在声明的最开始处加上单词const而成为“常量”：

```c
const char hex_chars[] = 
	{'0','1','2','3','4','5','6','7','8','9',
     'A','B','C','D','E','F'};
```

程序不应该对声明为const的数组进行修改，编译器能检测到直接修改某个元素的意图。



把数组声明为const有两个主要的好处。它表明程序不会改变数组，这对于以后阅读程序的人可能是有价值的信息。它还有助于编译器发现错误——const会告诉编译器我们不打算修改数组。



const类型限定符不限于数组，后面将看到，它可以和任何变量一起使用。但是，const在数组中特别有用，因为数组经常含有一些在程序执行过程中不会发生改变的参考信息。



### 发牌

下面这个程序说明了二维数组和常量数组的用法。程序负责发一副标准纸牌。每张标准纸牌都有一个花色（梅花、方块、红桃或黑桃）和一个等级（2、3、4、5、6、7、8、9、10、J、Q、K或A）。程序需要用户指明手里应该握有几张牌：

```
Enter number of cards in hand: 5
Your hand: 7c 2s 5d as 2h
```

不能明显地看出如何编写这样一个程序。如何从一副牌中随机抽取纸牌呢？如何避免两次抽到同一张牌呢？下面将分别处理这两个问题。



为了随机抽取纸牌，可以采用一些C语言的库函数。time函数（来自于<time.h>）返回当前的时间，用一个数表示。srand函数(来自于stdlib.h)初始化c语言的随机数生成器。通过把time函数的返回值传递给函数srand可以避免程序在每次运行时发同样的牌。rand函数(来自于stdlib.h)在每次调用时会产生一个看似随机的数。通过采用运算符%，可以缩放rand函数的返回值，使其落在0~3（用于表示牌的花色）的范围内，或者是落在0~12（用于表示纸牌的等级）的范围内。



为了避免两次都拿到同一张牌，需要记录已经选择过的牌。为了这个目的，程序将采用一个名为in_hand的二维数组，数组有4行（每行表示一种花色）和13列（每列表示一种等级）。换句话说，数组中的每个元素对应着52张纸牌中的一张。在程序开始时，所有数组元素都为假。每次随机抽取一张纸牌时，将检查数组in_hand中的对应元素是真还是假。如果为真，那么就需要抽取其他纸牌；如果为假，则把true存储到与这张牌相对应的数组元素中，以提醒我们这张纸牌已经抽取过了。



一旦证实纸牌是“新”的（还没被选取过），就需要把牌的等级和花色数值翻译成字符，然后显示出来。为了把纸牌的等级和花色翻译成字符格式，程序将设置两个字符数组（一个用于纸牌的等级，另一个用于纸牌的花色），然后用等级和花色对数组取下标。这两个字符数组在程序执行期间不会发生改变，所以也可以把它们声明成const。

```c
#include <stdbool.h>  /*C99 ONLY*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NUM_SUITS 4
#define NUM_RANKS 13


int main(void) {
    bool in_hand[NUM_SUITS][NUM_RANKS] = {false};
    int num_cards,rank,suit;

    const char rank_code[] = {'2','3','4','5','6','7','8',
                                '9','t','j','q','k','a'};

    const char suit_code[] = {'c','d','h','s'};

    /**
     * srand函数初始化c语言的随机数生成器。通过把time函数的返回值传递给srand可以避免在每次运行时发同样的牌
     */
    srand((unsigned) time(NULL));

    printf("Enter number of cards in head: ");
    scanf("%d",&num_cards);

    printf("Your hand:");
    while (num_cards > 0) {
        suit =rand() % NUM_SUITS;
        rank = rand() % NUM_RANKS;
        if (!in_hand[suit][rank]) {
            in_hand[suit][rank] = true;
            num_cards--;
            printf(" %c%c",rank_code[rank],suit_code[suit]);
        }
    }
    printf("\n");
    return 0;
}
```

注意，数组in_hand的初始化式：

```c
bool in_hand[NUM_SUITS][NUM_RANKS] = {false};
```

尽管in_hand是二维数组，C语言仍允许只使用一对花括号（不过编译器可能会产生警告消息）。跟前面一样，由于我们在初始化式中只给出了一个值，编译器会把其他数组元素填充为0（假）。



## C99中的变长数组

之前说到，数组变量的长度必须用常量表达式进行定义。但是在C99中，有时候也可使用非常量表达式。下面是reverse.c程序的修改版，其中用到了变长数组。

```c
#include <stdio.h>


int main(void) {
    int i,n;

    printf("How many numbers do you want to reverse? ");
    scanf("%d",&n);

    int a[n];  /* C99 ONLY */

    printf("Enter %d numbers:", n);
    for (int i = 0; i < n; i++){
        scanf("%d",&a[i]);
    }
    printf("In reverse order:");
    for (i = n-1;i>=0;i--)
        printf(" %d",a[i]);
    printf("\n");
    return 0;
}
```

上面程序中的数组a是一个变长数组（VLA）。变长数组的长度是在程序执行时计算的，而不是在程序编译时计算的。变长数组的主要优点是程序员不必在构造数组时随便给定一个长度，程序在执行时可以准确地计算出所需的元素个数。如果让程序员来指定长度，数组可能过长（浪费内存）或过短（导致程序出错）。在新版本程序中，数组a的长度由用户的输入确定而不是由程序员指定一个固定的值，这是与老版本不同的地方。



变长数组的长度不一定要用变量来指定，任意表达式（可以含有运算符）都可以。例如：

```c
int a[3*i+5];
int b[j+k];
```

像其他数组一样，变长数组也可以是多维的：

```c
int c[m][n];
```

变长数组的主要限制是它们没有静态存储期限（目前还没有发现具有这一特性的数组），另一个限制是变长数组没有初始化式。



变长数组常见于除main函数以外的其他函数。对于函数f而言，变长数组的最大优势就是每次调用f时长度可以不同（后续将讲述这一特性）。







