# 基本类型

到目前为止，只使用了C语言的两种基本（内置的）类型：int和float。（还见过_Bool，那是C99中的一种基本类型。）本章讲述其余的基本类型，并从整体上讨论有关的重要问题。首先展示整数类型的取值范围，包括长整型、短整型和无符号整型。然后介绍double类型和long double类型，这些类型提供了更大的取值范围和比float类型更高的精度。然后将讨论char（字符）类型，这种类型将用于字符数据的处理。还将讨论解决重要的类型转换问题，即把一种类型的值转换成另外一种类型的等价值。随后展示利用typeof定义新类型名的方法。最后，描述sizeof运算符，这种运算符用来计算一种类型需要的存储空间大小。



## 整数类型

C语言支持两种根本不同的数值类型：整数类型（也称整型）和浮点类型（也称浮点型）。整型类型的值是整数，而浮点类型的值则可能还有小数部分。整数类型又分为两大类：有符号型和无符号型。



### 有符号整数和无符号整数

有符号整数如果为正数或零，那么最左边的位（符号位）为0；如果为负数，则符号位为1。因此，最大的16位整数的二进制表示形式是0111111111111111，对应的值是32767（即2^15 -1）。而最大的32位整数是01111111111111111111111111111111，对应的数值是2147483647（即2^31-1）。不带符号位的整数（最左边的位是数值的一部分）的整数称为无符号整数。最大的16位无符号整数是65535（即2^16-1），而最大的32位无符号整数是4294967295（即2^32-1）。



**默认情况下，C语言中的整型变量都是有符号的，也就是说最左位保留为符号位。若要告诉编译器变量没有符号位，需要把它声明成unsigned类型。无符号整数主要用于系统编程和底层与机器相关的应用。后面的章节将讨论无符号整数的常见应用，在此之前，通常回避无符号整数。**



C语言的整数类型有不同的尺寸。int类型通常为32位，但在老的CPU上可能是16位。有些程序所需的数很大，无法以int类型存储，所以C语言还提供了长整型。某些时候，为了节省空间，通常会指示编译器以比正常存储小的空间来存储一些数，这样的数称为短整型。



**为了使构造的整数类型正好满足需要，可以指明变量是long类型或short类型，signed类型或unsigned类型，甚至可以把说明符组合起来（如long unsigned in）。**然而，实际上只有下列6种组合可以产生不同的类型：

```c
short int
unsigned short int

int
unsigned int

long int
unsigned long int
```

 其他组合都是上述某种类型的同义词。（例如，除非额外说明，否则所有整数都是有符号的。因此long signed int和long int是一样的类型。）另外，说明符的顺序没什么影响，所以unsigned short int和short unsigned int是一样的。



C语言允许通过省略单词int来缩写整数类型的名字。例如，unsigned short int可以缩写为unsigned short，而long int则可以缩写为long。C程序员经常会省略int；Java等语言甚至不允许程序员使用short int或long int这样的名字，而必须写成short或long。



6种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则。首先，C标准要求short int、int和long int中的每一种类型都要覆盖一个确定的最小取值范围。其次，标准要求int类型不能比short int类型短，long int类型不能比int类型短。但是，short int类型的取值范围有可能和int类型的范围是一样的，int类型的取值范围也可以和long int的一样。



下图说明了在16位机上整数类型通常的取值范围，注意short int和int有相同的取值范围：

| 类型               | 最小值      | 最大值     |
| ------------------ | ----------- | ---------- |
| short int          | -32768      | 32767      |
| unsigned short int | 0           | 65535      |
| int                | -32768      | 32767      |
| unsigned int       | 0           | 65535      |
| long int           | -2147483648 | 2147483647 |
| unsigned long int  | 0           | 4294967295 |



下表说明了32位机上整数类型通常的取值范围，这里的int和long int有着相同的取值范围：

| 类型               | 最小值      | 最大值     |
| ------------------ | ----------- | ---------- |
| short int          | -32768      | 32767      |
| unsigned short int | 0           | 65535      |
| int                | -2147483648 | 2147483647 |
| unsigned int       | 0           | 4294967295 |
| long int           | -2147483648 | 2147483647 |
| unsigned long int  | 0           | 4294967295 |



下表给出了64位机上（尤其是UNIX系统下）整数类型常见的取值范围：

| 类型               | 最小值               | 最大值               |
| ------------------ | -------------------- | -------------------- |
| short int          | -32768               | 32767                |
| unsigned short int | 0                    | 65535                |
| int                | -2147483648          | 2147483647           |
| unsigned int       | 0                    | 4294967295           |
| long int           | -9223372036854775808 | 9223372036854775807  |
| unsigned int       | 0                    | 18446744073709551615 |



再强调一下，上面三个表中给出的取值范围不是C标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查<limits.h>头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。



### C99中的整数类型

C99提供了两个额外的标准整数类型：long long int和unsigned long long int。增加这两种整数类型有两个原因，一是为了满足日益增长的对超大型整数的需求，二是为了适应支持64位运算的新处理器的能力。这两个long long类型要求至少64位宽，所以long long int类型值的范围通常为-2^63(-9223372036854775808)到2^63-1(9223372036854775807)，而unsigned long long int类型值的范围通常为0到2^64-1（18446744073709551615）。



C99中把short int、int、long int和long long int类型（以及signed char类型）称为标准有符号整型，而把unsigned short int、unsigned int、unsigned long int和unsigned long long int类型（以及unsigned char类型）和_Bool类型称为标准无符号整型。



除了标准的整数类型以外，C99标准还允许在具体实现时定义扩展的数类整型（包括有符号的和无符号的）。例如，编译器可以提供有符号和无符号的128位整数类型。



### 整数常量

现在把注意力转向常量——在程序中以文本形式出现的数，而不是读、写或计算出来的数。C语言允许用十进制（基数为10）、八进制（基数为8）和十六进制（基数为16）形式书写整数常量。



**八进制数和十六进制数**

八进制是用数字0~7书写的。八进制数的每一位表示一个8的幂（这就如同十进制数的每一位表示10的幂一样）。因此，八进制的数237表示成十进制数就是`2*8^2+3*8^1+7*8^0=128+24+7=159`。



十六进制是用数字0~9加上字母A~F书写的。其中字母A~F表示10~15的数。十六进制数的每一位表示一个16的幂，十六进制数1AF的十进制数值是`1*16v^2+10*16^1+15*16^0=256+160+15=431`。



- 十进制常量包含0~9中的数字，但是一定不能以零开头：

  15	255	32767

- 八进制常量只包含0~7中的数字，而且必须要以零开头：

  017	0377 	077777

- 十六进制常量包含0~9中的数字和a~f中的字母，而且总是以0x开头：

  0xf	0xff	0x7fff



十六进制常量中的字母既可以是大写字母也可以是小写字母。



**需要切记的是八进制和十六进制只是书写数的方式，它们不会对数的实际存储方式产生影响。（整数都是以二进制形式存储的，跟表示方式无关。）任何时候都可以从一种书写形式切换到另一种书写形式，甚至可以混合使用：10+015 + 0x20的值为55（十进制）。八进制和十六进制更适合底层程序的编写。**直到第20章才会较多地用到它们。



**十进制整数常量的类型通常为int，但如果常量的值大得无法存储在int型中，就用long int类型。如果出现long int不够用得罕见情况，编译器会用unsigned long int作最后的尝试。确定八进制和十六进制常量得规则略有不同：编译器会依次尝试int、unsigned int、long int和unsigned long int类型，直至找到能表示该常量的类型。**



为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母L（或l）：

```
15L 0377L 0x7fffl
```

为了指明是无符号常量，可以在常量后边加上字母U（或u）：

```
15U 0377U 0x7fffu
```

L和U可以结合使用，以表明常量既是长整型又是无符号的：0xffffffffUL。（字母L、U的顺序和大小写无所谓。）



### C99中的整数常量

在C99中，以LL或ll（两个字母大小写要一致）结尾的整数常量是long long int型的。如果在LL或ll的前面或后面增加字母U（或u），则代表该整数常量为unsigned long long int型。



C99确定整数常量类型的规则与C89有些不同。对于没有后缀（U、u、L、l、LL、ll）的十进制常量，其类型是int、long int或long long int中能表示该值的最小类型。对于八进制或者十六进制常量，可能的类型顺序为int、unsigned int、long int、unsigned long int、long long int和unsigned long long int。常量后面的任何后缀都会改变可能类型的列表。例如，以U（或u）结尾的常量类型一定是unsigned int、unsigned long int和unsigned long long int中的一种，以L（或l）结尾的十进制常量类型一定是long int或long long int中的一种。如果常量的数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。



### 整数溢出

对整数执行算术运算时，其结果有可能因为过大而无法表示。例如，对两个int值进行算术运算时，结果必须仍然能用int类型来表示；否则就会发生溢出。



整数溢出时的行为要根据操作数是有符号型还是无符号型来确定。有符号整数运算中发生溢出时，程序的行为是未定义的。未定义行为的结果是不确定的。最可能的情况是，仅仅是运算的结果出错了，但程序也有可能崩溃，或出现其他意想不到的状况。



### 读/写整数

假设有一个程序因为其中一个int变量发生了"溢出"而无法工作。我们的第一反应是把变量的类型从int变为long int。但仅仅这样做是不够的，还必须检查数据类型的改变对程序其他部分的影响，尤其是需要检查该变量是否用在printf函数或scanf函数的调用中。如果用了，需要改变调用中的格式串，因为**%d只适用于int类型。**



读写无符号整数、短整数和长整数需要一些新的转换说明符。

- 读写无符号整数时

  使用字母u、o或x代替转换说明中的d。如果使用u说明符，该数将以十进制形式读写，o表示八进制形式，而x表示十六进制形式。

  ```c
  unsigned int u;
  
  scanf("%u",&u);
  printf("%u",u);
  scanf("%o",&u);
  printf("%o",u);
  scanf("%x",&u);
  printf("%x",u);
  ```

- 读写短整数时

  在d、o、u或x前面加上字母h：

  ```c
  short s;
  
  scanf("%hd",&s);
  printf("%hd",s);
  ```

- 读写长整数时

  在d、o、u或x前面加上字母l：

  ```c
  long l;
  
  scanf("%ld",&l);
  printf("%ld",l);
  ```

- 读写长长整数时(仅限C99)

  在d、o、u或x前面加上字母ll：

  ```c
  long long ll;
  
  scanf("%lld",&ll);
  printf("%lld",ll);
  ```





### 数列求和

6.1节使用while循环编写了一个程序对用户输入的整数数列求和。该程序的一个问题就是所求的和（或其中某个数）可能会超过int型变量允许的最大值。如果程序运行在整数长度为16位的机器上，可能会发生下面的情况：

```
This program sums a series of integers.
Enter integers (0 to terminate): 10000 20000 30000 0
The sums is: -5536
```

求和的结果应该为60000，但这个值不在int型变量表示的范围内，所以出现了溢出。当有符号整数发生溢出时，结果是未定义的，在本例中得到了一个毫无意义的结果。为了改进这个程序，可以把变量改换成long型。



```c
#include <stdio.h>

int main(void) {
    long n,sum = 0;

    printf("This program sums a series of integers.\n");
    printf("Enter integers (0 to terminate):\n");

    scanf("%ld",&n);
    while (n != 0) {
        sum += n;
        scanf("%ld",&n);
    }
    printf("The sums is:%ld\n",sum);
    return 0;
}

```

这种改变非常简单：将n和sum声明为long型变量而不是int型变量，然后把scanf和printf函数中的转换说明由%d改为%ld。



## 浮点类型

整数类型并不适用于所有应用。有时候需要变量能够存储带小数点的数，或者能存储极大数或极小数。这类数可以用浮点（因小数点是浮动的而得名）格式进行存储。C语言提供了3种浮点类型。

- float

  单精度浮点数

- double

  双精度浮点数

- long double

  扩展精度浮点数

**当精度要求不严格时（例如，计算带一位小数的温度），float是很合适的类型。double提供更高的精度，对绝大多数程序来说都够用了。long double支持极高精度的要求，很少用到。**



C标准没有说明float、double和long double类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数计算机都遵循IEEE 754标准（即IEC 60559）的规范，所以这里也用它作为一个示例。



| 类型   | 最小正值        | 最大值         | 精度     |
| ------ | --------------- | -------------- | -------- |
| float  | 1.17549*10^-38  | 3.40282*10^38  | 6个数字  |
| double | 2.22507*10^-308 | 1.79769*10^308 | 15个数字 |





### 浮点常量

浮点常量可以有许多种书写形式。例如，下面这些常量全都是表示数57.0的有效方式：5

```
57.0	57.	 57.0e0 	57e0	5.7e1	5.7e+1	.57e2	570.e-1
```

浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。



**默认情况下，浮点常量都以双精度数的形式存储。换句话说，当C语言编译器在程序中发现常量57.0时，它会安排数据以double类型变量的格式存储在内存中。**



在某些极个别的情况下，可能会需要强制编译器以float或long double格式存储浮点常量。为了表明只需要单精度，可以在常量的末尾处加上字母F或f（如57.0F）；而为了说明常量必须以long double格式存储，可以在常量的末尾处加上字母L或l（如57.0L）。



C99提供了十六进制浮点常量的书写规范。十六进制浮点常量以0x或0X开头。这一特性很少用到。



### 读/写浮点数

前面已讨论过，转换说明符%e、%f和%g用于读写单精度浮点数。读写double和long double类型的值所需的转换说明符略有不同。

- 读取double类型的值时，在e、f或g前放置字母l；

  ```c
  double d;
  
  scanf("%lf",&d);
  ```

  注意：只能在scanf函数格式串中使用l，不能在printf函数格式串中使用。在printf函数格式串中，转换e、f和g可以用来写float类型或double类型的值。（C99允许printf函数调用中使用%le、%lf和%lg，不过字母l不起作用。）

- 读写long double类型的值时，在e、f或g前放置字母L：

  ```c
  long double d;
  
  scanf("%Lf",&ld);
  printf("%Lf",ld);
  ```



## 字符类型

目前还没有讨论的唯一一个基本类型是char类型，即字符类型（也称字符型）。char类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。



char类型的变量可以用任意单字符赋值：

```c
char ch;

ch = 'a';
ch = 'A';
ch = '0';
ch = ' ';
```

注意，字符常量需要用单引号括起来，而不是双引号。



### 字符操作

在C语言中字符的操作非常简单，因为存在这样一个事实：C语言把字符当作小整数进行处理。毕竟所有字符都是以二进制的形式进行编码的，而且无需花费太多的想象就可以将这些二进制代码看成整数。例如，在ASCII码中，字符的取值范围是0000000~1111111，可以看成是0~127的整数。字符'a'的值为97，'A'的值为65，'0'的值为48，而' '的值为32。在C中，字符和整数之间的关联是非常强的，字符常量事实上是int类型而不是char类型。



当计算中出现字符时，C语言只是使用它对应的整数值。思考下面这个例子，假设采用ASCII字符集：

```c
char ch;
int i;

i = 'a';        // i is now 97
ch = 65;		// ch is now 'A'
ch = ch + 1;	// ch is now 'B'
ch++;			// ch is now 'C'
```

可以像比较数那样对字符进行比较。下面的if语句测试ch中是否含有小写字母，如果有，那么它会把ch转化为相应的大写字母。

```c
if('a' <= ch && ch <= 'z')
	ch = ch - 'a' +'A';
```

字符拥有和数相同的属性，这一事实会带来一些好处。例如，可以让for语句中的控制变量遍历所有的大写字母：

```c
for(ch = 'A';ch <= 'Z';ch++)...
```

另一方面，以数的方式处理字符可能会导致编译器无法检查出来的多种编程错误，还可能会导致编写出如'a' * 'b' / 'c'这类无意义的表达式。此外，这样做有可能会妨碍程序的可移植性，因为程序可能会基于一些对字符集的假设。



### 有符号字符和无符号字符

既然C语言允许把字符作为整数来使用，那么char类型应该像整数类型一样也存在有符号型和无符号型两种。通常有符号字符的取值范围是-128~127，而无符号字符的取值范围则是0~255。



C语言标准没有说明普通char类型数据是有符号型还是无符号型，有些编译器把它们当作有符号型来处理，有些编译器则将它们当作无符号型来处理。



大多数时候，人们并不真的关心char类型是有符号型还是无符号型。但是，偶尔确实需要注意，特别是当使用字符型变量存储一个小值整数的时候。基于上述原因，标准C允许使用单词signed和unsigned来修饰char类型：

```c
signed char sch;
unsigned char uch;
```

由于字符和整数之间有密切关系，C89采用术语**整值类型**来统称包含整数类型和字符类型。枚举类型也属于整值类型。



C99不使用术语“整值类型”，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99中的_Bool型是无符号整数类型。



### 算术类型

整数类型和浮点类型统称为算术类型。



下面对C89中的算术类型进行了总结分类：

- 整值类型：
  - 字符整型（char）
  - 有符号整型（signed char、short int、int、long int）
  - 无符号整型（unsigned char、unsigned short int、unsigned int、unsigned long int）
  - 枚举类型
- 浮点类型（float、double、long double）



C99的算术类型具有更复杂的层次：

- 整数类型：
  - 字符类型（char）
  - 有符号整型，包括标准的（signed char、short int、long int、long long int）和扩展的
  - 无符号整型，包括标准的（unsigned char、unsigned short int、unsigned int、unsigned long int、unsigned long long int、_Bool）和扩展的
  - 枚举类型
- 浮点类型：
  - 实数浮点类型（float、double、long double）
  - 复数类型（float_Complex、double_Complex、long double_Complex）。



### 字符处理函数

前面已经讲过如何使用if语句把小写字母转换成大写字母：

```c
if('a' <= ch && ch <= 'z')
	ch = ch - 'a' + 'A';
```

但是这不是最好的方法。一种更便捷且更易于移植的转换方法是调用C语言的toupper库函数：

```c
ch = toupper(ch);
```

toupper函数在被调用时检测参数（本例中为ch）是否是小写字母。如果是，它会把参数转换成相应的大写字母；否则，toupper函数会返回参数的值。



调用toupper函数的程序需要在顶部放置下面这条#include指令：

```c
#include <ctype.h>
```



### 用scanf和printf读/写字符

转换说明%c允许scanf函数和printf函数对单个字符进行读/写操作：

```c
char ch;
scanf("%c",&ch);
printf("%c",ch);
```

在读入字符前，scanf函数不会跳过空白字符。如果下一个未读字符是空格，那么在前面的例子中，scanf函数返回后变量ch将包含一个空格。为了强制scanf函数在读入字符前跳过空白字符，需要在格式串中的转换说明%c前面加上一个空格：

```c
scanf(" %c",&ch);
```

回顾3.2节的内容，scanf格式串中的空白意味着“跳过0个或多个空白字符”。**所以，在上面的代码例子中，需要在想输入的有效字符前先输入一个空格才能被读取。**



### 用getchar和putchar读/写字符

C语言还提供了另外一些读/写单个字符的方法。特别是，可以用getchar函数和putchar函数来取代scanf函数和printf函数。putchar函数用于写单个字符：

```c
putchar(ch);
```

每次调用getchar函数时，它会读入一个字符并将其返回。为了保存这个字符，必须使用赋值操作将其存储到变量中：

```c
ch = getchar();
```

事实上，getchar函数返回的是一个int类型的值而不是char类型的值。因此，如果一个变量用于存储getchar函数读取的字符，其类型设置为int而不是char也没啥好奇怪的。和scanf函数一样，getchar函数也不会在读取时跳过空白字符。



执行程序时，使用getchar函数和putchar函数（胜于scanf函数和printf函数）可以节约时间。getchar函数和putchar函数执行速度快有两个原因。第一个原因是，这两个函数比scanf函数和printf函数简单得多，因为scanf函数和printf函数是设计用来按不同的格式读/写多种不同数据类型的。第二个原因是，为了额外的速度提升，通常getchar函数和putchar函数是作为宏来实现的。



getchar函数还有一个优于scanf函数的地方：因为返回的是读入的字符，所以getchar函数可以应用在多种不同的C语言惯用法中，包括用在搜索字符或跳过所有出现的同一字符的循环中。思考下面这个scanf函数循环，前面曾用它来跳过输入行的剩余部分：

```c
do{
	scanf("%c",&ch);
}while(ch != '\n');
```

用getchar函数重写上述循环，得到下面的代码：

```c
do{
	ch = getchar();
}while(ch !='\n');
```

把getchar函数调用移到控制表达式中可以精简循环：

```c
while((ch =getchar()) != '\n')
	;
```

这个循环读入一个字符，把它存储在变量ch中，然后测试变量ch是否不是换行符。如果测试结果为真，那么执行循环体（循环体实际为空），接着再次测试循环条件，从而引发读入新的字符。实际上我们并不需要变量ch，可以把getchar函数的返回值与换行符进行比较：

```c
while(getchar() != '\n')
	;
```

这个循环是非常著名的C语言惯用法，虽然这种用法的含义是非常隐晦的，但是值得学习。



getchar函数对于搜索字符的循环和跳过字符的循环都很有用。思考下面这个利用getchar函数跳过不定数量的空格字符的语句：

```c
while((ch = getchar()) == '')
	;
```

当循环终止时，变量ch将包含getchar函数遇到的第一个非空白字符。



**注意：**

**如果在同一个程序中混合使用getchar和scanf函数，一定要注意。scanf函数倾向于遗留下它“扫视”过但未读取的字符（包括换行符）。思考一下，如果试图先读入数再读入字符的话，下面的程序段会发生什么：**

```c
printf("Enter an integer: ");
scanf("%d",&i);
printf("Enter a command: ");
command = getchar();
```

**在读入i的同时，scanf函数调用将会留下没有消耗掉的任意字符，包括（但不限于）换行符。getchar函数随后将取回第一个剩余字符，但这不是我们希望的结果。**



### 确定消息的长度

为了说明字符的读取方式，下面编写一个程序来计算消息的长度。在用户输入消息后，程序显示长度：

```
Enter a message: Brevity is the soul of wit.
Your message was 27 character(s) long.
```

消息的长度包括空格和标点符号，但是不包含消息结尾的换行符。



程序需要采用循环结构来实现读入字符和计数器自增操作，循环在遇到换行符时立刻终止。



既可以采用scanf函数也可以采用getchar函数读取字符，但大多数C程序员愿意采用getchar函数。采用简明的while循环书写的程序如下：

```c
#include <stdio.h>

int main(void){
    char ch;
    int len =0;

    printf("Enter a message: ");
    ch = getchar();
    while(ch != '\n'){
        len++;
        ch = getchar();
    }
    printf("Your message was %d character(s) long.\n",len);

    return 0;
}
```

回顾有关while循环和getchar函数惯用法的讨论，发现程序可以缩短为如下形式：

```c
#include <stdio.h>

int main(void){
    int len =0;

    printf("Enter a message: ");
    while(getchar() != '\n'){
        len++;
    }
    printf("Your message was %d character(s) long.\n",len);

    return 0;
}
```

## 类型转换

在执行算术运算时，计算机比C语言的限制更多。为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。**计算机可能可以直接将两个16位整数相加，但是不能直接将16位整数和32位整数相加，也不难直接将32位整数和32位浮点数相加。**



C语言则允许在表达式中混合使用基本类型。在单个表达式中可以组合整数、浮点数，甚至是字符。当然，在这种情况下C编译器可能需要生成一些指令将某些操作数转换成不同类型，使得硬件可以对表达式进行计算。例如，**如果对16位short型数和32位int型数进行加法操作，那么编译器将安排把16位short型值转换成32位值。如果是int型数据和float型数据进行加法操作，那么编译器将安排把int型值转换成float格式。这个转换过程稍微复杂一点，因为int型值和float型值的存储方式不同。**



因为编译器可以自动处理这些类型而无需程序员介入，所以这类转换称为隐式转换。C语言还允许程序员使用强制运算符执行显式转换。首先讨论隐式转换，然后再讨论显式转换。遗憾的是，执行隐式转换的规则有些复杂，主要是因为C语言有大量不同的算术类型。



当发生下列情况时会进行隐式转换。

- 当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换。）
- 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。
- 当函数调用中的实参类型与其对应的形参类型不匹配时。
- 当return语句中表达式的类型和函数返回值的类型不匹配时。



### 常用算术转换

常用算术转换可用于大多数二元运算符（包括算术运算符、关系运算符和判等运算符）的操作数。例如，假设变量f为float类型，而变量i为int类型。常用算术转换将会应用在表达式f + i的操作数上，因为两者的类型不同。显然把变量i转换成float类型（匹配变量f的类型）比把变量f转换成int类型（匹配变量i的类型）更安全。整数始终可以转换成float类型，可能会发生的最糟糕的事是精度会有少量损失。相反，把浮点数转换成int类型，将有小数部分的损失；更糟糕的是，如果原始数大于最大可能的整数或者小于最小的整数，那么将会得到一个完全没有意义的结果。



常用算术转换的策略是把操作数转换成可以安全地适用于两个数值的“最狭小的”数据类型。（粗略地说，如果某种类型要求的存储字节比另一种类型少，那么这种类型就比另一种类型更狭小。）为了统一操作数的类型，通常可以将相对狭小类型的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的提升是整值提升，它把字符或短整数转换成int类型（或者某些情况下是unsigned int类型）。











