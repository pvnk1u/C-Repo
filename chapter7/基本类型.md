# 基本类型

到目前为止，只使用了C语言的两种基本（内置的）类型：int和float。（还见过_Bool，那是C99中的一种基本类型。）本章讲述其余的基本类型，并从整体上讨论有关的重要问题。首先展示整数类型的取值范围，包括长整型、短整型和无符号整型。然后介绍double类型和long double类型，这些类型提供了更大的取值范围和比float类型更高的精度。然后将讨论char（字符）类型，这种类型将用于字符数据的处理。还将讨论解决重要的类型转换问题，即把一种类型的值转换成另外一种类型的等价值。随后展示利用typeof定义新类型名的方法。最后，描述sizeof运算符，这种运算符用来计算一种类型需要的存储空间大小。



## 整数类型

C语言支持两种根本不同的数值类型：整数类型（也称整型）和浮点类型（也称浮点型）。整型类型的值是整数，而浮点类型的值则可能还有小数部分。整数类型又分为两大类：有符号型和无符号型。



### 有符号整数和无符号整数

有符号整数如果为正数或零，那么最左边的位（符号位）为0；如果为负数，则符号位为1。因此，最大的16位整数的二进制表示形式是0111111111111111，对应的值是32767（即2^15 -1）。而最大的32位整数是01111111111111111111111111111111，对应的数值是2147483647（即2^31-1）。不带符号位的整数（最左边的位是数值的一部分）的整数称为无符号整数。最大的16位无符号整数是65535（即2^16-1），而最大的32位无符号整数是4294967295（即2^32-1）。



**默认情况下，C语言中的整型变量都是有符号的，也就是说最左位保留为符号位。若要告诉编译器变量没有符号位，需要把它声明成unsigned类型。无符号整数主要用于系统编程和底层与机器相关的应用。后面的章节将讨论无符号整数的常见应用，在此之前，通常回避无符号整数。**



C语言的整数类型有不同的尺寸。int类型通常为32位，但在老的CPU上可能是16位。有些程序所需的数很大，无法以int类型存储，所以C语言还提供了长整型。某些时候，为了节省空间，通常会指示编译器以比正常存储小的空间来存储一些数，这样的数称为短整型。



**为了使构造的整数类型正好满足需要，可以指明变量是long类型或short类型，signed类型或unsigned类型，甚至可以把说明符组合起来（如long unsigned in）。**然而，实际上只有下列6种组合可以产生不同的类型：

```c
short int
unsigned short int

int
unsigned int

long int
unsigned long int
```

 其他组合都是上述某种类型的同义词。（例如，除非额外说明，否则所有整数都是有符号的。因此long signed int和long int是一样的类型。）另外，说明符的顺序没什么影响，所以unsigned short int和short unsigned int是一样的。



C语言允许通过省略单词int来缩写整数类型的名字。例如，unsigned short int可以缩写为unsigned short，而long int则可以缩写为long。C程序员经常会省略int；Java等语言甚至不允许程序员使用short int或long int这样的名字，而必须写成short或long。



6种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则。首先，C标准要求short int、int和long int中的每一种类型都要覆盖一个确定的最小取值范围。其次，标准要求int类型不能比short int类型短，long int类型不能比int类型短。但是，short int类型的取值范围有可能和int类型的范围是一样的，int类型的取值范围也可以和long int的一样。



下图说明了在16位机上整数类型通常的取值范围，注意short int和int有相同的取值范围：

| 类型               | 最小值      | 最大值     |
| ------------------ | ----------- | ---------- |
| short int          | -32768      | 32767      |
| unsigned short int | 0           | 65535      |
| int                | -32768      | 32767      |
| unsigned int       | 0           | 65535      |
| long int           | -2147483648 | 2147483647 |
| unsigned long int  | 0           | 4294967295 |



下表说明了32位机上整数类型通常的取值范围，这里的int和long int有着相同的取值范围：

| 类型               | 最小值      | 最大值     |
| ------------------ | ----------- | ---------- |
| short int          | -32768      | 32767      |
| unsigned short int | 0           | 65535      |
| int                | -2147483648 | 2147483647 |
| unsigned int       | 0           | 4294967295 |
| long int           | -2147483648 | 2147483647 |
| unsigned long int  | 0           | 4294967295 |



下表给出了64位机上（尤其是UNIX系统下）整数类型常见的取值范围：

| 类型               | 最小值               | 最大值               |
| ------------------ | -------------------- | -------------------- |
| short int          | -32768               | 32767                |
| unsigned short int | 0                    | 65535                |
| int                | -2147483648          | 2147483647           |
| unsigned int       | 0                    | 4294967295           |
| long int           | -9223372036854775808 | 9223372036854775807  |
| unsigned int       | 0                    | 18446744073709551615 |



再强调一下，上面三个表中给出的取值范围不是C标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查<limits.h>头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。



### C99中的整数类型

C99提供了两个额外的标准整数类型：long long int和unsigned long long int。增加这两种整数类型有两个原因，一是为了满足日益增长的对超大型整数的需求，二是为了适应支持64位运算的新处理器的能力。这两个long long类型要求至少64位宽，所以long long int类型值的范围通常为-2^63(-9223372036854775808)到2^63-1(9223372036854775807)，而unsigned long long int类型值的范围通常为0到2^64-1（18446744073709551615）。



C99中把short int、int、long int和long long int类型（以及signed char类型）称为标准有符号整型，而把unsigned short int、unsigned int、unsigned long int和unsigned long long int类型（以及unsigned char类型）和_Bool类型称为标准无符号整型。



除了标准的整数类型以外，C99标准还允许在具体实现时定义扩展的数类整型（包括有符号的和无符号的）。例如，编译器可以提供有符号和无符号的128位整数类型。



### 整数常量

现在把注意力转向常量——在程序中以文本形式出现的数，而不是读、写或计算出来的数。C语言允许用十进制（基数为10）、八进制（基数为8）和十六进制（基数为16）形式书写整数常量。



**八进制数和十六进制数**

八进制是用数字0~7书写的。八进制数的每一位表示一个8的幂（这就如同十进制数的每一位表示10的幂一样）。因此，八进制的数237表示成十进制数就是`2*8^2+3*8^1+7*8^0=128+24+7=159`。



十六进制是用数字0~9加上字母A~F书写的。其中字母A~F表示10~15的数。十六进制数的每一位表示一个16的幂，十六进制数1AF的十进制数值是`1*16v^2+10*16^1+15*16^0=256+160+15=431`。



- 十进制常量包含0~9中的数字，但是一定不能以零开头：

  15	255	32767

- 八进制常量只包含0~7中的数字，而且必须要以零开头：

  017	0377 	077777

- 十六进制常量包含0~9中的数字和a~f中的字母，而且总是以0x开头：

  0xf	0xff	0x7fff



十六进制常量中的字母既可以是大写字母也可以是小写字母。



**需要切记的是八进制和十六进制只是书写数的方式，它们不会对数的实际存储方式产生影响。（整数都是以二进制形式存储的，跟表示方式无关。）任何时候都可以从一种书写形式切换到另一种书写形式，甚至可以混合使用：10+015 + 0x20的值为55（十进制）。八进制和十六进制更适合底层程序的编写。**直到第20章才会较多地用到它们。



**十进制整数常量的类型通常为int，但如果常量的值大得无法存储在int型中，就用long int类型。如果出现long int不够用得罕见情况，编译器会用unsigned long int作最后的尝试。确定八进制和十六进制常量得规则略有不同：编译器会依次尝试int、unsigned int、long int和unsigned long int类型，直至找到能表示该常量的类型。**



为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母L（或l）：

```
15L 0377L 0x7fffl
```

为了指明是无符号常量，可以在常量后边加上字母U（或u）：

```
15U 0377U 0x7fffu
```

L和U可以结合使用，以表明常量既是长整型又是无符号的：0xffffffffUL。（字母L、U的顺序和大小写无所谓。）



### C99中的整数常量

在C99中，以LL或ll（两个字母大小写要一致）结尾的整数常量是long long int型的。如果在LL或ll的前面或后面增加字母U（或u），则代表该整数常量为unsigned long long int型。



C99确定整数常量类型的规则与C89有些不同。对于没有后缀（U、u、L、l、LL、ll）的十进制常量，其类型是int、long int或long long int中能表示该值的最小类型。对于八进制或者十六进制常量，可能的类型顺序为int、unsigned int、long int、unsigned long int、long long int和unsigned long long int。常量后面的任何后缀都会改变可能类型的列表。例如，以U（或u）结尾的常量类型一定是unsigned int、unsigned long int和unsigned long long int中的一种，以L（或l）结尾的十进制常量类型一定是long int或long long int中的一种。如果常量的数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。



### 整数溢出

对整数执行算术运算时，其结果有可能因为过大而无法表示。例如，对两个int值进行算术运算时，结果必须仍然能用int类型来表示；否则就会发生溢出。



整数溢出时的行为要根据操作数是有符号型还是无符号型来确定。有符号整数运算中发生溢出时，程序的行为是未定义的。未定义行为的结果是不确定的。最可能的情况是，仅仅是运算的结果出错了，但程序也有可能崩溃，或出现其他意想不到的状况。



### 读/写整数

假设有一个程序因为其中一个int变量发生了"溢出"而无法工作。我们的第一反应是把变量的类型从int变为long int。但仅仅这样做是不够的，还必须检查数据类型的改变对程序其他部分的影响，尤其是需要检查该变量是否用在printf函数或scanf函数的调用中。如果用了，需要改变调用中的格式串，因为**%d只适用于int类型。**



读写无符号整数、短整数和长整数需要一些新的转换说明符。

- 读写无符号整数时

  使用字母u、o或x代替转换说明中的d。如果使用u说明符，该数将以十进制形式读写，o表示八进制形式，而x表示十六进制形式。

  ```c
  unsigned int u;
  
  scanf("%u",&u);
  printf("%u",u);
  scanf("%o",&u);
  printf("%o",u);
  scanf("%x",&u);
  printf("%x",u);
  ```

- 读写短整数时

  在d、o、u或x前面加上字母h：

  ```c
  short s;
  
  scanf("%hd",&s);
  printf("%hd",s);
  ```

- 读写长整数时

  在d、o、u或x前面加上字母l：

  ```c
  long l;
  
  scanf("%ld",&l);
  printf("%ld",l);
  ```

- 读写长长整数时(仅限C99)

  在d、o、u或x前面加上字母ll：

  ```c
  long long ll;
  
  scanf("%lld",&ll);
  printf("%lld",ll);
  ```





### 数列求和

6.1节使用while循环编写了一个程序对用户输入的整数数列求和。该程序的一个问题就是所求的和（或其中某个数）可能会超过int型变量允许的最大值。如果程序运行在整数长度为16位的机器上，可能会发生下面的情况：

```
This program sums a series of integers.
Enter integers (0 to terminate): 10000 20000 30000 0
The sums is: -5536
```

求和的结果应该为60000，但这个值不在int型变量表示的范围内，所以出现了溢出。当有符号整数发生溢出时，结果是未定义的，在本例中得到了一个毫无意义的结果。为了改进这个程序，可以把变量改换成long型。



```c
#include <stdio.h>

int main(void) {
    long n,sum = 0;

    printf("This program sums a series of integers.\n");
    printf("Enter integers (0 to terminate):\n");

    scanf("%ld",&n);
    while (n != 0) {
        sum += n;
        scanf("%ld",&n);
    }
    printf("The sums is:%ld\n",sum);
    return 0;
}

```

这种改变非常简单：将n和sum声明为long型变量而不是int型变量，然后把scanf和printf函数中的转换说明由%d改为%ld。



## 浮点类型

整数类型并不适用于所有应用。有时候需要变量能够存储带小数点的数，或者能存储极大数或极小数。这类数可以用浮点（因小数点是浮动的而得名）格式进行存储。C语言提供了3种浮点类型。

- float

  单精度浮点数

- double

  双精度浮点数

- long double

  扩展精度浮点数

**当精度要求不严格时（例如，计算带一位小数的温度），float是很合适的类型。double提供更高的精度，对绝大多数程序来说都够用了。long double支持极高精度的要求，很少用到。**



C标准没有说明float、double和long double类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数计算机都遵循IEEE 754标准（即IEC 60559）的规范，所以这里也用它作为一个示例。



| 类型   | 最小正值        | 最大值         | 精度     |
| ------ | --------------- | -------------- | -------- |
| float  | 1.17549*10^-38  | 3.40282*10^38  | 6个数字  |
| double | 2.22507*10^-308 | 1.79769*10^308 | 15个数字 |





### 浮点常量

浮点常量可以有许多种书写形式。例如，下面这些常量全都是表示数57.0的有效方式：5

```
57.0	57.	 57.0e0 	57e0	5.7e1	5.7e+1	.57e2	570.e-1
```

浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。



**默认情况下，浮点常量都以双精度数的形式存储。换句话说，当C语言编译器在程序中发现常量57.0时，它会安排数据以double类型变量的格式存储在内存中。**



在某些极个别的情况下，可能会需要强制编译器以float或long double格式存储浮点常量。为了表明只需要单精度，可以在常量的末尾处加上字母F或f（如57.0F）；而为了说明常量必须以long double格式存储，可以在常量的末尾处加上字母L或l（如57.0L）。



C99提供了十六进制浮点常量的书写规范。十六进制浮点常量以0x或0X开头。这一特性很少用到。



### 读/写浮点数

前面已讨论过，转换说明符%e、%f和%g用于读写单精度浮点数。读写double和long double类型的值所需的转换说明符略有不同。

- 读取double类型的值时，在e、f或g前放置字母l；

  ```c
  double d;
  
  scanf("%lf",&d);
  ```

  注意：只能在scanf函数格式串中使用l，不能在printf函数格式串中使用。在printf函数格式串中，转换e、f和g可以用来写float类型或double类型的值。（C99允许printf函数调用中使用%le、%lf和%lg，不过字母l不起作用。）

- 读写long double类型的值时，在e、f或g前放置字母L：

  ```c
  long double d;
  
  scanf("%Lf",&ld);
  printf("%Lf",ld);
  ```



## 字符类型

目前还没有讨论的唯一一个基本类型是char类型，即字符类型（也称字符型）。char类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。



char类型的变量可以用任意单字符赋值：

```c
char ch;

ch = 'a';
ch = 'A';
ch = '0';
ch = ' ';
```

注意，字符常量需要用单引号括起来，而不是双引号。



### 字符操作

在C语言中字符的操作非常简单，因为存在这样一个事实：C语言把字符当作小整数进行处理。毕竟所有字符都是以二进制的形式进行编码的，而且无需花费太多的想象就可以将这些二进制代码看成整数。例如，在ASCII码中，字符的取值范围是0000000~1111111，可以看成是0~127的整数。字符'a'的值为97，'A'的值为65，'0'的值为48，而' '的值为32。在C中，字符和整数之间的关联是非常强的，字符常量事实上是int类型而不是char类型。



当计算中出现字符时，C语言只是使用它对应的整数值。思考下面这个例子，假设采用ASCII字符集：

```c
char ch;
int i;

i = 'a';        // i is now 97
ch = 65;		// ch is now 'A'
ch = ch + 1;	// ch is now 'B'
ch++;			// ch is now 'C'
```

可以像比较数那样对字符进行比较。下面的if语句测试ch中是否含有小写字母，如果有，那么它会把ch转化为相应的大写字母。

```c
if('a' <= ch && ch <= 'z')
	ch = ch - 'a' +'A';
```

字符拥有和数相同的属性，这一事实会带来一些好处。例如，可以让for语句中的控制变量遍历所有的大写字母：

```c
for(ch = 'A';ch <= 'Z';ch++)...
```

另一方面，以数的方式处理字符可能会导致编译器无法检查出来的多种编程错误，还可能会导致编写出如'a' * 'b' / 'c'这类无意义的表达式。此外，这样做有可能会妨碍程序的可移植性，因为程序可能会基于一些对字符集的假设。



### 有符号字符和无符号字符

既然C语言允许把字符作为整数来使用，那么char类型应该像整数类型一样也存在有符号型和无符号型两种。通常有符号字符的取值范围是-128~127，而无符号字符的取值范围则是0~255。



C语言标准没有说明普通char类型数据是有符号型还是无符号型，有些编译器把它们当作有符号型来处理，有些编译器则将它们当作无符号型来处理。



大多数时候，人们并不真的关心char类型是有符号型还是无符号型。但是，偶尔确实需要注意，特别是当使用字符型变量存储一个小值整数的时候。基于上述原因，标准C允许使用单词signed和unsigned来修饰char类型：

```c
signed char sch;
unsigned char uch;
```

由于字符和整数之间有密切关系，C89采用术语**整值类型**来统称包含整数类型和字符类型。枚举类型也属于整值类型。



C99不使用术语“整值类型”，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99中的_Bool型是无符号整数类型。



### 算术类型

整数类型和浮点类型统称为算术类型。



下面对C89中的算术类型进行了总结分类：

- 整值类型：
  - 字符整型（char）
  - 有符号整型（signed char、short int、int、long int）
  - 无符号整型（unsigned char、unsigned short int、unsigned int、unsigned long int）
  - 枚举类型
- 浮点类型（float、double、long double）



C99的算术类型具有更复杂的层次：

- 整数类型：
  - 字符类型（char）
  - 有符号整型，包括标准的（signed char、short int、long int、long long int）和扩展的
  - 无符号整型，包括标准的（unsigned char、unsigned short int、unsigned int、unsigned long int、unsigned long long int、_Bool）和扩展的
  - 枚举类型
- 浮点类型：
  - 实数浮点类型（float、double、long double）
  - 复数类型（float_Complex、double_Complex、long double_Complex）。



### 字符处理函数

前面已经讲过如何使用if语句把小写字母转换成大写字母：

```c
if('a' <= ch && ch <= 'z')
	ch = ch - 'a' + 'A';
```

但是这不是最好的方法。一种更便捷且更易于移植的转换方法是调用C语言的toupper库函数：

```c
ch = toupper(ch);
```

toupper函数在被调用时检测参数（本例中为ch）是否是小写字母。如果是，它会把参数转换成相应的大写字母；否则，toupper函数会返回参数的值。



调用toupper函数的程序需要在顶部放置下面这条#include指令：

```c
#include <ctype.h>
```



### 用scanf和printf读/写字符

转换说明%c允许scanf函数和printf函数对单个字符进行读/写操作：

```c
char ch;
scanf("%c",&ch);
printf("%c",ch);
```

在读入字符前，scanf函数不会跳过空白字符。如果下一个未读字符是空格，那么在前面的例子中，scanf函数返回后变量ch将包含一个空格。为了强制scanf函数在读入字符前跳过空白字符，需要在格式串中的转换说明%c前面加上一个空格：

```c
scanf(" %c",&ch);
```

回顾3.2节的内容，scanf格式串中的空白意味着“跳过0个或多个空白字符”。**所以，在上面的代码例子中，需要在想输入的有效字符前先输入一个空格才能被读取。**



### 用getchar和putchar读/写字符

C语言还提供了另外一些读/写单个字符的方法。特别是，可以用getchar函数和putchar函数来取代scanf函数和printf函数。putchar函数用于写单个字符：

```c
putchar(ch);
```

每次调用getchar函数时，它会读入一个字符并将其返回。为了保存这个字符，必须使用赋值操作将其存储到变量中：

```c
ch = getchar();
```

事实上，getchar函数返回的是一个int类型的值而不是char类型的值。因此，如果一个变量用于存储getchar函数读取的字符，其类型设置为int而不是char也没啥好奇怪的。和scanf函数一样，getchar函数也不会在读取时跳过空白字符。



执行程序时，使用getchar函数和putchar函数（胜于scanf函数和printf函数）可以节约时间。getchar函数和putchar函数执行速度快有两个原因。第一个原因是，这两个函数比scanf函数和printf函数简单得多，因为scanf函数和printf函数是设计用来按不同的格式读/写多种不同数据类型的。第二个原因是，为了额外的速度提升，通常getchar函数和putchar函数是作为宏来实现的。



getchar函数还有一个优于scanf函数的地方：因为返回的是读入的字符，所以getchar函数可以应用在多种不同的C语言惯用法中，包括用在搜索字符或跳过所有出现的同一字符的循环中。思考下面这个scanf函数循环，前面曾用它来跳过输入行的剩余部分：

```c
do{
	scanf("%c",&ch);
}while(ch != '\n');
```

用getchar函数重写上述循环，得到下面的代码：

```c
do{
	ch = getchar();
}while(ch !='\n');
```

把getchar函数调用移到控制表达式中可以精简循环：

```c
while((ch =getchar()) != '\n')
	;
```

这个循环读入一个字符，把它存储在变量ch中，然后测试变量ch是否不是换行符。如果测试结果为真，那么执行循环体（循环体实际为空），接着再次测试循环条件，从而引发读入新的字符。实际上我们并不需要变量ch，可以把getchar函数的返回值与换行符进行比较：

```c
while(getchar() != '\n')
	;
```

这个循环是非常著名的C语言惯用法，虽然这种用法的含义是非常隐晦的，但是值得学习。



getchar函数对于搜索字符的循环和跳过字符的循环都很有用。思考下面这个利用getchar函数跳过不定数量的空格字符的语句：

```c
while((ch = getchar()) == '')
	;
```

当循环终止时，变量ch将包含getchar函数遇到的第一个非空白字符。



**注意：**

**如果在同一个程序中混合使用getchar和scanf函数，一定要注意。scanf函数倾向于遗留下它“扫视”过但未读取的字符（包括换行符）。思考一下，如果试图先读入数再读入字符的话，下面的程序段会发生什么：**

```c
printf("Enter an integer: ");
scanf("%d",&i);
printf("Enter a command: ");
command = getchar();
```

**在读入i的同时，scanf函数调用将会留下没有消耗掉的任意字符，包括（但不限于）换行符。getchar函数随后将取回第一个剩余字符，但这不是我们希望的结果。具体例子如下：**



### scanf和getchar混合使用的隐患

修改6.3节的程序square2.c，每24次平方后暂停并显示下列信息：
Press Enter to continue...

显示完上述消息后，程序应该使用getchar函数读入一个字符。getchar函数读到用户录入的回车键才允许程序继续。



完整代码如下所示：

```c
#include <stdio.h>

int main(void) {
 int i,n;
 printf("This program prints a table of squares.\n");
 printf("Enter number of entries in table: ");
 scanf("%d",&n);

 /**
  * 先调用 getchar() 函数以清除输入缓冲区中残留的换行符。这是因为在 scanf() 读取整数后，换行符仍留在缓冲区中。
  * 如果不先执行一次getchar()函数，在下面第循环执行到i=24的时候，getchar()获取到的是输入n时录入的回车键
  */
 getchar();


 for (i = 1;i<=n;i++) {
   printf("%10d%10d\n",i,i*i);
   if (i %24 == 0) {
    printf("Press Enter to continue");
    while (getchar() != '\n'){}
      ;
   }
 }

 return 0;
}
```

可以看到，在输入n后，scanf只读取了n的值，缓冲区中依然有录入n时输入的换行符，需要在scanf之后先执行一次getchar()将之前录入的换行符清除掉，才能使下面的循环不会在i==24的时候不等待用户输入换行符就直接继续执行（因为i==24时第一次执行getchar()，如果不清除，则获取到的会是之前录入n时键入的换行符）。



### 确定消息的长度

为了说明字符的读取方式，下面编写一个程序来计算消息的长度。在用户输入消息后，程序显示长度：

```
Enter a message: Brevity is the soul of wit.
Your message was 27 character(s) long.
```

消息的长度包括空格和标点符号，但是不包含消息结尾的换行符。



程序需要采用循环结构来实现读入字符和计数器自增操作，循环在遇到换行符时立刻终止。



既可以采用scanf函数也可以采用getchar函数读取字符，但大多数C程序员愿意采用getchar函数。采用简明的while循环书写的程序如下：

```c
#include <stdio.h>

int main(void){
    char ch;
    int len =0;

    printf("Enter a message: ");
    ch = getchar();
    while(ch != '\n'){
        len++;
        ch = getchar();
    }
    printf("Your message was %d character(s) long.\n",len);

    return 0;
}
```

回顾有关while循环和getchar函数惯用法的讨论，发现程序可以缩短为如下形式：

```c
#include <stdio.h>

int main(void){
    int len =0;

    printf("Enter a message: ");
    while(getchar() != '\n'){
        len++;
    }
    printf("Your message was %d character(s) long.\n",len);

    return 0;
}
```

## 类型转换

在执行算术运算时，计算机比C语言的限制更多。为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。**计算机可能可以直接将两个16位整数相加，但是不能直接将16位整数和32位整数相加，也不难直接将32位整数和32位浮点数相加。**



C语言则允许在表达式中混合使用基本类型。在单个表达式中可以组合整数、浮点数，甚至是字符。当然，在这种情况下C编译器可能需要生成一些指令将某些操作数转换成不同类型，使得硬件可以对表达式进行计算。例如，**如果对16位short型数和32位int型数进行加法操作，那么编译器将安排把16位short型值转换成32位值。如果是int型数据和float型数据进行加法操作，那么编译器将安排把int型值转换成float格式。这个转换过程稍微复杂一点，因为int型值和float型值的存储方式不同。**



因为编译器可以自动处理这些类型而无需程序员介入，所以这类转换称为隐式转换。C语言还允许程序员使用强制运算符执行显式转换。首先讨论隐式转换，然后再讨论显式转换。遗憾的是，执行隐式转换的规则有些复杂，主要是因为C语言有大量不同的算术类型。



当发生下列情况时会进行隐式转换。

- 当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换。）
- 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。
- 当函数调用中的实参类型与其对应的形参类型不匹配时。
- 当return语句中表达式的类型和函数返回值的类型不匹配时。



### 常用算术转换

常用算术转换可用于大多数二元运算符（包括算术运算符、关系运算符和判等运算符）的操作数。例如，假设变量f为float类型，而变量i为int类型。常用算术转换将会应用在表达式f + i的操作数上，因为两者的类型不同。显然把变量i转换成float类型（匹配变量f的类型）比把变量f转换成int类型（匹配变量i的类型）更安全。整数始终可以转换成float类型，可能会发生的最糟糕的事是精度会有少量损失。相反，把浮点数转换成int类型，将有小数部分的损失；更糟糕的是，如果原始数大于最大可能的整数或者小于最小的整数，那么将会得到一个完全没有意义的结果。



常用算术转换的策略是把操作数转换成可以安全地适用于两个数值的“最狭小的”数据类型。（粗略地说，如果某种类型要求的存储字节比另一种类型少，那么这种类型就比另一种类型更狭小。）为了统一操作数的类型，通常可以将相对狭小类型的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的提升是整值提升，它把字符或短整数转换成int类型（或者某些情况下是unsigned int类型）。





执行常用算术转换的规则可以划分为两种情况。

- 任一操作数的类型是浮点类型的情况。

  按照`float->double->long double`的方式将类型较狭小的操作数进行提升。

  

  也就是说，如果一个操作数的类型为long double，那么把另一个操作数的类型转换成long double类型。否则，如果一个操作数的类型为double类型，那么把另一个操作数转换成double类型。否则，如果一个操作数的类型是float类型，那么把另外一个数转换成float类型。注意，这些规则涵盖了混合整数和浮点类型的情况。例如，如果一个操作数的类型是long int类型，并且另一个操作数的类型是double类型，那么把long int类型的操作数转换成double类型。

- 两个操作数的类型都不是浮点类型的情况

  首先对两个操作数进行整值提升（保证没有一个操作数是字符类型或短整型）。然后按照`int->unsigned int->long int->unsigned long int`的顺序对类型较狭小的操作数进行提升。

  

  有一种特殊情况，只有在long int类型和unsigned int类型长度（比如32位）相同时才会发生。在这类情况下，如果一个操作数的类型是long int，而另一个的类型是unsigned int，那么两个操作数都会转换成unsigned long int类型。



### 注意：谨慎使用无符号整数

当把有符号操作数和无符号操作数结合时，把有符号操作数“转换成”无符号的值。转换过程中需要加上或者减去n+1的倍数，其中n是无符号类型能表示的最大值。这条规则可能会导致某些隐蔽的编程错误。



假设int类型的变量i的值为-10，而unsigned int类型的变量u的值为10。如果用<运算符比较变量i和u，那么期望的结果应该是1（真）。但是，在比较前，变量i转换成unsigned int类型。因为负数不能被表示成无符号整数，所以转换后的值将不再为-10，而是加上4294967296的结果（假定4294967295是最大的无符号整数），即4294967286。因而i<u比较的结果将为0。有些编译器会在比较有符号数和无符号数时给出一条警告信息。



由于此类陷阱的存在，所以最好避免使用无符号整数，特别是不要把它和有符号整数混合使用。



### 赋值过程中的转换

常用算术转换不适用于赋值运算。C语言会遵循另一条简单的转换规则，那就是把赋值运算右边的表达式转换成左边变量的类型。如果变量的类型至少和表达式类型一样“宽”，那么这种转换将没有任何障碍。例如：

```c
char c;
int i;
float f;
double d;

i = c;
f = i;
d = f;
```

其他情况下是有问题的。把浮点数赋值给整型变量会丢掉该数的小数部分：

```c
int i;

i = 842.97;   	// i is now 842
i = -842.97;	// i is now -842
```

此外，把某种类型的值赋给类型更狭小的变量时，如果该值在变量类型范围之外，那么将会得到无意义的结果（甚至更糟）。

```c
c = 10000;		// wrong
i = 1.0e20;		// wrong
f = 1.0e100;	// wrong
```

这类赋值可能会导致编译器或lint之类的工具发出警告。



如果浮点变量被赋值给float型变量时，一个很好的方法是在浮点常量尾部加上后缀f：

```c
f = 3.14159f;
```

**如果没有后缀，常量3.14159将是double类型，可能会引起警告信息。**



### C99中的隐式转换

C99中的隐式转换和C89中的隐式转换略有不同，这主要是因为C99增加了一些类型(_Bool、long long类型、扩展的整数类型和复数类型)。



为了定义转换规则，C99允许每个整数类型具有“整数转换等级”。下面按从最高级到最低级的顺序排列。

1. long long int、unsigned long long int
2. long int、unsigned long int
3. int、unsigned int
4. short int、unsigned short int
5. char、signed char、unsigned char
6. _Bool

简单起见，这里忽略了扩展的整数类型和枚举类型。



**C99用整数提升取代了C89中的整值提升，可以将任何等级低于int和unsigned int的类型转换为int（只要该类型的所有值都可以用int型表示）或unsigned int。**



**与C89一样，C99中执行常用算术运算转换的规则可以划分为两种情况。**

- **任一操作数的类型是浮点类型的情况。**

  **只要两个操作数都不是复数型，规则与前面一样。**

- **两个操作数的类型都不是浮点类型的情况**

  **首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦遇到可应用的规则就不再考虑别的规则：**

  - **如果两个操作数都是有符号型或者都是无符号型，将整数转换等级较低的操作数转换为等级较高的操作数的类型。**
  - **如果无符号操作数的等级高于或等于有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。**
  - **如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。**
  - **否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。**

**另外，所有算术类型都可以转换为_Bool类型。如果原始值为0则转换结果为0，否则结果为1。**



### 强制类型转换

虽然C语言的隐式转换使用起来非常方便，但是有些时候还需要从更大程度上控制类型转换。基于这种原因，C语言提供了强制类型转换。强制类型转换表达式的格式如下：

```
[强制转换表达式]	(类型名)表达式
```

这里的类型名表示的是表达式应该转换成的类型。



下面的例子显示了使用强制类型转换表达式计算float类型值小数部分的方法：

```c
float f,frac_part;

frac_part = f - (int)f;
```

强制类型转换表达式(int) f表示把f的值转换成int类型后的结果。C语言的常用算术转换则要求在进行减法运算前把(int)f转换回float类型。f和(int) f的不同之处就在于f的小数部分，这部分在强制类型转换时被丢掉了。



强制类型转换表达式可以用于显示那些肯定会发生的类型转换：

```c
i = (int) f;  // f is converted to int
```

**它也可也用来控制编译器并且强制它进行我们需要的转换。**思考下面的例子：

```c
float quotient;
int dividend,divisor;

quotient = dividend / divisor;
```

**正如现在写的那样，除法的结果是一个整数，在把结果存储在quotient变量中之前，要把结果转换成float格式。但是，为了得到更精确的结果，可能需要在除法执行之前把dividend和divisor的类型转换成float格式的。强制类型转换表达式可以完成这一点：**

```c
quotient = (float) dividend / divisor;
```

**变量divisor不需要进行强制类型转换，因为把变量dividend强制转换成float类型会迫使编译器把divisor也转换成float类型。**



C语言把（类型名）视为一元运算符。一元运算符的优先级高于二元运算符，所以编译器会把表达式

```c
(float) dividend / divisor
```

解释为

```c
((float) dividend) / divisor
```

**有些时候，需要使用强制类型转换来避免溢出。**思考下面这个例子：

```c
long i;
int j = 1000;

i = j * j;  // overflow may occur
```

乍看之下，这条语句没有问题。表达式`j*j`的值是1000000，并且变量i是long int类型的，所以i应该能很容易地存储这种大小的值，不是吗？**问题是，当两个int类型值相乘时，结果也应该是int类型的，但是`j*j`的结果太大，以致在某些机器上无法表示成int型，从而导致溢出。**幸运的是，可以使用强制类型转换避免这种问题的发生：

```c
i = (long) j * j;
```

因为强制运算符的优先级高于*，所以第一个变量j会被转换成long int类型，同时也迫使第二个j进行转换。注意，语句

```c
i = (long) (j * j);  // wrong
```

是不对的，因为溢出在强制类型转换之前就已经发生了。



## 类型定义

5.2节中，我们使用`#define`指令创建了一个宏，可以用来定义布尔型数据：

```c
#define BOOL int
```

但是，一个更好的设置布尔类型的方法是利用所谓的类型定义的特性：

```c
typedef int Bool;
```

注意，所定义的类型的名字放在最后。还要注意，我们使用首字母大写的单词BOOL。将类型名的首字母大写不是必须的，只是一些C语言程序员的习惯。



**采用typedef定义BOOL会导致编译器在它所识别的类型名列表中加入BOOL。现在，BOOL类型可以和内置的类型名一样用于变量声明、强制类型转换表达式和其他地方了。（#define BOOL int这样的宏则不行）**例如，可以使用Bool声明变量：

```c
Bool flag;
```

**编译器会把Bool类型看成是int类型的同义词；因此，变量flag实际就是一个普通的int类型变量。**



### 类型定义的优点

类型定义使程序更加易于理解。例如，假设变量cash_in和cash_out将用于存储美元数量。把Dollars声明为：

```c
typedef float Dollars;
```

并且随后写出：

```c
Dollars cash_in,cash_out;
```

这样的写法比下面的写法更有实际意义：

```c
float cash_in,cash_out;
```

类型定义还可以使程序更容易修改。如果稍后决定Dollars实际应该定义为double类型的，那么只需要改变类型定义就足够了：

```c
typedef double Dollars;
```

Dollars变量的声明不需要进行改变。如果不使用类型定义，则需要找到所有用于存储美元数量的float类型变量（显然不是容易的）并且改变它们的声明。



### 类型定义和可移植性

**类型定义是编写可移植性程序的一种重要工具。程序从一台计算机移动到另一台计算机可能引发的问题之一就是不同计算机上的类型取值范围可能不同。如果i是int类型的变量，那么赋值语句：**

```c
i = 100000;
```

在使用32位整数的机器上是没问题的，但是在使用16位整数的机器上就会出错。



**可移植性技巧：**

**为了更大的可移植性，可以考虑使用typedef定义新的整数类型名。**



**假设编写的程序需要用变量来存储产品数量，取值范围在0~50000。为此可以使用long int类型的变量（因为这样保证可以存储至少在2147483647以内的数），但是用户更愿意使用int类型的变量，因为算术运算时int类型值比long int类型值运算速度快；同时，int类型变量占用的空间较少。**



我们可以定义自己的“数量”类型，而避免使用int类型声明数量变量：

```c
typedef int Quantity;
```

并且使用这种类型来声明变量：

```c
Quantity q;
```

**当把程序转到使用较短整数的机器上时，需要改变Quantity的定义：**

```c
typedef long Quantity;
```

**可惜的是，这种技术无法解决所有的问题，因为Quantity定义的变化可能会影响Quantity类型变量的使用方式。我们至少需要改动使用了Quantity类型变量的printf函数调用和scanf函数调用，用转换说明`%ld`替换`%d`。**



C语言库自身使用typedef为那些可能依据C语言实现的不同而不同的类型创建类型名；这些类型的名字经常以_t结尾，比如ptrdiff_t、size_t和wchar_t。这些类型的精确定义不尽相同，下面是一些常见的例子；

```c
typedef long int ptrdiff_t;
typedef unsigned long int size_t;
typedef int wchar_t;
```

**在C99中，`<stdint.h>`头使用typedef定义占用特定位数的整数类型名。例如，int32_t是恰好占用32位的有符号整型。这是一种有效的定义方式，能使程序更易于移植。**



## sizeof运算符

sizeof运算符允许程序存储指定类型值所需空间的大小。表达式

```c
[sizeof表达式] sizeof(类型名)
```

**的值是一个无符号整数，代表存储属于类型名的值所需要的字节数。表达式sizeof(char)的值始终为1，但是对其他类型计算出的值可能会有所不同。在32位的机器上，表达式sizeof(int)的值通常为4。注意，sizeof运算符是一种特殊的运算符，因为编译器本身就可以确定sizeof表达式的值。**



通常情况下，sizeof运算符也可以应用于常量、变量和表达式。如果i和j是整型变量，那么sizeof(i)在32位机器上的值为4，这和表达式sizeof(i+j)的值一样。



**显示sizeof值时要注意，因为sizeof表达式的类型是size_t，这是一种由实现定义的类型。在C89中，最好在显示前把表达式的值转换成一种已知的类型。size_t一定是无符号整型，所以最安全的方法是把sizeof表达式强制转换成unsigned long类型（C89中最大的无符号类型），然后使用转换说明符%lu显示：**

```c
printf("Size of int: %lu\n",(unsigned long) sizeof(int));
```



**在C99中，size_t类型可以比unsigned long更长。但C99中的printf可以直接显示出size_t类型值而不需要强制转换。方法是在转换说明中的一般整数（通常用u）代码前使用字母z:**

```c
printf("Size of int: %zu\n",sizeof(int));
```



