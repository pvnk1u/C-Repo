# 指针

指针是C语言最重要——也是最常被误解的特性之一。由于指针的重要性，本书将用3章对其进行讨论。本章侧重于基础知识，12章和17章则介绍指针的更高级应用。



本章将从内存地址及其与指针变量的关系入手，然后介绍取地址运算符和间接寻址运算符，随后是有关指针赋值的内容及给函数传递指针的方法，最后则讨论从函数返回指针。



## 指针变量

理解指针的第一步是在机器级上观察指针表示的内容。大多数现代计算机都将内存分割为字节（byte），每个字节可以存储8位的信息。

```
0 1 0 1 0 0 1 1
```

**每个字节都有唯一的地址（address），用来和内存中的其他字节相区别。如果内存中有n个字节，那么可以把地址看作0~n-1的数。**



| 地址 | 内容        |
| ---- | ----------- |
| 0    | 01010011    |
| 1    | 01110101    |
| 2    | 01110011    |
| 3    | 01100001    |
| 4    | 01101110    |
|      | .<br>.<br>. |
| n-1  | 01000011    |

可执行程序由代码（原始C程序中与语句相对应的机器指令）和数据（原始程序中的变量）两部分构成。**程序中的每个变量占有一个或多个字节内存，把第一个字节的地址称为是变量的地址。**下图中，变量i占用地址为2000和2001的两个字节，所以变量i的地址是2000：

|      | .<br>.<br>. |
| ---- | ----------- |
| 2000 | i           |
| 2001 | i           |
|      | .<br>.<br>. |

这就是指针的出处。虽然用数表示地址，但是地址的取值范围可能不同于整数的范围，所以一定不能用普通整型变量存储地址。但是，可以用特殊的指针变量存储地址。在用指针变量p存储i的地址时，我们说p“指向”i。**换句话说，指针就是地址，而指针变量就是存储地址的变量。**



本书的例子不再把地址显示为数，而采用更加简单的标记。为了说明指针变量p存储变量i的地址，将把p的内容显示为指向i的箭头：

```
p->i
```



### 指针变量的声明

**对指针变量的声明与对普通变量的声明基本一样，唯一的不同就是必须在指针变量名字前放置星号：**

```c
int *p;
```

上述声明说明p是指向int类型**对象**的指针变量。这里我们用术语**对象**来代替变量，是因为p**可以指向不属于变量的内存区域（见第17章）。**



指针变量可以和其他变量一起出现在声明中：

```c
int i,j,a[10],b[20],*p,*q;
```

在这个例子中，i和j都是普通整型变量，a和b是整型数组，而p和q是指向整型对象的指针。



C语言要求每个指针变量只能指向一种特定类型（**引用类型**）的对象：

```c
int *p		/* points only to integers */
double *q		/* points only to doubles */
char *c		/* points only to characters */
```

**至于引用类型是什么类型则没有限制。事实上，指针变量甚至可以指向另一个指针，即指向指针的指针。**



## 取地址运算符和间接寻址运算符

**为使用指针，C语言提供了一对特殊设计的运算符。为了找到变量的地址，可以使用&（取地址）运算符。如果x是变量，那么&x就是x在内存中的地址。为了获得对指针所指向对象的访问，可以使用*（间接寻址）运算符。如果p是指针，那么`*p`表示p当前指向的对象。**



### 取地址运算符

声明指针变量是为指针留出空间，但是并没有把它指向对象：

```c
int *p;		/* points nowhere in particular */
```

在使用前初始化p是至关重要的。一种初始化指针变量的方法是使用&运算符把某个变量的地址赋给它，或者更常采用左值：

```c
int i,*p;
...
p = &i;
```

通过把i的地址赋值给变量p的方法，上述语句把p指向了i：

```
p->i
```

在声明指针变量的同时对它进行初始化也是可行的：

```c
int i;
int *p = &i;
```

甚至可以把i的声明和p的声明合并，但是需要首先声明i：

```c
int i,*p = &i;
```



### 间接寻址地址符

一旦指针变量指向了对象，就可以使用*（间接寻址）运算符访问存在在对象中的内容。例如，如果p指向i，那么可以如下所示显示出i的值：

```c
printf("%d\n",*p);
```

printf函数将会显示i的值，而不是i的地址。



对变量使用&运算符产生指向变量的指针，而对指针使用*运算符则可以返回到原始变量：

```c
j = *&i; 	/* same as j = i; */
```

只要p指向i，`*p`就是i的别名。`*p`不仅拥有和i相同的值，而且对`*p`的的改变也会改变i的值。（`*p`是左值，所以对它赋值是合法的。）下面的例子说明了`*p`和i的等价关系，这些图显示了在计算中不同的点上p和i的值。

```c
p = &i;		// p->i(?)

i= 1;		// p->i(1)

printf("%d\n",i);	/* prints 1 */
printf("%d\n",*p);	/* prints 1*/
*p = 2;				/* p->i(2) */

printf("%d\n",i);	/* prints 2 */
printf("%d\n",*p);	/* prints 2 */
```

**不要把间接寻址运算符用于未初始化的指针变量。如果指针变量p没有初始化，那么试图使用p的值会导致未定义的行为:**

```c
int *p;
printf("%d",*p);	/** WRONG **/
```

给`*p`赋值尤其危险。如果p恰好具有有效的内存地址，下面的赋值会试图修改存储在该地址的数据：

```c
int *p;
*p = 1;		/* WRONG */
```

**如果上述赋值改变的内存单元属于该程序，那么可能会导致不规律的行为；如果改变的内存单元属于操作系统，那么很可能会导致系统崩溃。编译器可能会给出警告信息，告知p未初始化，所以请留意获得的警告消息。**



## 指针赋值

C语言允许使用赋值运算符进行指针的复制，前提是两个指针具有相同的类型。假设i、j、p和q声明如下：

```c
int i,j,*p,*q;
```

语句

```c
p = &i;
```

是指针赋值的示例，把i的地址复制给p。下面是另一个指针赋值的示例：

```c
q = p;
```

这条语句是把p的内容（即i的地址）复制给q，效果是把q指向了p所指向的地方。现在p和q都指向了i，所以可以用对`*p`或`*q`赋新值的方法来改变i：

```c
*p=1;  	// i =1
*q=2;	// i= 2
```

任意数量的指针变量都可以指向同一个对象。



注意不要把

```c
q = p;
```

和

```c
*q = *p;
```

搞混。第一条语句是指针赋值，而第二条语句不是。就如下面的例子显示的：

```c
 p = &i;
 q = &j;
 i = 1;
 
 /*****
 
 此时：
 p->i(1)
 q->j(?)
 
******/

*q = *p;  // p->i(1)    q->j(1)
```

赋值语句`*q=*p`是把p指向的值（i的值）复制到q指向的对象（变量j）中。



## 指针作为参数

到目前为止，我们回避了一个十分重要的问题：指针对什么有益呢？因为C语言中指针有几个截然不同的作用，所以此问题没有唯一的答案。在本节中，我们将看到如何把指向变量的指针用作函数的参数。指针的其他应用将在后续讨论。



在`函数-实际参数`一节已经看到，因为C语言用值进行参数传递，所以在函数调用中用作实际参数的变量无法改变。当希望函数能够改变变量时，C语言的这种特性就很讨厌了。当时曾尝试编写能改变两个参数的decompose函数，但是失败了。



指针提供了此问题的解决方法：不再传递变量x作为函数的实际参数，而是提供&x，即指向x的指针。声明相应的形式参数p为指针。调用函数时，p的值为&x，因此*p（p指向的对象）将是x的别名。函数体内`*p`的每次出现都将是对x的间接引用，而且允许函数既可以读取x也可以修改x。



为了用实例证明这种方法，下面通过把形式参数int_part和frac_part声明成指针的方法来修改decompose函数。现在decompose函数的定义形式如下：

```c
void decompose(double x,long *int_part,double *frac_part){
	*int_part = (long) x;
	*frac_part = x-*int_part;
}
```

decompose函数的原型既可以是：

```c
void decompose(double x,long *int_part,double *frac_part);
```

也可以是:

```c
void decompose(double long *,double *);
```

以下列方式调用decompose函数；

```c
decompose(3.14159,&i,&d);
```

因为i和d前有取地址运算符&，所以decompose函数的实际参数是指向i和d的指针，而不是i和d的值。调用decompose函数时，把值3.14159复制到x中，把指向i的指针存储在int_part中，而把指向d的指针存储在frac_part中。



当compose函数返回时，就像原来希望的那样，i和d将分别有值3和0.14159。



用指针作为函数的实际参数实际上不新鲜，从第2章开始就已经在scanf函数调用中使用过了。思考下面的例子：

```c
int i;
...
scanf("%d",&i);
```

**必须把&放在i的前面以便给scanf函数传递指向i的指针，指针会告诉scanf函数把读取的值放在哪里。如果没有&运算符，传递给scanf函数的将是i的值（函数无法修改非指针形参的值）。**



虽然scanf函数的实际参数必须是指针，但并不总需要&运算符。在下面的例子中，我们向scanf函数传递了一个指针变量：

```c
int i,*p;
...
p = &i;
scanf("%d",p);
```

既然p包含了i的地址，那么scanf函数将读入整数并把它存储在i中。在调用中使用&运算符将是错误的：

```c
scanf("%d",&p);		/* WRONG */
```

scanf函数读入整数并且把它存储在p中而不是i中。



向函数传递需要的指针却失败了可能会导致严重的后果。假设我们在调用decompose函数时没有在i和d前面加上&运算符：

```c
decompose(3.14159,i,d);
```

decompose函数期望第二个和第三个实际参数是指针，但传入的却是i和d的值。decompose函数没有办法区分，所以它会把i的d的值当成指针来使用。当decompose函数把值存储到`*int_part`和`*frac_part`中时，它会修改未知的内存地址，而不是修改i和d。



如果已经提供了decompose函数的原型（当然，应该始终这么做），那么编译器将告诉我们实际参数的类型不对。然而，在scanf的例子中，编译器通常不会检查出传递指针失败，因此scanf函数特别容易出错。



### 找出数组中的最大元素和最小元素

为了说明如何在函数中传递指针，下面来看一个名为max_min的函数，该函数用于找出数组中的最大元素和最小元素。调用max_min函数时，将传递两个指向变量的指针；然后max_min函数把答案存储在这些变量中。max_min函数具有下列原型：

```c
void max_min(int a[],int n,int *max,int *min);
```

max_min函数的调用可以具有下列的形式：

```c
max_min(b,N,&big,&small);
```

b是整型数组，而N是数组b中的元素数量。big和small是普通的整型变量。当max_min函数找到数组b中的最大元素时，通过给`*max`赋值的方法把值存储在big中。（因为max指向big，所以给`*max`赋值将会修改big的值。）类似地，可以通过给`*min`赋值把b中最小元素的值存储在small中。



为了测试max_min函数，我们编写程序用来往数组中读入10个数，然后把数组传递给max_min函数，并且显示结果：

```
Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
Largest: 102
Smallest: 7
```

下面是完整的程序（maxmin.c）：

```c
#include <stdio.h>
#define N 10

void max_min(int a[],int n,int *max,int *min);

int main(void) {
    int b[N],i,big,small;

    printf("Enter %d numbers: ",N);
    for (i=0;i<N;i++)
        scanf("%d",&b[i]);

    max_min(b,N,&big,&small);

    printf("Largest: %d\n",big);
    printf("Smallest: %d\n",small);

    return 0;
}

void max_min(int a[],int n,int *max,int *min) {
    int i;

    *max = *min =a[0];
    for (i=1;i<N;i++) {
        if (a[i] > *max)
            *max = a[i];
        else if (a[i] < *min)
            *min = a[i];
    }
}
```

### 用const保护参数

当调用函数并且把指向变量的指针作为参数传入时，通常会假设函数将修改变量（否则，为什么函数需要指针呢？）例如，如果在程序中看到语句：

```c
f(&x);
```

大概是希望f改变x的值。但是，f仅需要检查x的值而不是改变它的值也是可能的。指针可能高效的原因是：如果变量需要大量的存储空间，那么传递变量的值会浪费时间和空间。



**可以使用单词const来表明函数不会改变指针参数所指的对象（但是可以改变指针本身）**：const应放置在形式参数的声明中，后面紧跟着形式参数的类型说明：

```c
void f(const int *p)
{
	*p = 0;		/* WRONG */
}
```

这一用法表明p是指向“常整数”的指针。试图改变`*p`是编译器会检查的一种错误。



需要注意的是，`void f(const int *p)`说明的是不能改变指针p指向的整数，但是并不阻止f改变p自身。



`void f(int * const p);`是合法的。然而效果不同于把const放在p的类型前面。在p的类型前面放置const可以保护p指向的对象。在p的类型后面放置const可以保护p本身：

```c
void f(int * const p);
{
	int j;
	*p = 0;	/* legal */
	p = &j; /* WRONG */
}
```

这一特性并不经常用到。因为p很少是另一个指针（调用函数时的实际参数）的副本，所以极少有什么理由保护它。



更罕见的一种情况是需要同时保护p和它所指向的对象，这可以通过在p类型的前和后逗放置const来实现：

```c
void f(const int * const p);
{
    int j;
    
    *p = 0;
    p = &j;
}
```





## 指针作为返回值

我们不仅可以为函数传递指针，还可以编写返回指针的函数。返回指针的函数是相对普遍的，后面会遇到几个。



当给定指向两个整数的指针时，下列函数返回指向两整数中较大数的指针：

```c
int *max(int *a,int *b)
{
	if(*a > *b)
		return a;
	else
		return b;
}
```

调用max函数时，用指向两个int型变量的指针作为参数，并且把结果存储在一个指针变量中：

```c
int *p,i,j;
...
p = max(&i,&j);
```

调用max期间，`*a`是i的别名，而`*b`是j的别名。如果i的值大于j，那么max返回i的地址；否则，max返回j的地址。调用函数后，p可以指向i也可以指向j。



这个例子中max函数返回的指针是作为实际参数传入的两个指针中的一个，但这不是唯一的选择。函数也可以返回指向外部变量或指向声明为static的局部变量的指针。



**永远不要返回指向自动局部变量的指针：**

```c
int *f(void){
	int i;
	...
	return &i;
}
```

一旦f返回，变量i就不存在了，所以指向变量i的指针将是无效的。有的编译器会在这种情况下给出类似“function returns address of local variable”的警告。



指针可以指向数组元素，而不仅仅是普通变量。设a为数组，则`&a[i]`是指向a中元素i的指针。当函数的参数中有数组时，返回一个指向数组中的某个元素的指针有时是挺有用的。例如，下面的函数假定数组a有n个元素，并返回一个指向数组中间元素的指针：

```c
int *find_middle(int a[],int n){
	return &a[n/2];
}
```



## 显示变量的地址

任何指针（包括变量的地址）都可以通过调用printf函数并在格式串中使用转换说明%p来显示。

