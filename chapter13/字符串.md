# 字符串

前几章虽然使用过char类型变量和char类型数组，但是始终没有谈到处理字符序列（术语是字符串）的便捷方法。本章将会补上，并将介绍字符串常量（C标准中称为字符串字面量）和字符串变量。其中，字符串变量可以在程序运行过程中发送改变。



## 字符串字面量

字符串字面量是用一对双引号括起来的字符序列：

```
"When you come to a fork in the road, take it."
```

之前例子中的字符串字面量常常作为格式串出现在printf函数和scanf函数的调用中。



### 字符串字面量中的转义序列

字符串字面量可以像字符常量一样包含转义序列。在printf函数和scanf函数的格式串中已经使用过转义字符。例如，字符串

```
"Candy\nIs dandy\nBut liquor\nIs quicker.\n --Ogden Nash\n"
```

中的每一个字符`\n`都会导致光标移到下一行。



字符串字面量中的八进制数和十六进制数的转义序列也都是合法的，但是它们不像字符转义序列那样常见。



### 如何存储字符串字面量

我们经常在printf函数调用和scanf函数调用中用到字符串字面量。但是，当调用printf函数并且用字符串字面量作为参数时，究竟传递了什么呢？为了回答这个问题，需要明白字符串字面量是如何存储的。



**从本质而言，C语言把字符串字面量作为字符数组来处理。当C语言编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。这块内存空间将用来存储字符串字面量中的字符，以及一个用来标志字符串末尾的额外字符（空字符）。空字符是一个所有位都为0的字节，因此用转义序列`\0`来表示。**



不要混淆空字符（'\0'）和零字符（'0'）。空字符的码值为0，而零字符则有不同的码值（ASCII中为48）。



例如，字符串字面量“abc”是作为有4个字符的数组来存储的（a、b、c和\0）：

| a    | b    | c    | \0   |
| ---- | ---- | ---- | ---- |



字符串字面量可以为空。字符串“”作为单独一个空字符来存储：`\0`。



既然字符串字面量是作为数组来存储的，那么编译器会把它看作是`char *`类型的指针。例如，printf函数和scanf函数都接收`char *`类型的值作为它们的第一个参数。思考下面的例子：

```c
printf("abc");
```

当调用printf函数时，会传递“abc”的地址（即指向存储字母a的内存单元的指针）。



### 字符串字面量的操作

通常情况下可以在任何C语言允许使用`char *`指针的地方使用字符串字面量。例如，字符串字面量可以出现在赋值运算符的右边：

```c
char *p;

p = "abc";
```

**这个赋值操作不是复制“abc”中的字符，而是使p指向字符串的第一个字符。**



C语言允许对指针取下标，因此可以对字符串字面量取下标：

```c
char ch;

ch = "abc"[1];
```

ch的新值将是字母b。其他可能的下标是0（字母a）、2（字母c）和3（空字符）。字符串字面量的这种特性并不常用，但有时也比较方便。思考下面的函数，这个函数把0~15的数转换成等价的十六进制的字符形式：

```c
char digit_to_hex_char(int digit)
{
	return "0123456789ABCDEF"[digit];
}
```

试图改变字符串字面量会导致未定义的行为：

```c
char *p = "abc";

*p= 'd';  // WRONG
```



### 字符串字面量与字符常量

只包含一个字符的字符串字面量不同于字符常量。字符串字面量“a”是用指针来表示的，这个指针指向存放字符`“a”`（后面紧跟空字符）的内存单元。字符常量`‘a’`是用整数（字符集的数值码）来表示的。



不要在需要字符串的时候使用字符（反之亦然）。函数调用：

```c
printf("\n");
```

是合法的，因为printf函数期望指针作为它的第一个参数。然而，下面的调用却是非法的：

```c
printf('\n');		// WRONG
```





## 字符串变量

一些编程语言为声明字符串变量提供了专门的string类型。C语言采取了不同的方式：只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。这种方法很简单，但使用起来有很大难度。有时很难辨别是否把字符数组作为字符串来使用。如果编写自己的字符串处理函数，请千万注意要正确地处理空字符。而且，要确定字符串长度没有比逐个字符地搜索空字符更快捷的方法了。



假设需要用一个变量来存储最多有80个字符的字符串。由于字符串在末尾处需要有空字符，我们把变量声明为含有81个字符的数组：

```c
#define STR_LEN 80
...
char str[STR_LEN+1];
```

这里把STR_LEN定义为80而不是81，强调的是str可以存储最多有80个字符的字符串；然后才在str的声明中对STR_LEN加1。这是C程序员常用的方式。



当声明用于存放字符串的字符数组时，要始终保证数组的长度比字符串的长度多一个字符。这是因为C语言规定每个字符串都要以空字符结尾。如果没有给空字符预留位置，可能会导致程序运行时出现不可预知的结果，因为C函数库中的函数假设字符串都是以空字符结尾的。



声明长度为STR_LEN+1的字符数组并不意味着它总是用于存放长度为STR_LEN的字符串。字符串的长度取决于空字符的位置，而不是取决于用于存放字符串的字符数组的长度。有STR_LEN+1个字符的数组可以存放多种长度的字符串，范围是从空字符串到STR_LEN的字符串。



### 初始化字符串变量

字符串变量可以在声明时进行初始化：

```c
char date1[8] = "June 14";
```

编译器将把字符串“June 14”中的字符复制到数组date1中，然后追加一个空字符从而使date1可以用作字符串使用。date1将如下所示：

| J    | u    | n    | e    |      | 1    | 4    | \0   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

"June 14"看起来是字符串字面量，但其实不然。C编译器会把它看成是数组初始化式的缩写形式。实际上，我们可以写成：

```c
char date1[8] = {'J','u','n','e',' ','1','4','\0'};
```

明显是原来的形式更便于阅读。



如果初始化式太短以至于不能填满字符串变量将会如何呢？在这种情况下，编译器会添加空字符。因此，在声明

```c
char date2[9] = "June 14";
```

之后，date2将如下所示：

| J    | u    | n    | e    |      | 1    | 4    | \0   | \0   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

大体上来说，这种行为与C语言处理数组初始化式的方法一致。当数组的初始化式比数组本身短时，余下的数组元素会被初始化为0。





如果初始化式比字符串变量长又会怎样呢？这对字符串而言是非法的，就如同对数组是非法的一样。然而，C语言允许初始化式（不包括空字符）与变量有完全相同的长度：

```c
char date3[7] = "June 14";
```

**由于没有给空字符留空间，所以编译器不会试图存储空字符。**



**如果正在计划对用来放置字符串的字符数组进行初始化，一定要确保数组的长度要长于初始化式的长度，否则，编译器将忽略空字符，这将使得数组无法作为字符串使用。**



字符串变量的声明中可以省略它的长度。这种情况下，编译器会自动计算长度：

```c
char date4[] = "June 14";
```



编译器为date4分配8个字符的空间，这足够存储“June 14”中的字符和一个空字符（**不指定date4的长度并不意味着以后可以改变数组的长度。一旦编译了程序，date4的长度就固定是8了。**）如果初始化式很长，那么省略字符串变量的长度是特别有效的，因为手工计算长度很容易出错。



### 字符数组和字符指针

比较一下下面这两个看起来很相似的声明：

```c
char date[] = "June 14";
char *date = "June 14";
```

**前者声明date是一个数组，后者声明date是一个指针。正因为有了数组和指针之间的紧密关系，才使上面这两个声明中的date都可以用作字符串。尤其是，任何期望传递字符数组或字符指针的函数都能够接收这两种声明的date作为参数。**



**然而，需要注意，不能错误地认为上面这两种date可以互换。两者之间存在很大的差异：**

- **在声明为数组时，就像任意数组元素一样，可以修改存储在date中的字符。在声明为指针时，date指向字符串字面量，前面已经看到字符串字面量是不可以修改的。**
- **在声明为数组时，date是数组名。在声明为指针时，date是变量，这个变量可以在程序执行期间指向其他字符串。**



如果希望可以修改字符串，那么就要建立字符数组来存储字符串，声明指针变量就不够的。下面的声明使编译器为指针变量分配了足够的内存空间：

```c
char *p;
```

可惜的是，它不能为字符串分配空间。（因为我们没有指明字符串的长度。）在使用p作为字符串之前，必须把p指向字符数组。一种可能是把p指向已经存在的字符串变量：

```c
char str[STR_LEN+1],*p;

p = str;
```

现在p指向了str的第一个字符，所以可以把p作为字符串使用了。另一种可能是让p指向一个动态分配的字符串（见17章——动态分配字符串）。



使用未初始化的指针变量作为字符串是非常严重的错误。考虑下面的例子，它试图创建字符串“abc”：

```c
char *p;

p[0]='a';	/* WRONG */
```

因为p没有被初始化，所以我们不知道它指向哪里。用指针p把字符a写入内存会导致未定义的行为。



## 字符串的读和写

使用printf函数或puts函数来写字符串是很容易的。读字符串却有点麻烦，主要是因为输入的字符串可能比用来存储它的字符串变量长。为了一次性读入字符串，可以使用scanf函数或gets函数，也可以每次读入一个字符。



### 用printf函数和puts函数写字符串

转换说明%s允许printf函数写字符串。考虑下面的例子：

```c
char str[] = "Are we having fun yet?";

printf("%s\n",str);
```

输出会是：

```
Are we having fun yet?
```

printf函数会逐个写字符串中的字符，直到遇到空字符才停止。（如果空字符丢失，printf函数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止。）



如果只想显示字符串的一部分，可以使用转换说明`%.ps`，这里p是要显示的字符数量。语句

```c
printf("%.6s\n",str);
```

会显示

```
Are we
```

字符串跟数一样，可以在指定字段内显示。转换说明%ms会在大小为m的字段内显示字符串。（对于超过m个字符的字符串，printf函数会显示出整个字符串，而不会截断。）如果字符串少于m个字符，则会在字段内向右对其输出。如果要强制左对齐，可以在m前加一个减号。m值和p值可以组合使用：转换说明%m.ps会使字符串的前p个字符在大小为m的字段内显示。



printf函数不是唯一一个字符串输出函数。C函数库还提供了puts函数，此函数可以按如下方式使用：

```c
puts(str);
```

puts函数只有一个参数，即需要显示的字符串。在写完字符串后，puts函数总会添加一个额外的换行符，从而前进到下一个输出行的开始处。



### 用scanf函数和gets函数读字符串

转换说明%s允许scanf函数把字符串读入字符数组：

```c
scanf("%s",str);
```

**在scanf函数调用中，不需要在str前添加运算符&，因为str是数组名，编译器在把它传递给函数时会把它当作指针来处理。**



**调用时，scanf函数会跳过空白字符（3.2节），然后读入字符并存储到str中，直到遇到空白字符为止。scanf函数始终会在字符串末尾存储一个空字符。**



**用scanf函数读入字符串永远不会包含空白字符。因此，scanf函数通常不会读入一整行输入。换行符会使scanf函数停止读入，空格符或制表符也会产生同样的结果。为了一次读入一整行输入，可以使用gets函数。类似于scanf函数，gets函数把读入的字符放到数组中，然后存储一个空字符。然而，在其他方面gets函数有些不同于scanf函数。**

- **gets函数不会在开始读字符串之前跳过空白字符（scanf函数会跳过）。**
- **gets函数会持续读入直到找到换行符才停止（scanf函数会在任意空白字符处停止）。此外，gets函数会忽略掉换行符，不会把它存储到数组中，用空字符代替换行符。**



为了领会scanf函数与gets函数之间的差异，考虑下面的程序段：

```c
char sentence[SENT_LEN+1];

printf("Enter a sentence: \n");
scanf("%s",sentence);
```

假定用户输入信息：

```
To C, or not to C: that is the question.
```

scanf函数会把字符处“To”存储到sentence中。下一次scanf函数调用将从单词To后面的空格处继续读入这行。



现在假设用gets函数替换scanf函数：

```c
gets(sentence);
```

当用户输入和先前相同的信息时，gets函数会把字符处

```
" To C, or not to C: that is the question."
```

存储到sentence中。



**注意：在把字符读入数组时，scanf函数和gets函数都无法检测数组何时被填满。因此，它们存储字符时可能越过数组的边界，这会导致未定义的行为。通过用转换说明%ns代替%s可以使scanf函数更安全。这里的数字n指出可以存储的最多字符数。可惜的是，gets函数天生就是不安全的，fgets函数则是一种好得多的选择。**



### 逐个字符读取字符串

因为对许多程序而言，scanf函数和gets函数都有风险且不够灵活，C程序员经常会自己编写输入函数。通过每次一个字符的方式来读入字符处，这类函数可以提供比标准输入函数更大程度的控制。



如果决定设计自己的输入函数，那么就需要考虑下面的这些问题。

- 在开始存储字符串之前，函数应该跳过空白字符吗？
- 什么字符会导致函数停止读取：换行符、任意空白字符还是其他某种字符？需要存储这类字符还是忽略掉？
- 如果输入的字符串太长以致无法存储，那么函数应该做些什么：忽略额外的字符还是把它们留给下一次输入操作？



假定我们所需要的函数不会跳过空白字符，在第一个换行符（不存储到字符串中）处停止读取，并且忽略额外的字符。函数将有如下原型：

```c
int read_line(char str[],int n);
```

str表示用来存储输入的数组，而n是读入字符的最大数量。如果输入行包含多余n个的字符，read_line函数将忽略多余的字符。read_line函数会返回实际存储在str中的字符数量（0到n之间的任意数）。我们不可能总是需要read_line的返回值，但是有这个返回值也没问题。



read_line函数主要由一个循环构成。只要str中还有空间，此循环就会调用getchar函数逐个读入字符并把它们存储到str中。在读入换行符时循环终止。（严格地说，如果getchar函数读入字符失败，也应该终止循环，但是这里暂时忽略这种复杂情况。）下面是read_line函数的完整定义：

```c
int read_line(char str[],int n)
{
	int ch,i=0;
	
	while((ch=getchar()) != '\n'){
		if(i < n)
			str[i++] = ch;
	}
	str[i]='\0';		// 终止符0
	return i;			// 已存储的字符数量
}
```

注意，ch的类型是int而不是char，这是因为getchar把它读取的字符作为int类型的值返回。



返回之前，read_line函数在字符串的末尾放置一个空字符。scanf函数和gets函数等标准函数会自动在输入字符串的末尾放置一个空字符；然而，如果要自己写输入函数，必须手工加上空字符。



## 访问字符串中的字符

字符串是以数组的形式存储的，因此可以使用下标来访问字符串中的字符。例如，为了对字符串s中的每个字符进行处理，可以设定一个循环来对计数器i进行自增操作，并通过表达式s[i]来选择字符。



假定需要一个函数来统计字符串中空格的数量。利用数组取下标操作可以写出如下函数：

```c
int count_spaces(const char s[]){
	int count = 0,i;
	
	for(i = 0;s[i] != '\0',i++)
		if(s[i] == ' ')
			count++;
	return count;
}
```

在s的声明中加上const表明count_spaces函数不会改变数组。**如果s不是字符串，count_spaces将需要第2个参数来指明数组的长度。然而，因为s是字符串，所以count_spaces可以通过测试空字符来定位s的末尾。**



许多C程序员不会像例子中编写count_spaces函数，他们更愿意使用指针来跟踪字符串中的当前位置。就像前面看到的那样，这种方法对于处理数组来说一直有效，但在处理字符串方面尤其方便。



下面用指针算术代替数组取下标来重新编写count_spaces函数。这次不再需要变量i，而是利用s自身来跟踪字符串中的位置。通过对s反复进行自增操作，count_spaces函数可以逐个访问字符串中的字符。下面是count_spaces函数的新版本：

```c
int count_spaces(const char *s){
	int count = 0;
	
	for(;*s != '\0';s++)
		if(*s == ' ')
			count++;
	return count;
}
```

注意，const没有阻止count_spaces函数对s的修改，它的作用是阻止函数改变s所指向的字符。**而且，因为s是传递给count_spaces函数的指针的副本，所以对s进行自增操作不会影响原始的指针。**



count_spaces函数示例引出了一些如何编写字符串函数的问题。

- **用数组操作或指针操作访问字符串中的字符，哪种方法更好一些呢？**只要使用方便，可以随意使用任意一种方法，甚至可以混合使用两者方法。在count_spaces函数的第2种写法中，不再需要变量i，而是把s作为指针来对函数进行一些简化。从传统意义上来说，C程序员更倾向于使用指针操作来处理字符串。
- **字符串形式参数应该声明为数组还是指针呢？**count_spaces函数的两种写法说明了这两种选择：第1种写法把s声明为数组，而第二种写法则把s声明为指针。实际上，这两种声明之间没有任何差异。回顾之前的内容就知道，编译器会把数组型的形式参数视为指针。
- **形式参数的形式（s[]或者*s）是否会对实际参数产生影响呢？**不会的。当调用count_spaces函数时，实际参数可以是数组名、指针变量或者字符串字面量。count_spaces函数无法说明差异。



## 使用C语言的字符串库

**一些编程语言提供的运算符可以对字符串进行复制、比较、拼接、选择子串等操作，但C语言的运算符根本无法操作字符串。在C语言中把字符串当作数组来处理，因此对字符串的限制方式和对数组的一样，特别是，它们都不能用C语言的运算符进行复制和比较操作。**



直接复制或比较字符串会失败。例如，假定str1和str2有如下声明：

```c
char str1[10],str2[10];
```

利用=运算符来把字符串复制到字符数组中是不可能的：

```c
str1 = "abc";		// WRONG
str2 = str1;		// WRONG
```

从12.3节可知，**把数组名用作=的左操作数是非法的。但是，使用=初始化字符数组是合法的：**

```c
char str1[10] = "abc";
```

这是因为**在声明中，=不是赋值运算符。**



试图使用关系运算符或判等运算符来比较字符串是合法的，但不会产生预期的结果：

```c
if(str1 == str2)...		// WRONG
```

**这条语句把str1和str2作为指针来进行比较，而不是比较两个数组的内容。因为str1和str2有不同的地址，所以表达式str1 == str2的值一定为0。**





幸运的是，字符串的所有操作功能都没有丢失：C语言的函数库为完成对字符串的操作提供了丰富的函数集。这些函数的原型驻留在`<string.h>`头中，所以需要字符串操作的程序应该包含下列内容：

```c
#include <string.h>
```

在`<string.h>`中声明的每个函数至少需要一个字符串作为实际参数。字符串形式参数声明为`char *`类型，这使得实际参数可以是字符数组、`char *`类型的变量或者字符串字面量——上述这些都适合作为字符串。然而，要注意那些没有声明为const的字符串形式参数。这些形式参数可能会在调用函数时发生改变，所以对应的实际参数不应该是字符串字面量。



`<string.h>`中有许多函数，这里介绍几种最基本的。在后续的例子中，假设str1和str2都是用字符串的字符数组。



### strcpy函数

strcpy（字符串）复制函数在`<string.h>`中的原型如下：

```c
char *strcpy(char *s1,const char *s2);
```

strcpy函数把字符串s2复制给字符串s1。（准确地讲，应该说成是“strcpy函数把s2指向的字符串复制到s1指向的数组中”。）也就是说，strcpy函数把s2中的字符复制到s1中直到遇到s2中的第一个空字符为止（该空字符也需要复制）。strcpy函数返回s1（即指向目标字符串的指针）。这一过程不会改变s2指向的字符串，因此将其声明为const。



strcpy函数的存在弥补了不能使用赋值运算符复制字符串的不足。例如，假设我们想把字符串“abcd”存储到str2中，不能使用下面的赋值：

```c
str2 = "abcd";		// WRONG
```

这是因为str2是数组名，不能出现在赋值运算的左侧。但是，这时可以调用strcpy函数：

```c
strcpy(str2,"abcd");		// str1 now contains "abcd"
```

类似地，不能直接把str2赋值给str1，但是可以调用strcpy：

```c
strcpy(str1,str2);			// str1 now contains "abcd"
```

**大多数情况下我们会忽略strcpy函数的返回值，但有时候strcpy函数调用是一个更大的表达式的一部分，这时其返回值就比较有用了。例如，可以把一系列strcpy函数调用连起来：**

```c
strcpy(str1,str(str2,"abcd"));
/* both str1 and str2 now contain "abcd" */
```



**在strcpy(str1,str2)的调用中，strcpy函数无法检查str2指向的字符串的大小是否真的适合str1指向的数组。假设str1指向的字符串长度为n，如果str2指向的字符串中的字符数不超过n-1，那么复制操作就可以完成。但是，如果str2指向更长的字符串，那么结果就无法预料了。（因为strcpy函数会一直复制到第一个空字符为止，所以它会越过str1指向的数组的边界继续复制。）**



**尽管执行会慢一点，但是调用strccpy函数仍是一种更安全的复制字符串的方法。strncpy类似于strcpy，但它还有第三个参数可以用于限制所复制的字符数。为了将str2复制到str1，可以使用如下的strncpy调用：**

```c
strncpy(str1,str2,sizeof(str1));
```



**只要str1足够装下存储在str2中的字符串（包括空字符），复制就能正确完成。当然，strncpy本身也不是没有风险。如果str2中存储的字符串的长度大于str1数组的长度，strncpy会导致str1中的字符串没有终止的空字符。下面是一种更安全的用法：**

```c
strncpy(str1,str2,sizeof(str1)-1);	// char占一个字节，因此sizeof计算结果正好是数组中的元素个数
str1[sizeof(str1)-1]= '\0';
```

第二条语句确保str1总是以空字符结束，即使strncpy没能从str2中复制到空字符。



### strlen函数

strlen(求字符串长度)函数的原型如下：

```c
size_t strlen(const char *s);
```

定义在C函数库中的size_t是一个typedef名字，表示C语言中的一种无符号整型。除非是处理极长的字符串，否则不需要关心其技术细节。可以简单地把strlen的返回值作为整数处理。



strlen函数返回字符串s的长度：**s中第一个空字符之前的字符个数（不包括空字符）。**下面是几个示例：

```c
int len;

len = strlen("abc");		// len is now 3
len = strlen("");			// len is now 0
strcpy(str1,"abc");			
len = strlen(str1);			// len is now 3
```

最后一个例子说明了很重要的一点：**当用数组作为实际参数时，strlen不会测量数组本身的（最大）长度，而是返回存储在数组中的字符串的长度。**



### strcat函数

strcat（字符串拼接）函数的原型如下：

```c
char *strcat(char *s1,const char *s2);
```

strcat函数把字符串s2的内容追加到字符串s1的末尾，并且返回字符串s1（指向结果字符串的指针）。



下面列举了一些使用strcat函数的例子：

```c
strcpy(str1,"abc");
strcat(str1,"def");			// str1 now contains "abcdef"
strcpy(str1,"abc");			
strcpy(str2,"def");
strcat(str1,str2);			// str1 now contains "abcdef"
```

同使用strcpy函数一样，通常忽略strcat函数的返回值。下面的例子说明了可能使用返回值的方法：

```c
strcpy(str1,"abc");
strcpy(str2,"def");
strcat(str1,strcat(str2,"ghi"));
	/* str1 now contains "abcdefghi"; str2 contains "defghi" */
```



如果str1指向的数组没有大到足以容纳str2指向的字符串中的字符，那么调用strcat(str1,str2)的结果将是不可预测的。考虑下面的例子：

```c
char str1[6] = "abc";
strcat(str1,"def");		// WRONG
```

strcat函数会试图把字符d、e、f和`\0`添加到str1中已存储的字符串的末尾。不幸的是，str1仅限于6个字符，这导致strcat函数写到了数组末尾的后面。



**strncat函数比strcat更安全，但速度也慢一些。与strncpy一样，它有第三个参数来限制所复制的字符数。**下面是调用的形式：

```c
strncat(str1,str2,sizeof(str1)- strlen(str1)-1);
```

strncat函数会在遇到空字符时终止str1，第三个参数（待复制的字符数）没有考虑该空字符。在上面的例子中，第三个参数计算str1中的剩余空间（由表达式`sizeof(str1)-strlen(str1)`给出，`sizeof(str1)`计算出整个char数组可存储的字符个数，`strlen(str1)`计算出该char数组目前已使用的字符数)，然后减去1以确保为空字符留下空间。



### strcmp函数

strcmp(字符串比较)函数的原型如下：

```c
int strcmp(const char *s1,const char *s2);
```

strcmp函数比较字符串s1和字符串s2，然后根据s1是小于、等于或大于s2，函数返回一个小于、等于或大于0的值。例如，为了检查str1是否小于str2，可以写

```c
if(strcmp(str1,str2) < 0)	// is str1 < str2?
...
```

为了检查str1是否小于或等于str2，可以写

```c
if(strcmp(str1,str2) <= 0)	/ is str1 <= str2
...
```

通过选择适当的关系运算符（<、<=、>、>=）或判等运算符（==、!=），可以测试str1和str2之间任何可能的关系。



类似于字典中单词的编排方式，strcmp函数利用字典顺序进行字符串比较。更精确地说，只要满足下列两个条件之一，那么strcmp函数就认为s1是小于s2的。

- s1与s2的前i个字符一致，但是s1的第i+1个字符小于s2的第i+1个字符。例如，"abc"小于"bcd"，"abd"小于"abe"。
- s1的所有字符与s2的字符一致，但是s1比s2短。例如，"abc"小于"abcd"。



当比较两个字符串中的字符时，strcmp函数会查看字符对应的数值码。一些底层字符集的知识可以帮助预测strcmp函数的结果。例如，下面是ASCII字符集的一些重要性质。

- A~Z、a~z、0~9这几组字符的数值码都是连续的。
- 所有的大写字母都小于小写字母（在ASCII码中，65~90的编码表示大写字母，97~122的编码表示小写字母。）
- 数字小于字母。（48~57的编码表示数字。）
- 空格符小于所有打印字符。（ASCII码中空格符的值是32。）



### 显示一个月的提醒列表

为了说明C语言字符串函数库的用法，现在来看一个程序。这个程序会显示一个月的每日提醒列表。用户需要输入一系列提醒，每条提醒都要有一个前缀来说明是一个月中的哪一天。当用户输入的是0而不是有效的日期时，程序会显示出录入的全部提醒的列表，按日期排序的。下面是与程序的会话示例：

```
Enter day and reminder:24 Susan`s birthday
Enter day and reminder:5 6:00 - Dinner with Marge and Russ
Enter day and reminder:26 Movie - "Chinatown"
Enter day and reminder:0

Day Reminder
  5 6:00 - Dinner with Marge and Russ
 24 Susan`s birthday
 26 Movie - "Chinatown"
```

总体策略不是很复杂：程序需要读入一系列日期和提醒的集合，并且按照顺序进行存储（按日期排序），然后显示出来。为了读入日期，会用到scanf函数。为了读入提醒，会用到之前介绍的read_line函数。



把字符串存储在二维的字符数组中，数组的每一行包含一个字符串。在程序读入日期以及相关的提醒后，通过使用strcmp函数进行比较来查找数组从而确定这一天所在的位置。然后，程序会使用strcpy函数把此位置之后的所有字符串往后移动一个位置。最后，程序会把这一天复制到数组中，并且调用strcat函数来把提醒附加到这一天后面。（日期和提醒在此之前是分开存放的。）



当然，总会有少量略微复杂的地方。例如，希望日期在两个字符的字段中右对齐以便它们的个位可以对齐。有很多种方法可以解决这个问题。这里选择用scanf函数吧日期读入到整型变量中，然后调用sprintf函数把日期转换成字符串格式。sprintf是个类似于printf的库函数，不同之处在于它会把输出写到字符串中。函数调用：

```c
sprintf(day_str,"%2d",day);
```

即使输入有更多的数字，在%与d之间的数2也会通知scanf函数在读入两个数字后停止。



解决了上述细节问题之后，程序编写如下（remind.c）：

```c
/*
 Created by pvnk1u on 2024/10/23.
*/

#include <stdio.h>
#include <string.h>

// 最大提醒数量
#define MAX_REMIND 50
// 消息长度
#define MSG_LEN 60

int read_line(char str[],int n);

int main(void) {
    // 把字符串存储在二维的字符数组中
    char reminders[MAX_REMIND][MSG_LEN+3];
    char day_str[3],msg_str[MSG_LEN+1];
    int day,i,j,num_remind = 0;

    for (;;) {
        if (num_remind == MAX_REMIND) {
            printf("--No Space left --\n");
            break;
        }
        printf("Enter day and reminder: ");
        scanf("%2d",&day);
        if (day == 0)
            break;
        sprintf(day_str,"%2d",day);
        read_line(msg_str,MSG_LEN);

        for (i=0;i<num_remind;i++)
            if (strcmp(day_str,reminders[i]) < 0)
                break;

        for (j = num_remind;j>i;j--)
            strcpy(reminders[j],reminders[j-1]);

        strcpy(reminders[i],day_str);
        strcat(reminders[i],msg_str);

        num_remind++;
    }

    printf("\nDay Reminder\n");
    for (i=0;i<num_remind;i++)
        printf(" %s\n",reminders[i]);
    return 0;
}

int read_line(char str[],int n) {
    int ch,i=0;

    while ((ch=getchar()) != '\n')
        if (i<n)
            str[i++] = ch;
    str[i] = '\0';
    return i;
}
```

虽然这个程序很好地说明了strcpy函数、strcat函数和strcmp函数，但是作为实际的提醒程序，它还缺少一些东西。显然有许多需要完善的地方，从小调整到大改进都有（例如，当程序终止时把提醒保存到文件中）。后续将会进一步改进。



## 字符串惯用法

处理字符串的函数是特别丰富的惯用法资源。本节将探讨几种最著名的惯用法，并利它们编写strlen函数和strcat函数。当然，我们可能永远都不需要编写这两个函数，因为它们是标准函数库的一部分，但类似的函数还是有可能需要编写的。



本节使用的简洁风格是在许多C程序员中流行的风格。即使不准备在自己的程序中使用，也应该掌握这种风格，因为很可能会在其他人编写的程序中遇到。



在开始之前最后再说一点。不可以编写与库函数同名的函数，即使不包含该函数所属的头也不行。事实上，所有以str和一个小写字母开头的名字都是保留的（以便在未来的C标准版本中往`<string.h>`头里加入函数）。



### 搜索字符串的结尾

许多字符串操作需要搜索字符串的结尾。strlen函数就是一个重要的例子。下面的strlen函数搜索字符串参数的结尾，并且使用一个变量来跟踪字符串的长度：

```c
size_t strlen(const char *s)
{
	size_t n;
	
	for(n=0;*s != '\0';s++)
		n++;
	return n;
}
```

指针s从左至右扫描整个字符串，变量n记录当前已经扫描的字符数量。当s最终指向一个空字符时，n所包含的值就是字符串的长度。



现在看看是否能精简strlen函数的定义。首先，把n的初始化移到它的声明中：

```c
size_t strlen(const char *s)
{
	size_t n=0;
	
	for(;*s != '\0';s++)
		n++;
	return n;
}
```

接下来注意到，条件`*s != '\0'`与`*s != 0 `是一样的，因为空字符的整数值就是0。而测试`*s != 0` 与测试`*s`是一样的，两者都在`*s`不为0时结果为真。这些发现引出strlen函数的又一个版本：

```c
size_t strlen(const char *s)
{
	size_t n=0;
	
	for(;*s;s++)
		n++;
	return n;
}
```

然而，就如同之前见到的那样，在同一个表达式中对s进行自增操作并且测试*s是可行的：

```c
size_t strlen(const char *s)
{
	size_t n=0;
	
	for(;*s++;)
		n++;
	return n;
}
```

用while语句替换for语句，可以得到如下版本的strlen函数：

```c
size_t strlen(const char *s)
{
	size_t n=0;
	
	while(*s++)
		n++;
	return n;
}
```

虽然前面已经对strlen函数进行了相当大的精简，但是可能仍没有提高它的运行速度。至少对于一些编译器来说下面的版本确实会运行得更快一些：

```c
size_t strlen(const char *s){
	const char *p = s;
	
	while(*s)
		s++;
	return s - p;
}
```

**这个版本的strlen函数通过定位空字符位置的方式来计算字符串的长度，然后用空字符的地址减去字符串中第一个字符的地址。运行速度的提升得益于不需要在while循环内部对n进行自增操作。请注意，在p的声明中出现了单词const，如果没有它，编译器会注意到把s赋值给p会给s指向的字符串造成一定危险。**



### 复制字符串

复制字符串是另一种常见操作。为了介绍C语言中的“字符串复制”惯用法，这里将开发strcat函数的两个版本。首先从直接但有些冗长的strcat函数写法开始：

```c
char *strcat(char *s1,const char *s2){
	char *p = s1;
	
	while(*p != '\0')
		p++;
	while(*s2 != '\0'){
		*p = *s2;
		p++;
		s2++;
	}
	*p = '\0';
	return s1;
}
```

strcat函数的这种写法采用了两步算法：1、确定字符串s1末尾空字符的位置，并且使指针p指向它。2、把字符串s2中的字符逐个复制到p所指向的位置。



函数中的第一个while语句实现了第1步。程序中先把p设定为指向s1的第一个字符。第二个while语句实现了第2步。循环体把s2指向的一个字符复制到p指向的地方，接着p和s2都进行自增。接下来，程序在p指向的位置放置空字符，然后strcat函数返回。



类似于对strlen函数的处理，也可以简化strcat函数的定义，得到下面的版本：

```c
char *strcat(char *s1,const char *s2){
	char *p = s1;
	
	while(*p){
		p++;
	}
	while(*p++ = *s2++)
		;
	return s1;
}
```

改进的strcat函数的核心是“字符串复制”的惯用法：

```c
[惯用法] while(*p++ = *s2++)
			;
```

如果忽略了两个++运算符，那么圆括号中的表达式会简化为普通的赋值：

```c
*p = *s2;
```

这个表达式把s2指向的字符复制到p所指向的地方。正是由于有了这两个++运算符，赋值之后p和s2才进行了自增。重复执行此表达式所产生的效果就是把s2指向的一系列字符复制到p所指向的地方。



**但是什么会使循环终止呢？由于圆括号中的主要运算符是赋值运算符，所以while语句会测试赋值表达式的值，也就是测试复制的字符。除空字符以外的所有字符的测试结果都为真，因此，循环只有在复制空字符后才会终止。而且由于循环是在赋值之后终止，所以不需要单独用一条语句来在新字符串的末尾添加空字符。**



## 字符串数组

现在来看一个在使用字符串时经常遇到的问题：存储字符串数组的最佳方式是什么？最明显的解决方案是创建二维的字符数组，然后按照每行一个字符串的方式把字符串存储到数组中。考虑下面的例子：

```c
char planets[][8] = {"Mercury","Venus","Earth",
					"Mars","Jupiter","Saturn","Uranus","Neptune","Pluto"}; 
```

**注意，虽然允许省略planets数组的行数（因为这个数很容易从初始化式中元素的数量求出），但是C语言要求指明列数。**



下面给出了planets数组的可能形式。并非所有的字符串都足以填满数组的一整行，所以C语言用空字符来填补。因为只有3个行星的名字需要用满8个字符（包括末尾的空字符），所以这样的数组有一点浪费空间。remind.c程序就是这种浪费的代表，它把提醒信息按行存储到二维字符数组中，且为每条提醒信息都分配了60个字符的空间。在示例中，提醒信息的长度在18个字符到37个字符之间，所以浪费的空间相当可观。

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | M    | e    | r    | c    | u    | r    | y    | \0   |
| 1    | V    | e    | n    | u    | s    | \0   | \0   | \0   |
| 2    | E    | a    | r    | t    | h    | \0   | \0   | \0   |
| 3    | M    | a    | r    | s    | \0   | \0   | \0   | \0   |
| 4    | J    | u    | p    | i    | t    | e    | r    | \0   |
| 5    | S    | a    | t    | u    | r    | n    | \0   | \0   |
| 6    | U    | r    | a    | n    | u    | s    | \0   | \0   |
| 7    | N    | e    | p    | t    | u    | n    | e    | \0   |
| 8    | P    | l    | u    | t    | o    | \0   | \0   | \0   |

**因为大部分字符串集都是长字符串和短字符串的混合，所以这些例子所暴露的低效性是在处理字符串时经常遇到的问题。我们需要的是参差不齐的数组（ragged array），即每一行有不同长度的二维数组。C语言本身不提供这种“参差不齐的数组类型”，但它提供了模拟这种数组类型的工具。秘诀就是建立一个特殊的数组，这个数组的元素都是指向字符串的指针。**



下面是planets数组的另外一种写法，这次把它看成是指向字符串的指针的数组：

```c
char *planets[] = {"Mercury","Venus","Earth",
					"Mars","Jupiter","Saturn",
					"Uranus","Neptune","Pluto"}; 
```

看上去改动不是很大，只是去掉了一对方括号，并且在planets前加了一个星号。但是，这对planets存储方式产生的影响却很大：

| planets |      |      |      |      |      |      |      |      |      |      |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0       | ——>  | M    | e    | r    | c    | u    | r    | y    | \0   |      |
| 1       | ——>  | V    | e    | n    | u    | s    | \0   |      |      |      |
| 2       | ——>  | E    | a    | r    | t    | h    | \0   |      |      |      |
| 3       | ——>  | M    | a    | r    | s    | \0   |      |      |      |      |
| 4       | ——>  | J    | u    | p    | i    | t    | e    | r    | \0   |      |
| 5       | ——>  | S    | a    | t    | u    | r    | n    | \0   |      |      |
| 6       | ——>  | U    | r    | a    | n    | u    | s    | \0   |      |      |
| 7       | ——>  | N    | e    | p    | t    | u    | n    | e    | \0   |      |
| 8       | ——>  |      | P    | l    | u    | t    | o    | \0   |      |      |

**planets的每一个元素都是指向以空字符串结尾的字符串的指针。虽然必须为planets数组中的指针分配空间，但是字符串中不再有任何浪费的字符。**



为了访问其中一个行星名字，只需要对planets数组取下标。由于指针和数组之间的紧密关系，访问行星名字中的字符的方式和访问二维数组元素的方式相同。例如，为了在planets数组中搜寻以字母M开头的字符串，可以使用下面的循环：

```c
for(i=0;i<9;i++)
	if(planets[i][0] == 'M')
		printf("%s begins with M\n",planets[i]);
```

