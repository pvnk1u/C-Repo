# 字符串

前几章虽然使用过char类型变量和char类型数组，但是始终没有谈到处理字符序列（术语是字符串）的便捷方法。本章将会补上，并将介绍字符串常量（C标准中称为字符串字面量）和字符串变量。其中，字符串变量可以在程序运行过程中发送改变。



## 字符串字面量

字符串字面量是用一对双引号括起来的字符序列：

```
"When you come to a fork in the road, take it."
```

之前例子中的字符串字面量常常作为格式串出现在printf函数和scanf函数的调用中。



### 字符串字面量中的转义序列

字符串字面量可以像字符常量一样包含转义序列。在printf函数和scanf函数的格式串中已经使用过转义字符。例如，字符串

```
"Candy\nIs dandy\nBut liquor\nIs quicker.\n --Ogden Nash\n"
```

中的每一个字符`\n`都会导致光标移到下一行。



字符串字面量中的八进制数和十六进制数的转义序列也都是合法的，但是它们不像字符转义序列那样常见。



### 如何存储字符串字面量

我们经常在printf函数调用和scanf函数调用中用到字符串字面量。但是，当调用printf函数并且用字符串字面量作为参数时，究竟传递了什么呢？为了回答这个问题，需要明白字符串字面量是如何存储的。



**从本质而言，C语言把字符串字面量作为字符数组来处理。当C语言编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。这块内存空间将用来存储字符串字面量中的字符，以及一个用来标志字符串末尾的额外字符（空字符）。空字符是一个所有位都为0的字节，因此用转义序列`\0`来表示。**



不要混淆空字符（'\0'）和零字符（'0'）。空字符的码值为0，而零字符则有不同的码值（ASCII中为48）。



例如，字符串字面量“abc”是作为有4个字符的数组来存储的（a、b、c和\0）：

| a    | b    | c    | \0   |
| ---- | ---- | ---- | ---- |



字符串字面量可以为空。字符串“”作为单独一个空字符来存储：`\0`。



既然字符串字面量是作为数组来存储的，那么编译器会把它看作是`char *`类型的指针。例如，printf函数和scanf函数都接收`char *`类型的值作为它们的第一个参数。思考下面的例子：

```c
printf("abc");
```

当调用printf函数时，会传递“abc”的地址（即指向存储字母a的内存单元的指针）。



### 字符串字面量的操作

通常情况下可以在任何C语言允许使用`char *`指针的地方使用字符串字面量。例如，字符串字面量可以出现在赋值运算符的右边：

```c
char *p;

p = "abc";
```

**这个赋值操作不是复制“abc”中的字符，而是使p指向字符串的第一个字符。**



C语言允许对指针取下标，因此可以对字符串字面量取下标：

```c
char ch;

ch = "abc"[1];
```

ch的新值将是字母b。其他可能的下标是0（字母a）、2（字母c）和3（空字符）。字符串字面量的这种特性并不常用，但有时也比较方便。思考下面的函数，这个函数把0~15的数转换成等价的十六进制的字符形式：

```c
char digit_to_hex_char(int digit)
{
	return "0123456789ABCDEF"[digit];
}
```

试图改变字符串字面量会导致未定义的行为：

```c
char *p = "abc";

*p= 'd';  // WRONG
```



### 字符串字面量与字符常量

只包含一个字符的字符串字面量不同于字符常量。字符串字面量“a”是用指针来表示的，这个指针指向存放字符`“a”`（后面紧跟空字符）的内存单元。字符常量`‘a’`是用整数（字符集的数值码）来表示的。



不要在需要字符串的时候使用字符（反之亦然）。函数调用：

```c
printf("\n");
```

是合法的，因为printf函数期望指针作为它的第一个参数。然而，下面的调用却是非法的：

```c
printf('\n');		// WRONG
```





## 字符串变量

一些编程语言为声明字符串变量提供了专门的string类型。C语言采取了不同的方式：只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。这种方法很简单，但使用起来有很大难度。有时很难辨别是否把字符数组作为字符串来使用。如果编写自己的字符串处理函数，请千万注意要正确地处理空字符。而且，要确定字符串长度没有比逐个字符地搜索空字符更快捷的方法了。



假设需要用一个变量来存储最多有80个字符的字符串。由于字符串在末尾处需要有空字符，我们把变量声明为含有81个字符的数组：

```c
#define STR_LEN 80
...
char str[STR_LEN+1];
```

这里把STR_LEN定义为80而不是81，强调的是str可以存储最多有80个字符的字符串；然后才在str的声明中对STR_LEN加1。这是C程序员常用的方式。



当声明用于存放字符串的字符数组时，要始终保证数组的长度比字符串的长度多一个字符。这是因为C语言规定每个字符串都要以空字符结尾。如果没有给空字符预留位置，可能会导致程序运行时出现不可预知的结果，因为C函数库中的函数假设字符串都是以空字符结尾的。



声明长度为STR_LEN+1的字符数组并不意味着它总是用于存放长度为STR_LEN的字符串。字符串的长度取决于空字符的位置，而不是取决于用于存放字符串的字符数组的长度。有STR_LEN+1个字符的数组可以存放多种长度的字符串，范围是从空字符串到STR_LEN的字符串。



### 初始化字符串变量

字符串变量可以在声明时进行初始化：

```c
char date1[8] = "June 14";
```

编译器将把字符串“June 14”中的字符复制到数组date1中，然后追加一个空字符从而使date1可以用作字符串使用。date1将如下所示：

| J    | u    | n    | e    |      | 1    | 4    | \0   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

"June 14"看起来是字符串字面量，但其实不然。C编译器会把它看成是数组初始化式的缩写形式。实际上，我们可以写成：

```c
char date1[8] = {'J','u','n','e',' ','1','4','\0'};
```

明显是原来的形式更便于阅读。



如果初始化式太短以至于不能填满字符串变量将会如何呢？在这种情况下，编译器会添加空字符。因此，在声明

```c
char date2[9] = "June 14";
```

之后，date2将如下所示：

| J    | u    | n    | e    |      | 1    | 4    | \0   | \0   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

大体上来说，这种行为与C语言处理数组初始化式的方法一致。当数组的初始化式比数组本身短时，余下的数组元素会被初始化为0。





如果初始化式比字符串变量长又会怎样呢？这对字符串而言是非法的，就如同对数组是非法的一样。然而，C语言允许初始化式（不包括空字符）与变量有完全相同的长度：

```c
char date3[7] = "June 14";
```

**由于没有给空字符留空间，所以编译器不会试图存储空字符。**



**如果正在计划对用来放置字符串的字符数组进行初始化，一定要确保数组的长度要长于初始化式的长度，否则，编译器将忽略空字符，这将使得数组无法作为字符串使用。**



字符串变量的声明中可以省略它的长度。这种情况下，编译器会自动计算长度：

```c
char date4[] = "June 14";
```



编译器为date4分配8个字符的空间，这足够存储“June 14”中的字符和一个空字符（**不指定date4的长度并不意味着以后可以改变数组的长度。一旦编译了程序，date4的长度就固定是8了。**）如果初始化式很长，那么省略字符串变量的长度是特别有效的，因为手工计算长度很容易出错。



### 字符数组和字符指针

比较一下下面这两个看起来很相似的声明：

```c
char date[] = "June 14";
char *date = "June 14";
```

**前者声明date是一个数组，后者声明date是一个指针。正因为有了数组和指针之间的紧密关系，才使上面这两个声明中的date都可以用作字符串。尤其是，任何期望传递字符数组或字符指针的函数都能够接收这两种声明的date作为参数。**



**然而，需要注意，不能错误地认为上面这两种date可以互换。两者之间存在很大的差异：**

- **在声明为数组时，就像任意数组元素一样，可以修改存储在date中的字符。在声明为指针时，date指向字符串字面量，前面已经看到字符串字面量是不可以修改的。**
- **在声明为数组时，date是数组名。在声明为指针时，date是变量，这个变量可以在程序执行期间指向其他字符串。**



如果希望可以修改字符串，那么就要建立字符数组来存储字符串，声明指针变量就不够的。下面的声明使编译器为指针变量分配了足够的内存空间：

```c
char *p;
```

可惜的是，它不能为字符串分配空间。（因为我们没有指明字符串的长度。）在使用p作为字符串之前，必须把p指向字符数组。一种可能是把p指向已经存在的字符串变量：

```c
char str[STR_LEN+1],*p;

p = str;
```

现在p指向了str的第一个字符，所以可以把p作为字符串使用了。另一种可能是让p指向一个动态分配的字符串（见17章——动态分配字符串）。



使用未初始化的指针变量作为字符串是非常严重的错误。考虑下面的例子，它试图创建字符串“abc”：

```c
char *p;

p[0]='a';	/* WRONG */
```

因为p没有被初始化，所以我们不知道它指向哪里。用指针p把字符a写入内存会导致未定义的行为。



## 字符串的读和写

使用printf函数或puts函数来写字符串是很容易的。读字符串却有点麻烦，主要是因为输入的字符串可能比用来存储它的字符串变量长。为了一次性读入字符串，可以使用scanf函数或gets函数，也可以每次读入一个字符。



### 用printf函数和puts函数写字符串

转换说明%s允许printf函数写字符串。考虑下面的例子：

```c
char str[] = "Are we having fun yet?";

printf("%s\n",str);
```

输出会是：

```
Are we having fun yet?
```

printf函数会逐个写字符串中的字符，直到遇到空字符才停止。（如果空字符丢失，printf函数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止。）



如果只想显示字符串的一部分，可以使用转换说明`%.ps`，这里p是要显示的字符数量。语句

```c
printf("%.6s\n",str);
```

会显示

```
Are we
```

字符串跟数一样，可以在指定字段内显示。转换说明%ms会在大小为m的字段内显示字符串。（对于超过m个字符的字符串，printf函数会显示出整个字符串，而不会截断。）如果字符串少于m个字符，则会在字段内向右对其输出。如果要强制左对齐，可以在m前加一个减号。m值和p值可以组合使用：转换说明%m.ps会使字符串的前p个字符在大小为m的字段内显示。



printf函数不是唯一一个字符串输出函数。C函数库还提供了puts函数，此函数可以按如下方式使用：

```c
puts(str);
```

puts函数只有一个参数，即需要显示的字符串。在写完字符串后，puts函数总会添加一个额外的换行符，从而前进到下一个输出行的开始处。



### 用scanf函数和gets函数读字符串

转换说明%s允许scanf函数把字符串读入字符数组：

```c
scanf("%s",str);
```

**在scanf函数调用中，不需要在str前添加运算符&，因为str是数组名，编译器在把它传递给函数时会把它当作指针来处理。**



**调用时，scanf函数会跳过空白字符（3.2节），然后读入字符并存储到str中，直到遇到空白字符为止。scanf函数始终会在字符串末尾存储一个空字符。**



**用scanf函数读入字符串永远不会包含空白字符。因此，scanf函数通常不会读入一整行输入。换行符会使scanf函数停止读入，空格符或制表符也会产生同样的结果。为了一次读入一整行输入，可以使用gets函数。类似于scanf函数，gets函数把读入的字符放到数组中，然后存储一个空字符。然而，在其他方面gets函数有些不同于scanf函数。**

- **gets函数不会在开始读字符串之前跳过空白字符（scanf函数会跳过）。**
- **gets函数会持续读入直到找到换行符才停止（scanf函数会在任意空白字符处停止）。此外，gets函数会忽略掉换行符，不会把它存储到数组中，用空字符代替换行符。**



为了领会scanf函数与gets函数之间的差异，考虑下面的程序段：

```c
char sentence[SENT_LEN+1];

printf("Enter a sentence: \n");
scanf("%s",sentence);
```

假定用户输入信息：

```
To C, or not to C: that is the question.
```

scanf函数会把字符处“To”存储到sentence中。下一次scanf函数调用将从单词To后面的空格处继续读入这行。



现在假设用gets函数替换scanf函数：

```c
gets(sentence);
```

当用户输入和先前相同的信息时，gets函数会把字符处

```
" To C, or not to C: that is the question."
```

存储到sentence中。



**注意：在把字符读入数组时，scanf函数和gets函数都无法检测数组何时被填满。因此，它们存储字符时可能越过数组的边界，这会导致未定义的行为。通过用转换说明%ns代替%s可以使scanf函数更安全。这里的数字n指出可以存储的最多字符数。可惜的是，gets函数天生就是不安全的，fgets函数则是一种好得多的选择。**



### 逐个字符读取字符串

因为对许多程序而言，scanf函数和gets函数都有风险且不够灵活，C程序员经常会自己编写输入函数。通过每次一个字符的方式来读入字符处，这类函数可以提供比标准输入函数更大程度的控制。



如果决定设计自己的输入函数，那么就需要考虑下面的这些问题。

- 在开始存储字符串之前，函数应该跳过空白字符吗？
- 什么字符会导致函数停止读取：换行符、任意空白字符还是其他某种字符？需要存储这类字符还是忽略掉？
- 如果输入的字符串太长以致无法存储，那么函数应该做些什么：忽略额外的字符还是把它们留给下一次输入操作？



假定我们所需要的函数不会跳过空白字符，在第一个换行符（不存储到字符串中）处停止读取，并且忽略额外的字符。函数将有如下原型：

```c
int read_line(char str[],int n);
```

str表示用来存储输入的数组，而n是读入字符的最大数量。如果输入行包含多余n个的字符，read_line函数将忽略多余的字符。read_line函数会返回实际存储在str中的字符数量（0到n之间的任意数）。我们不可能总是需要read_line的返回值，但是有这个返回值也没问题。



read_line函数主要由一个循环构成。只要str中还有空间，此循环就会调用getchar函数逐个读入字符并把它们存储到str中。在读入换行符时循环终止。（严格地说，如果getchar函数读入字符失败，也应该终止循环，但是这里暂时忽略这种复杂情况。）下面是read_line函数的完整定义：

```c
int read_line(char str[],int n)
{
	int ch,i=0;
	
	while((ch=getchar()) != '\n'){
		if(i < n)
			str[i++] = ch;
	}
	str[i]='\0';		// 终止符0
	return i;			// 已存储的字符数量
}
```

注意，ch的类型是int而不是char，这是因为getchar把它读取的字符作为int类型的值返回。



返回之前，read_line函数在字符串的末尾放置一个空字符。scanf函数和gets函数等标准函数会自动在输入字符串的末尾放置一个空字符；然而，如果要自己写输入函数，必须手工加上空字符。



## 访问字符串中的字符

字符串是以数组的形式存储的，因此可以使用下标来访问字符串中的字符。例如，为了对字符串s中的每个字符进行处理，可以设定一个循环来对计数器i进行自增操作，并通过表达式s[i]来选择字符。



假定需要一个函数来统计字符串中空格的数量。利用数组取下标操作可以写出如下函数：

```c
int count_spaces(const char s[]){
	int count = 0,i;
	
	for(i = 0;s[i] != '\0',i++)
		if(s[i] == ' ')
			count++;
	return count;
}
```

在s的声明中加上const表明count_spaces函数不会改变数组。**如果s不是字符串，count_spaces将需要第2个参数来指明数组的长度。然而，因为s是字符串，所以count_spaces可以通过测试空字符来定位s的末尾。**



许多C程序员不会像例子中编写count_spaces函数，他们更愿意使用指针来跟踪字符串中的当前位置。就像前面看到的那样，这种方法对于处理数组来说一直有效，但在处理字符串方面尤其方便。



下面用指针算术代替数组取下标来重新编写count_spaces函数。这次不再需要变量i，而是利用s自身来跟踪字符串中的位置。通过对s反复进行自增操作，count_spaces函数可以逐个访问字符串中的字符。下面是count_spaces函数的新版本：

```c
int count_spaces(const char *s){
	int count = 0;
	
	for(;*s != '\0';s++)
		if(*s == ' ')
			count++;
	return count;
}
```

注意，const没有阻止count_spaces函数对s的修改，它的作用是阻止函数改变s所指向的字符。**而且，因为s是传递给count_spaces函数的指针的副本，所以对s进行自增操作不会影响原始的指针。**



count_spaces函数示例引出了一些如何编写字符串函数的问题。

- **用数组操作或指针操作访问字符串中的字符，哪种方法更好一些呢？**只要使用方便，可以随意使用任意一种方法，甚至可以混合使用两者方法。在count_spaces函数的第2种写法中，不再需要变量i，而是把s作为指针来对函数进行一些简化。从传统意义上来说，C程序员更倾向于使用指针操作来处理字符串。
- **字符串形式参数应该声明为数组还是指针呢？**count_spaces函数的两种写法说明了这两种选择：第1种写法把s声明为数组，而第二种写法则把s声明为指针。实际上，这两种声明之间没有任何差异。回顾之前的内容就知道，编译器会把数组型的形式参数视为指针。
- **形式参数的形式（s[]或者*s）是否会对实际参数产生影响呢？**不会的。当调用count_spaces函数时，实际参数可以是数组名、指针变量或者字符串字面量。count_spaces函数无法说明差异。



## 使用C语言的字符串库

**一些编程语言提供的运算符可以对字符串进行复制、比较、拼接、选择子串等操作，但C语言的运算符根本无法操作字符串。在C语言中把字符串当作数组来处理，因此对字符串的限制方式和对数组的一样，特别是，它们都不能用C语言的运算符进行复制和比较操作。**



直接复制或比较字符串会失败。例如，假定str1和str2有如下声明：

```c
char str1[10],str2[10];
```

利用=运算符来把字符串复制到字符数组中是不可能的：

```c
str1 = "abc";		// WRONG
str2 = str1;		// WRONG
```

从12.3节可知，**把数组名用作=的左操作数是非法的。但是，使用=初始化字符数组是合法的：**

```c
char str1[10] = "abc";
```

这是因为**在声明中，=不是赋值运算符。**



试图使用关系运算符或判等运算符来比较字符串是合法的，但不会产生预期的结果：

```c
if(str1 == str2)...		// WRONG
```

**这条语句把str1和str2作为指针来进行比较，而不是比较两个数组的内容。因为str1和str2有不同的地址，所以表达式str1 == str2的值一定为0。**





幸运的是，字符串的所有操作功能都没有丢失：C语言的函数库为完成对字符串的操作提供了丰富的函数集。这些函数的原型驻留在`<string.h>`头中，所以需要字符串操作的程序应该包含下列内容：

```c
#include <string.h>
```

在`<string.h>`中声明的每个函数至少需要一个字符串作为实际参数。字符串形式参数声明为`char *`类型，这使得实际参数可以是字符数组、`char *`类型的变量或者字符串字面量——上述这些都适合作为字符串。然而，要注意那些没有声明为const的字符串形式参数。这些形式参数可能会在调用函数时发生改变，所以对应的实际参数不应该是字符串字面量。



`<string.h>`中有许多函数，这里介绍几种最基本的。在后续的例子中，假设str1和str2都是用字符串的字符数组。



### strcpy函数

strcpy（字符串）复制函数在`<string.h>`中的原型如下：

```c
char *strcpy(char *s1,const char *s2);
```

strcpy函数把字符串s2复制给字符串s1。（准确地讲，应该说成是“strcpy函数把s2指向的字符串复制到s1指向的数组中”。）也就是说，strcpy函数把s2中的字符复制到s1中直到遇到s2中的第一个空字符为止（该空字符也需要复制）。strcpy函数返回s1（即指向目标字符串的指针）。这一过程不会改变s2指向的字符串，因此将其声明为const。



strcpy函数的存在弥补了不能使用赋值运算符复制字符串的不足。例如，假设我们想把字符串“abcd”存储到str2中，不能使用下面的赋值：

```c
str2 = "abcd";		// WRONG
```

这是因为str2是数组名，不能出现在赋值运算的左侧。但是，这时可以调用strcpy函数：

```c
strcpy(str2,"abcd");		// str1 now contains "abcd"
```

类似地，不能直接把str2赋值给str1，但是可以调用strcpy：

```c
strcpy(str1,str2);			// str1 now contains "abcd"
```

**大多数情况下我们会忽略strcpy函数的返回值，但有时候strcpy函数调用是一个更大的表达式的一部分，这时其返回值就比较有用了。例如，可以把一系列strcpy函数调用连起来：**

```c
strcpy(str1,str(str2,"abcd"));
/* both str1 and str2 now contain "abcd" */
```



**在strcpy(str1,str2)的调用中，strcpy函数无法检查str2指向的字符串的大小是否真的适合str1指向的数组。假设str1指向的字符串长度为n，如果str2指向的字符串中的字符数不超过n-1，那么复制操作就可以完成。但是，如果str2指向更长的字符串，那么结果就无法预料了。（因为strcpy函数会一直复制到第一个空字符为止，所以它会越过str1指向的数组的边界继续复制。）**



**尽管执行会慢一点，但是调用strccpy函数仍是一种更安全的复制字符串的方法。strncpy类似于strcpy，但它还有第三个参数可以用于限制所复制的字符数。为了将str2复制到str1，可以使用如下的strncpy调用：**

```c
strncpy(str1,str2,sizeof(str1));
```



**只要str1足够装下存储在str2中的字符串（包括空字符），复制就能正确完成。当然，strncpy本身也不是没有风险。如果str2中存储的字符串的长度大于str1数组的长度，strncpy会导致str1中的字符串没有终止的空字符。下面是一种更安全的用法：**

```c
strncpy(str1,str2,sizeof(str1)-1);	// char占一个字节，因此sizeof计算结果正好是数组中的元素个数
str1[sizeof(str1)-1]= '\0';
```

第二条语句确保str1总是以空字符结束，即使strncpy没能从str2中复制到空字符。



### strlen函数

strlen(求字符串长度)函数的原型如下：

```c
size_t strlen(const char *s);
```

定义在C函数库中的size_t是一个typedef名字，表示C语言中的一种无符号整型。除非是处理极长的字符串，否则不需要关心其技术细节。可以简单地把strlen的返回值作为整数处理。



strlen函数返回字符串s的长度：**s中第一个空字符之前的字符个数（不包括空字符）。**下面是几个示例：

```c
int len;

len = strlen("abc");		// len is now 3
len = strlen("");			// len is now 0
strcpy(str1,"abc");			
len = strlen(str1);			// len is now 3
```

最后一个例子说明了很重要的一点：**当用数组作为实际参数时，strlen不会测量数组本身的（最大）长度，而是返回存储在数组中的字符串的长度。**



### strcat函数

strcat（字符串拼接）函数的原型如下：

```c
char *strcat(char *s1,const char *s2);
```

strcat函数把字符串s2的内容追加到字符串s1的末尾，并且返回字符串s1（指向结果字符串的指针）。



下面列举了一些使用strcat函数的例子：

```c
strcpy(str1,"abc");
strcat(str1,"def");			// str1 now contains "abcdef"
strcpy(str1,"abc");			
strcpy(str2,"def");
strcat(str1,str2);			// str1 now contains "abcdef"
```

同使用strcpy函数一样，通常忽略strcat函数的返回值。下面的例子说明了可能使用返回值的方法：

```c
strcpy(str1,"abc");
strcpy(str2,"def");
strcat(str1,strcat(str2,"ghi"));
	/* str1 now contains "abcdefghi"; str2 contains "defghi" */
```



如果str1指向的数组没有大到足以容纳str2指向的字符串中的字符，那么调用strcat(str1,str2)的结果将是不可预测的。考虑下面的例子：

```c
char str1[6] = "abc";
strcat(str1,"def");		// WRONG
```

strcat函数会试图把字符d、e、f和`\0`添加到str1中已存储的字符串的末尾。不幸的是，str1仅限于6个字符，这导致strcat函数写到了数组末尾的后面。



**strncat函数比strcat更安全，但速度也慢一些。与strncpy一样，它有第三个参数来限制所复制的字符数。**下面是调用的形式：

```c
strncat(str1,str2,sizeof(str1)- strlen(str1)-1);
```

strncat函数会在遇到空字符时终止str1，第三个参数（待复制的字符数）没有考虑该空字符。在上面的例子中，第三个参数计算str1中的剩余空间（由表达式`sizeof(str1)-strlen(str1)`给出，`sizeof(str1)`计算出整个char数组可存储的字符个数，`strlen(str1)`计算出该char数组目前已使用的字符数)，然后减去1以确保为空字符留下空间。



### strcmp函数

strcmp(字符串比较)函数的原型如下：

```c
int strcmp(const char *s1,const char *s2);
```



