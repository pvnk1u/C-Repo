# 编写大型程序

虽然某些C程序小得足够放入一个单独的文件中，但大多数程序都不是这样的。程序由多个文件构成的原则更容易让人接受。本章将会看到，常见的程序由多个源文件组成，通常还有一些头文件（header file）。**源文件包含函数的定义和外部变量，而头文件包含可以在源文件之间共享的信息。**



## 源文件

到现在为止一直假设C程序是由单独一个文件组成的。事实上，可以把程序分割成任意数量的源文件。根据惯例，源文件的扩展名为`.c`。每个源文件包含程序的部分内容，主要是函数和变量的定义。其中一个源文件必须包含一个名为`main`的函数，此函数作为程序的起始点。



把程序分割成多个源文件有许多显著的优点。

- 把相关的函数和变量分组放在同一个文件中可以使程序的结构清晰。
- 可以分别对每一个源文件进行编译。如果程序规模很大而且需要频繁改变（这一点在程序开发过程中是很普遍的）的话，这种方法可以极大地节约时间。
- 把函数分组放在不同的源文件中更易于复用。



## 头文件

当把程序分割为几个源文件时，问题也随之产生了：某文件中的函数如果调用定义在其他文件中的函数呢？函数如何访问其他文件中的外部变量呢？两个文件如何共享同一个宏定义或类型定义呢？答案是`#include`指令，此指令使得在任意数量的源文件中共享信息成为可能，这些信息可以是函数原型、宏定义、类型定义等。



`#include`指令告诉预处理器打开指定的文件，并且把此文件中的内容插入到当前文件中。因此，如果想让几个源文件可以访问相同的信息，可以把此信息放入一个文件中，然后利用`#include`指令把该文件的内容带进每个源文件中。把按照此种方式包含的文件称为头文件（有时称为包含文件）。根据惯例，头文件的扩展名为`.h`。



### #include指令

`#include`指令主要有两种书写格式。第一种格式用于属于C语言自身库的头文件：

```c
[#include指令 (格式1)]  #include<文件名>
```

第二种格式用于所有其他头文件，也包含任何自己编写的文件：

```c
[#include指令 (格式2)] #include "文件名"
```

这两种格式间的细微差异在于编译器定位头文件的方式。下面是大多数编译器遵循的规则。

- #include <文件名>

  搜寻系统头文件所在的目录（或多个目录）。（例如，在UNIX系统中，通常把系统头文件保存在目录/usr/include中。）

- #include "文件名"

  先搜寻当前目录，然后搜寻系统头文件所在的目录（或多个目录）。



### 共享宏定义和类型定义

大多数大型程序包含需要由几个源文件（或者，最极端的情况是用于全部源文件）共享的宏定义和类型定义。这些定义应该放在头文件中。



例如，假设正在编写的程序使用名为`BOOL`、`TRUE`和`FALSE`的宏。（C99中不需要这么做，因为<stdbool.h>头中定义了类似的宏。）我们把这些定义放在一个名为`boolean.h`的头文件中，这样做比在每个需要的源文件中重复定义这些宏更有意义：

```c
#define BOOL int
#define TRUE 1
#define FALSE 0
```

任何需要这些宏的源文件只需要包含下面这一行：

```c
#include "boolean.h"
```

类型定义在头文件中也是很普遍的。例如，不用定义BOOL宏，而是可以用typedef创建一个Bool类型。如果这样做，`boolean.h`文件将有下列显示：

```c
#define TRUE 1
#define FALSE 0
typedef int Bool;
```

把宏定义和类型定义放在头文件中有许多明显的好处。首先，不把定义复制到需要它们的源文件中可以节约时间。其次，程序变得更加容易修改。改变宏定义或类型定义只需要编辑单独的头文件，而不需要修改使用宏或类型的诸多源文件。最后，不需要担心由于源文件中包含相同宏或类型的不同定义而导致的矛盾。



### 共享函数原型

**假设源文件中包含函数f的调用，而函数f是定义在另一个文件`foo.c`中的。调用没有声明的函数f是非常危险的。如果没有函数原型可依赖，编译器会假定函数f的返回类型是int类型的，并假定形式参数的数量和函数f的调用中的实际参数的数量是匹配的。通过默认的实际参数提升，实际参数自身自动转化为“标准格式”。编译器的假定很可能是错误的，但是，因为一次只能编译一个文件，所以是没有办法进行检查的。如果这些假定是错误的，那么程序很可能无法工作，而且没有线索可以用来查找原因。（基于这个原因，C99禁止在编译器看到函数声明或定义之前对函数进行调用。）**



我们的第一个想法是在调用函数f的文件中声明它。这样可以解决问题，但是如果有多个源文件要调用函数f，如何能确保函数f的原型在所有文件中都一样呢？



解决方法是显而易见的：把函数f的原型放进一个头文件中，然后在所有调用函数f的地方包含这个头文件。既然在文件`foo.c`中定义了函数f，把头文件命名为`foo.h`。除了在调用函数f的源文件中包含`foo.h`，还需要在`foo.c`中包含它，从而使编译器可以验证`foo.h`中函数f的原型和`foo.c`中f的函数定义相匹配。仅用于文件`foo.c`内部而不会被其他源文件调用的函数不需要在头文件中声明。



### 共享变量声明

外部变量在文件中共享的方式与函数的共享很类似。为了共享函数，要把函数的定义放在一个源文件中，然后在需要调用此函数的其他文件中放置声明。共享外部变量的方法与此方式非常类似。



目前不需要区别变量的声明和它的定义。为了声明变量i，可以这样写：

```c
int i;		/* declares i and define it as well */
```

这样不仅声明i是int类型的变量，而且也对i进行了定义，从而使编译器为i留出了空间。为了声明变量i而不是定义它，需要在变量声明的开始处放置extern关键字：

```c
extern int i;	/* desclres i without defining it */
```

extern告诉编译器，变量i是在程序中的其他位置定义的（很可能是在不同的源文件中），因此不需要为i分配空间。



相似的，extern可以用于所有类型的变量。在数组的声明中使用extern时，可以省略数组的长度：

```c
extern int a[];
```

因为此刻编译器不用为数组a分配空间，所以也就不需要知道数组的长度了。



**为了在几个源文件中共享变量i，首先把变量i的定义放置在其中的一个文件中：**

```c
int i;
```

**如果需要对变量i初始化，可以把初始化式放在这里。在编译这个文件时，编译器会为变量i分配内存空间，而其他文件只需要包含变量i的声明（而不是定义）即可：**

```c
extern int i;
```



**通过在每个文件中声明变量i，使得在这些文件中可以访问/或修改变量i。然而，由于关键字extern的存在，编译器不会在每次编译这些文件时为变量i分配额外的内存空间。**



注意：当同一个变量的声明出现在不同文件中时，编译器无法检查声明是否和变量定义相匹配。例如，一个文件可以包含定义：

```c
int i;
```

同时另一个文件包含声明：

```c
extern long i;
```

这类错误可能导致程序的行为异常。**为了避免这种情况，通常会把共享变量的声明放置在头文件中。需要访问特定变量的源文件可以包含相应的头文件。此外，含有变量定义的源文件需要包含含有相应变量声明的头文件，这样编译器就可以检查声明与定义是否匹配。**



虽然在文件中共享变量是C语言界中的长期惯例，但是它有重大的缺点。在第19章中将会看到存在的问题，并且学习如何设计不需要共享变量的程序。



### 嵌套包含

头文件自身也可以包含`#include`指令。虽然这种做法可能看上去有点奇怪，但实际上却是十分有用的。思考含有下列原型的头文件：

```c
int is_empty(void);
int is_full(void);
```

由于这些函数只能返回0或1，那么声明它们的返回类型是Bool类型而不是int类型是一个很好的主意：

```c
Bool is_empty(void);
Bool is_full(void);
```

当然，这样就需要在这个头文件中包含文件`boolean.h`以便在编译这个头文件时可以使用`Bool`的定义。（在C99中应包含`<stdbool.h>`而不是`boolean.h`，并把这两个函数的返回类型声明为`bool`而不是`Bool`。）



### 保护头文件

**如果源文件包含同一个头文件两次，那么可能产生编译错误。当头文件包含其他头文件时，这种问题十分普遍。例如，假设`file1.h`包含`file3.h`，`file2.h`包含`file3.h`，而`prog.c`同时包含`file1.h`和`file2.h`，那么在编译`prog.c`时，`file3.h`就会被编译两次。**



两次包含同一个头文件不总是会导致编译错误。如果文件只包含宏定义、函数原型和/或变量声明，那么将不会有任何困难。然而，如果文件包含类型定义，则会带来编译错误。



安全起见，保护全部头文件避免多次包含可能是个好主意，那样的话可以在稍候添加类型定义而不用冒可能因忘记保护文件而产生的风险。此外，在程序开发期间，避免同一个头文件的不必要重复编译可以节省一些时间。



为了防止头文件多次包含，用`#ifndef`和`#endif`指令来封闭文件的内容。例如，可以用如下方式保护文件`boolean.h`：

```c
#ifndef BOOLEAN_H
#define BOOLEAN_H

#define TRUE 1
#define FALSE 0
typedef int Bool;

#endif
```

在首次包含这个文件时，没有定义宏`BOOLEAN_H`，所以预处理器允许保留`#ifndef`和`#endif`之间的多行内容。但是如果再次包含此文件，那么预处理器将把`#ifndef`和`#endif`之间的多行内容删除。



宏的名字（`BOOLEAN_H`）并不重要，但是，给它取类似于头文件名的名字是避免和其他的宏冲突的好方法。由于不能把宏命名为`BOOLEAN_H`（标识符不能含有句点），所以像`BOOLEAN_H`这样的名字是个很好的选择。



### 头文件中的#error指令

`#error`指令经常放置在头文件中，用来检查不应该包含头文件的条件。例如，如果头文件中用到了一个最初的C89标准之前不存在的特性，为了避免把头文件用于旧的非标准编译器，可以在头文件中包含`#ifndef`指令来检查`__STDC__`宏是否存在：

```c
#ifndef __STDC__
#error This header requires a Standard C compiler
#endif
```



## 把程序划分成多个文件

