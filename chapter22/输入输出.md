# 输入/输出

C语言的输入/输出库是标准库中最大且最重要的部分。由于输入/输出是C语言的高级应用，因此将用一整章来讨论`<stdio.h>`头——输入/输出函数存放的主要地方。



从第二章开始已经在使用`<stdio.h>`了，而且已经对printf函数、scanf函数、putchar函数、getchar函数、puts函数以及gets函数的使用有了一定的了解。本章会涉及更多有关这6个函数的信息，并介绍一些新的用于文件处理的函数。值得高兴的是，许多新函数和已经熟知的函数有着紧密的关系。例如，fprintf函数就是printf函数的“文件版”。



本章的开始会讨论一些基本问题：流的概念、FILE类型、输入和输出重定向以及文本文件和二进制文件的差异（22.1节）。随后将转入讨论特别为使用文件而设计的函数，包括打开和关闭文件的函数（22.2节）。在讨论完printf函数、scanf函数以及与“格式化”输入/输出相关的函数（22.3节）以后，将着眼于读/写非格式化数据的函数。

- 每次读写一个字符的getc函数、putc函数以及相关的函数（22.4节）
- 每次读写一行字符的gets函数、puts函数以及相关的函数（22.5节）
- 读/写数据块的fread函数和fwrite函数（22.6节）



随后，22.7节会说明如何对文件上执行随机的访问操作。最后，22.8节会描述sprintf函数、snprintf函数和sscanf函数，它们是printf函数和scanf函数的变体，后两者分别用于写入和读取一个字符串。



本章涵盖了`<stdio.h>`中的绝大部分函数，但忽略了其中8个函数。perror函数是这8个函数中的一个，它与`<errno.h>`紧密相关，所以推迟到24.2节讨论`<errno.h>`头时进行介绍。26.1节涵盖了其中7个函数（vfprintf、vprintf、vsprintf、vsnprintf、vfscanf、vscanf和vsscanf）。这些函数依赖于va_list类型，该类型在26.1节介绍。



在C89中，所有的标准输入/输出函数都属于`<stdio.h>`。但C99有所不同，有些输入/输出函数在`<wchar.h>`头（25.5节）中声明。`<wchar.h>`中的函数用于处理宽字符而不是普通字符，但大多数函数与`<stdio.h>`中的函数紧密相关。`<stdio.h>`中用于读或写数据的函数称为字节输入/输出函数，而`<wchar.h>`中的类似函数则称为宽字符输入/输出函数。



## 流

在C语言中，术语流（stream）表示任意输入的源或任意输出的目的地。许多小型程序（就像前面章节中的那些）都是通过一个流（通常和键盘相关）获得全部的输入，并且通过另一个流（通常和屏幕相关）写出全部的输出。



较大规模的程序可能会需要额外的流。这些流常常表示存储在不同介质（如硬盘驱动器、CD、DVD和闪存）上的文件，但也很容易和不存储文件的设备（网络端口、打印机等）相关联。这里将集中讨论文件因为它们常见且容易理解（在应该说流的时候，有时会使用术语文件）。但是一定要记住，`<stdio.h>`中的许多函数可以处理各种形式的流，而不仅仅可以处理表示文件的流。



### 文件指针

C程序中对流的访问时通过**文件指针（file pointer）**实现的。此指针的类型为`FILE *`（FILE类型在`<stdio.h>`中声明）。用文件指针表示的特定流具有标准的名字；如果需要，还可以声明另外一些文件指针。例如，如果程序除了标准流之外还需要两个流，则可以包含如下声明：

```c
FILE *fp1,*fp2;
```

虽然操作系统通常会限制可以同时打开的流的数量，但程序可以声明任意数量的`FILE *`类型变量。



### 标准流和重定向

`<stdio.h>`提供了3个标准流（如下表）。这3个标准流可以直接使用——不需要对其进行声明，也不用打开或关闭它们。

| 文件指针 | 流       | 默认的含义 |
| -------- | -------- | ---------- |
| stdin    | 标准输入 | 键盘       |
| stdout   | 标准输出 | 屏幕       |
| stderr   | 标准错误 | 屏幕       |

前面章节使用过的函数（printf、scanf、putchar、getchar、puts和gets）都是通过stdin获得输入，并且用stdout进行输出的。默认情况下，stdin表示键盘，而stdout和stderr则表示屏幕。然而，许多操作系统允许通过一种称为**重定向（redirection）**的机制来改变这些默认的定义。



通常，我们可以强制程序从文件而不是从键盘获得输入，方法是在命令行这放上文件的名字，并在前面加上字符`<`：

```c
demo <in.dat
```

这种方法称为输入**重定向（input direction）**，它本质上是使stdin流表示文件（此例中为文件in.dat）而非键盘。重定向的绝妙之处在于，demo程序不会意识到正在从文件**in.dat**中读取数据，它会认为从stdin获得的任何数据都是从键盘上录入的。



**输出重定向（output redirection）**也是类似的。对stdout流的重定向通常是通过在命令行中放置文件名，并在前面加上字符`>`实现的：

```shell
demo >out.dat
```

现在所有写入stdout的数据都将进入`out.dat`文件中，而不是出现在屏幕上了。顺便说一下，还可以把输出重定向和输入重定向结合使用：

```shell
demo <in.dat >out.dat
```

字符`<`和`>`不需要与文件名相邻，重定向文件的顺序也是无关紧要的，所以下面的例子效果一样：

```shell
demo < in.dat > out.dat
demo >out.dat <in.dat
```

输出重定向的一个问题是会把写入stdout的所有内容都放入到文件中。如果程序运行失常并且开始写出错消息，那么我们只能在看文件的时候才会知道。而这些应该是出现在stderr中的。通过把出错消息写到stderr而不是stdout中，我们可以保证即使在对stdout进行重定向时这些出错消息仍能出现在屏幕上。（不过，操作系统通常也允许对stderr进行重定向。）



### 文本文件与二进制文件

`<stdio.h>`支持两种类型的文件：文本文件和二进制文件。在**文本文件（text file）**中，字节表示字符，这使人们可以检查或编辑文件。例如，C程序的源代码时存储在文本文件中的。另一方面，在**二进制文件（binary file）**中，字节不一定表示字符；字节组还可以表示其他类型的数据，比如整数和浮点数。如果试图查看可执行C程序的内容，会立刻意识到它时存储在二进制文件中的。



文本文件具有两种二进制文件没有的特性。

- 文本文件分成若干行

  文本文件的每一行通常以一两个特殊字符结尾，特殊字符的选择与操作系统有关。在windows中，行末的标记时回车符（`\x0d`）与一个紧跟其后的回行符（`\x0a`）。在UNIX和Mac OS的较新版本中，行末的标记是一个单独的回行符。

- 文本文件可以包含一个特殊的“文件末尾”标记。

  一些操作系统允许在文本文件的末尾使用一个特殊的字节作为标记。在Windows中，标记为`\x1a`（Ctrl + Z）。Ctrl + Z不是必需的，但如果存在，它就标志着文件的结束，其后的所有字节都会被忽略。大多数其他操作系统（包括UNIX）没有专门的文件末尾字符。



二进制文件不分行，也没有行末标记和文件末尾标记，所有字节都是平等对待的。



向文件写入数据时，我们需要考虑时按文本格式存储还是按二进制格式进行存储。为了搞清楚其中的差别。考虑在文件中存储数32767的情况。一种选择时以文本的形式把该数按字符3、2、7、6、7写入。假设字符集为ASCII（ASCII字符集中，字符`1`是49即00110001），那么就得到下列5个字节：

| 00110011 | 00110010 | 00110111 | 00110110 | 00110111 |
| -------- | -------- | -------- | -------- | -------- |

另一种选择数以二进制的形式存储此束，这种方法只会占用两个字节：

| 01111111 | 11111111 |
| -------- | -------- |

（在按小端顺序（20.3节）存储的系统中，这两个字节的顺序相反。）从上述示例可以看出，用二进制形式存储数可以节省相当大的空间。



编写用来读写文件的程序时，需要考虑该文件是文本文件还是二进制文件。在屏幕上显示文件内容的程序可能要把文件视为文本文件。但是，文件复制程序就不能认为要复制的文件为文本文件。如果那样做，就不能完全复制含有文件末尾字符的二进制文件了。在无法确定文件是文本形式还是二进制形式时，安全的做法是把文件假定为二进制文件。



## 文件操作

简单性是输入和输出重定向的魅力之一：不需要打开文件、关闭文件或者执行任何其他的显式文件操作。可惜的是，重定向在许多应用中受到限制。当程序依赖重定向时，它无法控制自己的文件，甚至无法知道这些文件的名字。更糟糕的是，如果程序需要在同一时间读入两个文件或者写出两个文件，重定向都无法做到。



当重定向无法满足需要时，我们将使用`<stdio.h`提供的文件操作。本节将探讨这些文件操作，包括打开文件、关闭文件、改变缓冲文件的方式、删除文件以及重命名文件。



### 打开文件

```c
FILE *fopen(const char * restrict filename,const char * restrict mode);
```

如果要把文件用作流，打开时需要调用fopen函数。fopen函数的第一个参数是含有要打开文件名的字符串。（“文件名”可能包含关于文件为指导信息，如驱动器符或路径。）第二个参数是“模式字符串”，它用来指定打算对文件执行的操作。例如，字符串`r`表明将从文件读入数据，但是不会向文件写入数据。



注意，在fopen函数的原型中，restrict关键字（17.8节）出现了两次。restrict是C99关键字，表明filename和mode所指向的字符串的内存单元不共享。C89中的fopen原型不包含restrict，但也有这样的要求。restrict对fopen的行为没有影响，所以通常可以忽略。



fopen函数返回一个文件指针。程序可以（且通常将）把此指针存储在一个变量中，稍后在需要对文件进行操作时返回它。fopen函数的常见调用形式如下所示，其中fp是`FILE *`类型的变量：

```c
fp = fopen("in.dat","r");   /* opens in.dat for reading */
```

当程序稍后调用输入函数从文件in.dat中读数据时，将会把fp作为一个实际参数。



**当无法打开文件时，fopen函数会返回空指针。这可能是因为文件不存在，也可能是因为文件的位置不对，还可能是因为我们没有打开文件的权限。**



### 模式

**给fopen函数传递哪种模式字符串不仅依赖于稍后将要对文件采取的操作，还取决于文件中的数据是文本形式还是二进制形式。**为了打开一个文本文件，可以采用下表中的一种模式字符串。



用于文本文件的模式字符串：

| 字符串 | 含义                                     |
| ------ | ---------------------------------------- |
| “r”    | 打开文件用于读                           |
| “w”    | 打开文件用于写（文件不需要存在）         |
| “a”    | 打开文件用于追加（文件不需要存在）       |
| “r+”   | 打开文件用于读和写，从文件头开始         |
| “w+”   | 打开文件用于读和写（如果文件存在就截去） |
| “a+”   | 打开文件用于读和写（如果文件存在就追加） |

当使用fopen打开二进制文件时，需要在模式字符串中包含字母b。下表列出了用于二进制文件的模式字符串：

| 字符串         | 含义                                     |
| -------------- | ---------------------------------------- |
| ”rb“           | 打开文件用于读                           |
| ”wb“           | 打开文件用于写（文件不需要存在）         |
| ”ab“           | 打开文件用于追加（文件不需要存在）       |
| ”r+b“或者”rb+“ | 打开文件用于读和写，从文件头开始         |
| ”w+b“或者”wb+“ | 打开文件用于读和写（如果文件存在就截去） |
| ”a+b“或者”ab+“ | 打开文件用于读和写（如果文件存在就追加） |

从上面两个表可以看出`<stdio.h>`对写数据和追加数据进行了区分。当给文件写数据时，通常会对先前的内容进行覆盖。然而，当为追加打开文件时，向文件写入的数据添加在文件末尾，因而可以保留文件的原始内容。



顺便说一下，当打开文件用于读和写（模式字符串包含字符+）时，有一些特殊的规则。如果没有先调用一个文件定位函数（22.7节），那么就不能从读模式转换成写模式，除非读操作遇到了文件的末尾。类似地，如果既没有调用fflush函数（稍后介绍）也没有调用文件定位函数，那么就不能从写模式转换成读模式。



### 关闭文件

```c
int fclose(FILE *stream);
```

fclose函数允许程序关闭不再使用的文件。fclose函数的参数必须是文件指针，此指针来自fopen函数或freopen函数（稍后介绍）的调用。如果成功关闭了文件，fclose函数会返回零；否则，它将会返回错误代码EOF（在`stdio.h`中定义的宏）。



为了说明如何在实践中使用fopen函数和fclose函数，下面给出了一个程序的框架。把程序打开文件example.dat进行读操作，并要检查打开是否成功，然后在程序终止前再把文件关闭：

```c
#include <stdio.h>
#include <stdlib.h>

#define FILE_NAME "example.dat"

int main(void){
	FILE *fp = fopen(FILE_NAME,"r");
	if(fp == NULL){
		printf("Can`t open %s\n",FILE_NAME);
		exit(EXIT_FILURE);
	}
	...
	fclose(fp);
	return 0;
}
```

### 为打开的流附加文件

```c
FILE *freopen(const char * restrict filename,
				const char * restrict mode,
				FILE * restrict stream);
```

**freopen函数为已经打开的流附加上一个不同的文件。最常见的用法是把文件和一个标准流（stdin、stdout或stderr）相关联。**例如，为了使程序开始往文件foo中写数据，可以使用下列形式的freopen函数调用：

```c
if(freopen("foo","w",stdout) == NULL){
	/* error; foo can`t be opened */
}
```

在关闭了先前（通过命令行重定向或者之前的freopen函数调用）与stdout相关联的所有文件之后，freopen函数将打开文件foo，并将其与stdout相关联。



freopen函数的返回值通常是它的第三个参数（一个文件指针）。如果无法打开新文件，那么freopen函数会返回空指针。（如果无法关闭旧的文件，那么freopen函数会忽略掉错误。）



C99新增了一种机制。如果filename是空指针，freopen会试图把流的模式修改为mode参数指定的模式。不过，具体的实现可以不支持这种特性；如果支持，可以限定能进行哪些模式改变。



### 从命令行获取文件名

