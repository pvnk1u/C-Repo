# 指针和数组

上一章介绍了指针，并且说明了如何把指针用作函数的实际参数和函数的返回值。本章介绍指针的另一种应用。当指针指向数组元素时，C语言允许对指针进行算术运算（加法和减法），通过这种运算我们可以用指针代替数组下标对数组进行处理。



C语言中指针和数组的关系是非常紧密的。后面的章节将利用这种关系。理解指针和数组之间的关系对于熟练掌握C语言非常关键：它能使我们深入了解C语言的设计过程，并且能够帮助我们理解现有的程序。然而，需要知道的是，用指针处理数组的主要原因是效率，但是这里的效率提升已经不再像当初那么重要了，这主要归功于编译器的改进。



## 指针的算术运算

由11.5节（指针作为返回值）可知，指针可以指向数组元素。例如，假设已经声明a和p如下：

```c
int a[10],*p;
```

通过下列写法可以使p指向a[0]：

```c
p = &a[0];
```

现在可以通过p访问a[0]。例如，可以通过下列写法把值5存入a[0]中：

```c
*p = 5;
```



把指针p指向数组a的元素不是特别令人激动。但是，通过在p上执行指针算术运算（或者地址算术运算）可以访问数组a的其他所有元素。C语言支持3种（而且只有3种）格式的指针算术运算：

- 指针加上整数；
- 指针减去整数；
- 两个指针相减。



下面仔细研究一下每种运算。下面的所有例子都假设有如下声明：

```c
int a[10],*p,*q,i;
```



### 指针加上整数

指针p加上整数j产生指向特定元素的指针，这个特定元素是p原先指向的元素后的j个位置。更确切地说，如果p指向数组元素a[i]，那么p+j指向a[i+j]（当然，前提是a[i+j]必须存在）。



下面的示例说明指针的加法运算：

```c
p = &a[2];   // 指针p指向数组的第三个元素
q = p + 3;	// 指针q指向数组的第6个元素
p +=6;		// 指针p重新指向数组的第9个元素
```



### 指针减去整数

如果p指向数组元素a[i]，那么p-j指向a[i-j]。例如：

```c
p = &a[8];		// 指针p指向数组a的第9个元素
q = p -3;		// 指针q指向数组a的第6个元素
p -= 6;			// 指针p重新指向数组的第3个元素
```



### 两个指针相减

当两个指针相减时，结果为指针之间的距离（用数组元素的个数来度量）。因此，如果p指向a[i]且q指向a[j]，那么p-q就等于i-j。例如：

```c
p = &a[5];
q = &a[1];

i = p - q;		// i is 4
i = q - p;		// i is -4
```



在一个不指向任何数组元素的指针上执行算术运算会导致未定义的行为。此外，只有在两个指针指向同一个数组时，把它们相减才有意义。



### 指针比较

可以用关系运算符（<、<=、>和>=）和判等运算符（==和!=）进行指针比较。只有在两个指针指向同一数组时，用关系运算符进行的指针比较才有意义，比较的结果依赖于数组中两个元素的相对位置。例如，在下面的赋值后p<= q的值是0，而p >= q的值是1。

```c
p = &a[5];
q = &a[1];
```



### 指向复合常量的指针

指针指向由复合字面量创建的数组中的某个元素是合法的。回顾一下，复合字面量是C99的一个特性，可以用于创建没有名称的数组。



考虑如下的例子：

```c
int *p = (int[]){3,0,3,4,1};
```

p指向一个五元数组的第一个运算符，这个数组包括5个数组3，0，3，4，1。使用复合字面量可以减少一些麻烦，我们不再需要先声明一个数组变量，然后用指针p指向数组的第一个元素：

```c
int a[] = {3,0,3,4,1};
int *p = &a[0];
```



## 指针用于数组处理

指针的算术运算允许通过对指针变量进行重复自增来访问数组的元素。下面这个对数组a中元素求和的程序段说明了这种方法。在这个示例中，指针变量p初始指向a[0]，每次执行循环时对p进行自增；因此p先指向a[1]，然后指向a[2]，以此类推。在p指向数组的最后一个元素后循环终止。

```c
#define N 10
...
int a[N],sum,*p;
...
sum = 0;
for(p = &a[0],p<&a[N];p++)
	sum += *p;
```

for语句中的条件p<&a[N]值得特别说明一下。尽管元素a[N]不存在（数组a的下标从0到N-1），但是对它使用取地址运算符是合法的。因为循环不会尝试检查a[N]的值，所以在上述方式下使用a[N]是非常安全的。执行循环体时p依次等于&a[0]，&a[1], ... ,&a[N-1]，但是当p等于&a[N]时，循环终止。



当然，改用下标可以很容易地写出不使用指针的循环。支持采用指针运算的最常见论调是，这样做可以节省执行时间。但是，这依赖于具体的实现——对有些编译器来说，实际上依靠下标的循环会产生更好的代码。



### *运算符和++运算符的组合

C程序员经常在处理数组元素的语句中组合*（间接寻址）运算符和++运算符。思考一个简单的例子：把值存入一个数组元素中，然后前进到下一个元素。利用数组下标可以这样写：

```c
a[i++] = j;
```

如果p指向数组元素，那么相应的语句将会是：

```c
*p++ = j;
```

因为**后缀++的优先级高于***，所以编译器把上述语句看成是

```c
*(p++) = j;
```

p++的值是p。（因为使用后缀++，所以p只有在表达式计算出来后才可以自增。）因此，*(p++)的值将是`*p`，即p当前指向的对象。



当然，*p++不是唯一合法的`*`和++的组合。例如，可以编写`(*p)++`，这个表达式返回p指向的对象的值，然后对对象进行自增（p本身是不变化的）。如果觉得困惑，那么下面的表格可以提供一些帮助。

| 表达式             | 含义                                |
| ------------------ | ----------------------------------- |
| *p++或 *(p++)      | 自增前表达式的值是*p，以后再自增p   |
| (*p)++             | 自增前表达式的值是*p，以后再自增 *p |
| *++p或 *(++p)      | 先自增p，自增后表达式的值是*p       |
| `++*p` 或 `++(*p)` | 先自增*p，自增后表达式的值是 *p     |

这4种组合都可以出现在程序中，但有些组合比其他组合要常见的多。最频繁见到的就是`*p++`，它在循环中是很方便的。对数组a的元素求和时，可以把

```c
for(p = &a[0];p<&a[N],p++)
	sum += *p;
```

改写成

```c
p = &a[0];
while(p < &a[N])
	sum += *p++;
```

*运算符和--运算符的组合方法类似于 * 和++的组合。为了应用 * 和--的组合，一起回到10.2节的栈的例子。原始版本的栈依靠名为top的整型变量来记录contents数组中”栈顶“的位置。现在用一个指针变量来替换top，这个指针变量初始指向contents数组的第0个元素。

```c
int *top_ptr = &contents[0];
```

下面是新的push函数和pop函数：

```c
void push(int i){
	if(is_null()){
		stack_overflow();
	}else{
		*top_ptr++=i;
	}
}

int pop(void){
	if(is_empty()){
		stack_underflow();
	}else{
		return *--top_ptr;
	}
}
```

注意，因为希望pop函数在取回top_ptr指向的值之前对top_ptr进行自减，所以要写成*--top_ptr，而不是 *top_ptr--。



## 用数组名作为指针

指针的算术运算是数组和指针之间相互关联的一种方法，但这不是两者之间唯一的联系。下面是另一种关键的关系：可以用数组的名字作为指向数组第一个元素的指针。这种关系简化了指针的算术运算，而且使数组和指针更加通用。



例如，假设用如下形式声明a：

```c
int a[10];
```

用a作为指向数组第一个元素的指针，可以修改a[0]：

```c
*a = 7;		/* strores 7 in a[0] */
```

可以通过指针a+1来修改a[1]：

```c
*(a+1) = 12;	/* store 12 in a[1] */
```

通常情况下，a+i等同于&a[i]（两者都表示指向数组a中元素i的指针），并且* (a+i)等价于a[i]（两者都表示元素i本身）。换句话说，可以把数组的取下标操作看成是指针算术运算的一种形式。



数组名可以用作指针这一事实使得编写遍历数组的循环更加容易。思考下面这个来自12.2节的循环：

```c
for(p=&a[0];p<&a[N];p++)
	sum += *p;
```

为了简化这个循环，可以用a替换&a[0]，同时用a+N替换&a[N]：

```c
// 惯用法
for(p=a;p<a+N;p++)
	sum += *p;
```

虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其他地方是错误的：

```c
while(*a != 0)
	a++;		// WRONG
```



想要遍历数组的正确做法应该是：把a复制给一个指针变量，然后改变该指针变量：

```c
p = a;
while(*p != 0)
	p++;
```



### 数组反向（改进版）

8.1节的程序reverse.c读入10个数，然后逆序输出这些数。程序读取数时会把这些数存入数组。一旦所有的数都读入了，程序就会反向遍历数组并打印出这些数。



原来的程序利用下标来访问数组中的元素。下面是改进后的程序reverse3.c，这里用指针的算术运算取代了数组的取下标操作。

```c
#include <stdio.h>

#define N 10

int main(void) {
    int a[10],*p;

    printf("Enter %d numbers: ",N);
    for (p = a;p < a+N;p++)
        scanf("%d",p);

    printf("In reverse order: ");
    for (p = a+N-1;p>=a;p--)
        printf(" %d",*p);
    printf("\n");

    return 0;
}
```

在原先的程序中，整型变量i用来记录数组内的当前位置。新版程序用指针变量p替换了i。读入的数仍然存储在数组中，只是换了一种方法来记录数组中的位置。



**注意，scanf函数的第二个参数是p，不是&p。因为p指向数组的元素，所以它是满足scanf函数要求的参数；而&p则是指向数组元素的指针的指针。**



### 数组型实际参数（改进版）

**数组名在传递给函数时，总是被视为指针。**思考下面这个函数，这个函数会返回整型数组中最大的元素；

```c
int find_largest(int a[],int n){
	int i,max;
	max = a[0];
	
	for(i=1;i<n;i++)
		if(a[i] > max)
			max = a[i];
	return max;
}
```

假设调用find_largest函数如下：

```c
largest = find_largest(b,N);
```

**这个调用会把指向数组b第一个元素的指针赋值给a，数组本身并没有被复制。**



把数组型形式参数看作是指针会产生许多重要的结果。

- 在给函数传递普通变量时，变量的值会被复制；任何对相应的形式参数的改变都不会影响到变量。反之，因为没有对数组本身进行复制，所以作为实际参数的数组是可能被改变的。例如，下列函数可以通过在数组的每个元素中存储零来修改数组。

  ```c
  void store_zeros(int a[],int n){
  	int i;
  	for(i=0;i<N;i++){
  		a[i] = 0;
  	}
  }
  ```

  **为了指明数组型形式参数不会被改变，可以在其声明中包含单词const：**

  ```c
  int find_largest(const int a[],int n){
  	...
  }
  ```

  **如果参数中有const，编译器会核实find_largest函数体中确实没有对a中元素的赋值。**

- 给函数传递数组所需的时间与数组的大小无关。因为没有对数组进行复制，所以传递大数组不会产生不利的结果。

- 如果需要，可以把数组型形式参数声明为指针。例如，可以按如下形式定义find_largest函数:

  ```c
  int find_largest(int *a,int n){
  	...
  }
  ```

  **声明a是指针就相当于声明它是数组。编译器把这两类声明看作是完全一样的。**

  

  注意：

  对于形式参数而言，声明为数组和声明为指针是一样的；但是对变量而言，声明为数组跟声明为指针是不同的。声明

  ```c
  int a[10];
  ```

  会导致编译器预留10个整数的空间，但声明

  ```c
  int *a;
  ```

  只会导致编译器为一个指针变量分配空间。在后一种情况下，a不是数组，试图把它当作数组来使用可能会导致极糟的后果。例如，赋值

  ```c
  *a=0;	// WRONG
  ```

  **将在a指向的地方存储0。因为我们不知道a指向哪里，所以对程序的影响是无法预料的。**

- 可以给形式参数为数组的函数传递数组的”片断“，所谓片断是指连续的数组元素组成的序列。假设希望用find_largest函数来定位数组b中某一部分的最大元素，比如说元素b[5]，...，b[14]。调用find_largest函数时，将传递b[5]的地址和数10，表明希望find_largest函数从b[5]开始检查10个数组元素：

  ```c
  largest = find_largest(&b[5],10);
  ```



### 用指针作为数组名

既然可以用数组名作为指针，C语言是否允许把指针看作数组名进行取下标操作呢？答案是可以。下面是一个例子：

```c
#define N 100
...
int a[N],sum = 0,*p=a;
...
for(i=0;i<N;i++)
	sum += p[i];
```

编译器把p[i]看作*(p+i)，这是指针算术运算非常正规的用法。目前我们对能够对指针取下标还仅限于好奇，后面会看到它实际上非常有用。



## 指针和多维数组

就像指针可以指向一维数组的元素一样，指针还可以指向多维数组的元素。简单起见，这里只讨论二维数组，但所有内容都可以应用于更高维的数组。



### 处理多维数组的元素

从8.2节可知，C语言按行主序存储二维数组；换句话说，先是0行的元素，接着是1行的，以此类推。r行的数组可表示如下：

| 0行  | 1行  | ...  | r-1行 |
| ---- | ---- | ---- | ----- |
| .... | .... | .... | ....  |

**使用指针时可以利用这一布局特点。如果使指针p指向二维数组中的第一个元素（即0行0列的元素），就可以通过重复自增p的方法访问数组中的每一个元素。**



作为示例，来看看把二维数组的所有元素初始化为0的问题。假设数组的声明如下：

```c
int a[NUM_ROWS][NUM_COLS];
```

显而易见的方法是用嵌套的for循环：

```c
int row,col;
...
for(row=0;row<NUM_ROWS;row++)
	for(col=0;col<NUM_COLS;col++)
		a[row][col] = 0;
```

但是，如果把a看成是一维的整型数组，那么就可以把上述两个循环改成一个循环了：

```c
int *p;
...
for(p = &a[0][0];p<&a[NUM_ROWS-1][NUM_COLS-1];p++)
	*p = 0;
```

循环开始时p指向a[0] [0]。对p连续自增可以使指针p指向a[0] [1]、a[0] [2]、a[0] [3]等。当p达到a[0] [NUM_COLS-1]（即第0行的最后一个元素时），再次对p自增将使它指向a[1] [0]，也就是第1行的第一个元素。这一过程持续进行，直到p越过a[NUM_ROWS-1] [NUM_COLS-1] (数组中最后一个元素)为止。



虽然把二维数组当成一维数组来处理看上去像是搞欺骗，但是对大多数C语言编译器而言这样做都是合法的。这类方法明显破坏了程序的可读性，但是至少对一些老的编译器来说这种方法在效率方面进行了补偿。不过，对许多现代的编译器来说，这样所获得的速度优势往往极少甚至完全没有。



### 处理多维数组的行

处理二维数组的一行中的元素，该怎么办呢？再次选择使用指针变量p。为了访问到第i行的元素，需要初始化p使其指向数组a中第i行的元素0：

```c
p = &a[i][0];
```

**对于任意的二维数组a来说，由于表达式a[i]是指向第i行中第一个元素（元素0）的指针，上面的语句可以简写为：**

```c
p = a[i];
```

