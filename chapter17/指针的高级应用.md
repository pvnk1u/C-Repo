# 指针的高级应用

前面几章描述了指针的两种重要应用。第11章说明了如何利用指向变量的指针作为函数的参数从而允许函数修改该变量。第12章说明了如何对指向数组元素的指针进行算术运算来处理数组。本章则通过观察另外两种应用来完善指针的内容：动态存储分配和指向函数的指针。



**通过使用动态存储分配，程序可以在执行期间获得需要的内存块。**第一节将解释动态存储分配的基本概念。第二节则讨论动态分配字符串，这比通常的字符数组更加灵活。第三节大概地介绍数组的动态存储分配。第四节处理存储分配的问题，即不再需要内存单元时，动态地释放已分配的内存块。



因为动态分配的结构可以链接在一起形成表、树和其他高度灵活的数据结构，所以它们在C语言编程中扮演着重要的角色。第五节重点讲述链表，它是最基础的链式数据结构。这一节中引出的问题（“指向指针的指针”的概念）对引出第六节非常重要。



第七节介绍指向函数的指针，这是非常有用的内容。C语言中一些功能最强大的库函数都期望把指向函数的指针作为参数。这里将考察其中一个函数qsort，它可以对任意数组成员进行排序。



最后两节讨论C99中新出现的与指针相关的特性：受限指针和灵活数组成员。



## 动态存储分配

C语言中的数据结构通常是固定大小的。例如，一旦程序完成编译，数组元素的数量就固定了。（**在C99中，变长数组（8.3节）的长度在运行时确定，但在数组的生命周期内仍然是固定长度的。**）因为在编写程序时强制选择了大小，所以固定大小的数据结构可能会有问题。也就是说，在不修改程序并且再次编译程序的情况下无法改变数据结构的大小。



请思考16.3节中允许用户向数据库中添加零件的inventory程序。数据库存储在长度为100的数组中。为了扩大数据库的容量，可以增加数组的大小并且重新编译程序。但是，无论如何增大数组，始终有可能填满数组。幸运的是，还有别的办法。**C语言支持动态存储分配，即在程序执行期间分配内存单元的能力。利用动态存储分配，可以设计出能根据需要扩大（和缩小）的数据结构。**



**虽然动态存储分配适用于所有类型的数据，但主要用于字符串、数组和结构。动态分配的结构是特别有趣的，因为可以把它们链接形成表、树或其他数据结构。**



### 内存分配函数

为了动态地分配存储空间，需要调用三种内存分配函数的一种，这些函数都是声明在`<stdlib.h>`头中的。

- **malloc函数**

  **分配内存块，但是不对内存块进行初始化**

- **calloc函数**

  **分配内存块，并且对内存块进行清零**

- **reallloc**

  **调整先前分配的内存块大小**



在这三种函数中，malloc函数是最常用的一种。因为malloc函数不需要对分配的内存块进行清零，所以它比calloc更高效。



**当为申请内存块而调用内存分配函数时，由于函数无法知道计划存储在内存块中的数据是什么类型的，所以它不能返回int类型、char类型等普通类型的指针。取而代之的，函数会返回`void *`类型的值。`void *`类型的值是“通用”指针，本质上它只是内存地址。**



### 空指针

**当调用内存分配函数时，总存在这样的可能性：找不到满足我们需要的足够大的内存块。如果真的发生了这样的问题，函数会返回空指针（null pointer）。空指针是“不指向任何地方的指针”，这是一个区别于所有有效指针的特殊值。在把函数的返回值存储到指针变量中后，需要判断该指针变量是否为空指针。**



程序员的责任是测试任意内存分配函数的返回值，并且在返回空指针时采取适当的动作。**试图通过空指针访问内存的效果是未定义的，程序可能会崩溃或者出现不可预测的行为。**



**空指针用名为NULL的宏来表示，所以可以用下列方式检测malloc函数的返回值：**

```c
p = malloc(10000);
if(p = NULL){
	/* allocation failed; take approciates action */
}
```

一些程序员会把malloc函数的调用和NULL的测试组合在一起：

```c
if((p = malloc(10000)) == NULL){
	/* allocation failed; take appropriate action */
}
```

名为NULL的宏在6个头`<locale.h>`、`<stddef.h>`、`<stdio.h>`、`<stdlib.h>`、`string.h`和`<time.h>`中都有定义。（C99的`<wchar.h>`也定义了NULL。）只要把这些头中的一个包含在程序中，编译器就可以识别出NULL。当然，使用任意内存分配函数的程序都会包含`<stdlib.h>`，这使NULL必然有效。



在C语言中，指针测试真假的方法和数的测试一样。所有非空指针都为真，而只有空指针为假。因此，语句

```c
if(p == NULL)...
```

可以写成：

```c
if(!p)...
```

而语句

```c
if(p != NULL)...
```

则可以写成：

```c
if(p)...
```



## 动态分配字符串

**动态内存分配对字符串操作非常有用。字符串存储在字符数组中，而且可能很难预测这些数组需要的长度。通过动态地分配字符串，可以推迟到程序运行时才作决定。**



### 使用malloc函数为字符串分配内存

malloc函数具有如下原型：

```c
void *malloc(size_t size);
```

malloc函数分配size个字节的内存块，并且返回指向该内存块的指针。注意，size的类型是size_t，这是在C语言库中定义的无符号整数类型。除非正在定义一个非常巨大的内存块，否则可以只把size考虑成普通整数。



用malloc函数为字符串分配内存是很容易的，因为C语言保证char类型值恰需要一个字节的内存（换句话说，sizeof(char) 的值为1）。为给n个字符的字符串分配存储空间，可以写成

```c
p = malloc(n+1);
```

这里的p是`char *`类型变量。（**实际参数是n+1而不是n，这就给空字符留了空间。）在执行赋值操作时会把malloc函数返回的通用指针转换为`char *`类型，而不需要强制类型转换。（通常情况下，可以把`void *`类型值赋给任何指针类型的变量，反之亦然。）然而，一些程序员喜欢对malloc函数的返回值进行强制类型转换：**

```c
p = (char *) malloc(n+1);
```



**当使用malloc函数为字符串分配内存空间时，不要忘记包含空字符的空间。**



由于使用malloc函数分配的内存不需要清零或者以任何方式进行初始化，所以p指向带有n+1个字符的未初始化的数组。对这个数组进行初始化的一种方法是调用`strcpy`函数：

```c
strcpy(p,"abc");
```

数组中的前4个字符分别为`a`、`b`、`c`和`\0`。



### 在字符串函数中使用动态存储分配

动态存储分配使编写返回指向“新”字符串的指针的函数成为可能，所谓新字符串是指在调用此函数之前字符串并不存在。如果编写的函数把两个字符串连接起来而不改变其中任何一个字符串，请思考一下这样做会遇到什么问题。C标准库没有包含此类函数（因为strcat函数改变了作为参数传递过来的一个字符串，所以此函数不是我们所要的函数），但是可以很容易自行写出这样的函数。



自行编写的函数将测量用来连接的两个字符串的长度，然后调用malloc函数为结果分配适当大小的内存空间。接下来函数会把第一个字符串复制到新的内存空间中，并且调用strcat函数来拼接第二个字符串。

```c
char *concat(const char *s1,const char *s2)
{
	char *result;
	
	result = malloc(strlen(s1) + strlen(s2) + 1);
	if(result == NULL){
		printf("Error: malloc failed in concat\n");
		exit(EXIT_FAILURE);
	}
	strcpy(result,s1);
	strcat(result,s2);
	return result;
}
```

如果malloc函数返回空指针，那么concat函数显示出错消息并且终止程序。这并不是正确的措施，一些程序需要从内存分配失败后恢复并且继续运行。



下面是concat函数可能的调用方式：

```c
p = concat("abc","def");
```

这个调用之后，p指向字符串“abcdef”，此字符串是存储在动态分配的数组中的。数组包括结尾的空字符一共有7个字符长。



像concat这样动态分配存储空间的函数必须小心使用。当不再需要concat函数返回的字符串时，需要调用free函数（稍后讲到）来释放它占用的空间。如果不这样做，程序最终会用光内存空间。



### 动态分配字符串的数组

13.7节解决了在数组中存储字符串的问题。我们发现把字符串存储为二维字符数组中的行为可能会浪费空间，所以试图建立一个指向字符串字面量的指针的数组。如果数组元素是指向动态分配的字符串的指针，那么13.7节中的方法是有效的。为了说明这一点，先来重新编写13.5节中的程序remind.c，此程序显示出一个月的日常提醒列表。



**显示一个月的提醒列表（改进版）**

原始程序remind.c把提醒字符串存储在二维字符数组中，且数组的每行包含一个字符串。程序读入一天和相关的提醒后，会搜索数组并使用strcmp函数进行比较从而确定这一天所处的位置。然后，程序使用函数strcpy把该位置下面的全部字符串向下移动一个位置。最后，程序把这一天复制到数组中，并且调用strcat函数来添加这一天的提醒。



在新程序（remind2.c）中，**数组是一维的，且数组的元素是指向动态分配的字符串的指针。在此程序中换成动态分配的字符串有两个好处。第一，与原先那种用固定数量的字符来存储提醒的方式相比，可以为要存储的提醒分配确切字符数量的空间，从而可以更有效地利用空间。第二，不需要为了给新提醒分配空间而调用函数strcpy来移动已有的字符串，只需要移动指向字符串的指针。**



下面是新程序，程序中有改动的部分用粗体进行了标注。把二维数组换成指针数组显得异常容易：只需要改变程序中的8行内容：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_REMIND 50
#define MSG_LEN 60

int read_line(char str[],int n);

int main(void) {
    char *reminders[MAX_REMIND];
    char day_str[3],msg_str[MSG_LEN+1];
    int day,i,j,num_remind = 0;

    for (;;) {
        if (num_remind == MAX_REMIND) {
            printf("-- No space left --\n");
            break;
        }

        printf("Enter day and reminder: ");
        scanf("%2d",&day);
        if (day == 0)
            break;
        sprintf(day_str,"%2d",day);
        read_line(msg_str,MSG_LEN);

        for (int i = 0; i < num_remind; i++) {
            if (strcmp(day_str,reminders[i]) < 0)
                break;
        }

        for (j = num_remind;j>i;j--)
            reminders[j] = reminders[j-1];

        reminders[i] = malloc(2 + strlen(msg_str) + 1);
        if (reminders[i] == NULL) {
            printf("-- No space left-- \n");
            break;
        }

        strcpy(reminders[i],day_str);
        strcat(reminders[i],msg_str);

        num_remind++;
    }
    printf("\nDay Reminder\n");
    for (int i = 0; i < num_remind; ++i) {
        printf(" %s\n",reminders[i]);
    }

    return 0;
}

int read_line(char str[],int n) {
    int ch,i = 0;

    while ((ch = getchar()) != '\n') {
        if (i < n)
            str[i++] = ch;
    }
    str[i] = '\0';
    return i;
}
```
