# 声明
声明在C语言编程中起着核心的作用。通过声明变量和函数，可以在检查程序潜在的错误以及把程序翻译成目标代码两方面为编译器提供至关重要的信息。

前面几章已经提供了声明的示例，但是没有完整地描述，本章将弥补这个缺憾。本章会探讨可以用于声明的复杂选项，并且显示变量声明和函数声明之间的几个共同点。此外，本章还为存储期限、作用域以及链接这些重要概念提供了坚实的基础。

第一节介绍声明的一般语法，这是之前一直在回避的问题。接下来的4节将集中讨论声明中出现的数据项：存储类型、类型限定符、声明符和初始化式。最后还将讨论inline关键字，它可以用在C99函数声明中。

## 声明的语法
声明为编译器提供有关标识符含义的信息。当编写：
```c
int i;
```
时，是在告诉编译器：名字i表示当前作用域内数据类型为int的变量。声明
```c
float f(float);
```
则是在告诉编译器：f是一个返回值为float型的函数，并且此函数有一个实际参数，此参数类型也为float型。

一般地，声明具有下列形式：
```
声明说明符 声明符;
```
声明说明符描述声明的变量或函数的性质。声明符给出了它们的名字，并且可以提供关于其性质的额外信息。

声明说明符分为以下三大类：
- 存储类型
	**存储类型一共有4种：auto、static、extern和register。在声明中最多可以出现一种存储类型。如果存储类型存在，则必须把它放置在最前面。**
- 类型限定符
	**C89只有两种类型限定符：const和volatile。C99还有一个限定符restrict。声明可以包含零个或多个限定符。**
- 类型说明符
	关键字void、char、short、int、long、float、double、signed和unsigned都是类型说明符。这些单词可以组合使用，如第7章所述。这些单词出现的顺序并不重要（int undesigned long和 long unsigned int完全一样）。类型说明符也包括结构、联合和枚举的说明（例如，`struct point{int x,y;}`、`struct {int x,y}`或者`struct point`）。用typedef创建的类型名也是类型说明符。


**（C99还有第四种声明说明符，即函数说明符，它只适用于函数声明。这一类说明符只有一个，即关键字inline。）** 类型限定符和类型说明符必须跟随在存储类型的右边，但是两者的顺序没有限制。出于书写风格的考虑，这里会将类型限定符放置在类型说明符的前面。

声明符包括标识符（简单变量的名字）、后面跟随`[]`的标识符（数组名）、前放置`*`的标识符（指针名）和后边跟随`()`的标识符（函数名）。声明符之间用逗号分隔。表示变量的声明符后面可以跟随初始化式。

来看一些说明这些规则的例子。下面是一个带有存储类型和三个声明符的声明：
```c
static float x,y,*p;
```
在这个例子中，`static`是存储类型，`float`是类型说明符，`x`、`y`和`*p`是声明符。

下列声明有类型限定符但是没有存储类型。此外，它还有初始化式：
```c
const char month[] = "January";
```
在这个例子中，`const`是类型限定符，`char`是类型说明符，`month[]`是声明符，`"January"`则是初始化式。


下列声明既有存储类型也有类型限定符。此外，它还有三个类型说明符，当然它们的顺序并不重要：
```c
extern const unsigned long int a[10];
```
在这个例子中，`extern`是存储类型，`const`是类型限定符，`unsigned`、`long`、`int`是类型说明符，`a[10]`是声明符。

和变量声明一样，函数声明也有存储类型、类型限定符和类型说明符。下列声明具有存储类型和类型说明符：
```c
extern int square(int);
```
在这个例子中，`extern`是存储类型，`int`是类型说明符，`square`是声明符。

## 存储类型
**存储类型可以用于变量以及较小范围的形式参数的说明。现在集中讨论变量的存储类型。**

回顾一下10.3节的内容，术语“块”（block）表示函数体（花括号包含的部分）或者复合语句（可能包含声明）。在C99中，选择语句（if和switch）、循环语句（while、do和for）以及它们所控制的“内部”语句也被视为块，尽管本质上有一些差别。

### 变量的性质
C程序中的每个变量都具有以下3个性质。
- 存储期限
	**变量的存储期限决定了为变量预留和内存被释放的时间。具有自动存储期限的变量在所属块被执行时获得内存单元，并在块终止时释放内存单元，从而会导致变量失去值。具有静态存储期限的变量在程序运行期间占有同一个的存储单元，也就允许变量无限期地保留它的值。**
- 作用域
	**变量的作用域是指可以引用变量的那部分程序文本。变量可以有块作用域（变量从声明的地方一直到所在块的末尾都是可见的）或者文件作用域（变量从声明的地方一直到所在文件的末尾都是可见的）。**
- 链接
	**变量的链接确定了程序的不同部分可以共享此变量的范围。具有外部链接的变量可以被程序中的几个（或许全部）文件共享。具有内部链接的变量只能属于单独一个文件，但是此文件中的函数可以共享这个变量。（如果具有相同名字的变量出现在另一个文件中，那么系统会把它作为不同的变量来处理。）无链接的变量属于单独一个函数，而且根本不能被共享。**

变量的默认存储期限、作用域和链接都依赖于变量声明的位置。
- **在块（包括函数体）内部声明的变量具有自动存储期限、块作用域，并且无链接。**
- **在程序的最外层（任意块外部）声明的变量具有静态存储期限、文件作用域和外部链接。**

下面的例子说明了变量i和变量j的默认性质：
```c
/**
* 静态存储期限
* 文件作用域
* 外部链接
*/
int i;

void f(void){
	/**
	* 自动存储期限
	* 块作用域
	* 无链接
	*/
	int j;
}
```

对许多变量而言，默认的存储期限、作用域和链接是符合要求的。当这些性质无法满足要求时，可以通过指定明确的存储类型（auto、static、extern和register）来改变变量的性质。


### auto存储类型
auto存储类型只对属于块的变量有效。auto变量具有自动存储期限、块作用域，并且无链接。auto存储类型几乎从来不用明确地指明，因为对于在块内声明的变量，它是默认的。

### static存储类型
static存储类型可以用于全部变量，而无需考虑变量声明的位置。但是，作用于块外部声明的变量和块内部声明的变量时会有不同的效果。当用在块外部时，单词static说明变量具有内部链接。当用在块内部时，static把变量的存储期限从自动的变成了静态的。下面的例子说明了把变量i和变量j声明为static所产生的效果：
```c
/**
* 静态存储期限
* 文件作用域
* 内部链接
**/
static int i;

/**
* 静态存储期限
* 块作用域
* 无链接
**/
void f(void){
	static int j;
}
```
在用于块外部的声明时，static本质上使变量只在声明它的文件内可见。只有出现在同一文件中的函数可以看到此变量。在下面的例子中，函数f1和函数f2都可以访问变量i，但是其他文件中的函数不可以：
```c
static int i;

void f1(void){
	/* has access to i */
}

void f2(void){
	/* has access to i */
}
```
static的此种用法可以用来实现一种称为信息隐藏的技术。

块内声明的static变量在程序执行期间驻留在同一存储单元内。和每次程序所在块就会丢失值的自动变量不同，static变量会无限期地保留值。static变量具有以下一些有趣的性质。
- 块内的static变量只在程序执行前进行一次初始化，而auto变量则会在每次出现时进行初始化（假设它有初始化式）。
- 每次函数被递归调用时，它都会获得一组新的auto变量。但是，如果函数含有static变量，那么此函数的全部调用都可以共享这个static变量。
- **虽然函数不应该返回指向auto变量的指针，但是函数返回指向static变量的指针是没有错误的。**

声明函数中的一个变量为static，这样做允许函数在“隐藏”区域内的调用之间保留信息。隐藏区域是程序其他部分无法访问到的地方。然而，更经常的做法是用static来使程序更加有效。思考下列函数：
```c
char digit_to_hex_char(int digit)
{
	const char_hex_chars[16] = "0123456789ABCDEF";
	return hex_chars[digit];	
}
```
每次调用digit_to_hex_char函数时，都会把字符0123456789ABCDEF复制给数组hex_chars来对其进行初始化。现在，把数组设为static的：
```c
char digit_to_hex_char(int digit)
{
	static const char_hex_chars[16] = "0123456789ABCDEF";
	return hex_chars[digit];
}
```
**由于static型变量只进行一次初始化，这样做就改进了digit_to_hex_char函数的速度。**

### extern存储类型
**extern存储类型使几个源文件可以共享同一个变量。** 15.2节介绍了使用extern的基本概念，所以这里的讨论不会太多。回顾讲过的内容可以知道，下列声明给编译器提供的信息是，i是int型变量：
```c
extern int i;
```
**但是这样不会导致编译器为变量i分配存储单元。用C语言的术语来说，上述声明不是变量i的定义，它只是提示编译器需要访问定义在别处的变量（可能稍后在同一文件中，更常见的是在另一个文件中）。变量在程序中可以有多次声明，但只能有一次定义。**

**变量的extern声明不是定义这一规则有一个例外。** 对变量进行初始化的extern声明是变量的定义。例如，声明：
```c
extern int i = 0;
```
等效于：
```c
int i =0;
```
**这条规则可以防止多个extrern声明用不同方法对变量进行初始化。**

extern声明中的变量始终具有静态存储权限。变量的作用域依赖于声明的位置。如果声明在块内部，那么变量具有块作用域。否则，变量具有文件作用域：
```c
/*
* 静态存储权限
* 文件作用域
* 什么链接？
*/
extern int i;

void f(void)
{
	/**
	* 静态存储期限
	* 块作用域
	* 什么链接？
	*/
	extern int j;
}
```
**确定extern型变量的链接有一定难度。如果变量在文件中较早的位置（任何函数定义的外部）声明为static，那么它具有内部链接；否则（通常情况下），变量具有外部链接。**


### register存储类型
声明变量具有register存储类型就要求编译器把变量存储在寄存器中，而不是像其他变量一样保留在内存中。（寄存器是驻留在计算机CPU中的存储单元。存储在寄存器中的数据会比存储在普通内存中的数据访问和更新的速度更快。）指明变量的存储类型是register是一种请求，而不是命令。编译器可以选择把register型变量存储在内存中。

**register存储类型只对声明在块内的变量有效。register变量具有和auto变量一样的存储期限、作用域和链接。但是，register变量缺乏auto变量所具有的一种性质：由于寄存器没有地址，所以对register变量使用取地址运算符&是非法的。即使编译器选择把变量存储在内存中，这一限制仍适用。**

**register存储类型最好用于需要频繁进行访问或更新的变量。例如，在for语句中的循环控制变量就比较适合声明为register：**
```c
int sum_array(int a[],int n)
{
	register int i;
	int sum = 0;

	for(i = 0;i < n;i++)
		sum += a[i];
	return sum;
}
```
现在register存储类型已经不像以前那样在C程序中流行了。**当今的编译器比早期的C语言编译器复杂多了，许多编译器可以自动确定哪些变量保留在寄存器中可以获得最大的好处。不过，使用register仍然可以为编译器优化程序性能提供有用的信息。特别的，编译器知道不能对register变量取地址，因而不能用指针对其进行修改。在这一方面，register关键字与C99的restrict关键字相关。**

### 函数的存储类型
**和变量声明一样，函数声明（定义）也可以包括存储类型，但是选项只有extern和static。在函数声明开始处的单词extern说明函数具有外部链接，也就是允许其他文件调用此函数：static说明是内部链接，也就是说只能在定义函数的文件内部调用此函数。如果不指明函数的存储类型，那么会假设函数具有外部链接。**


思考下面的函数声明：
```c
extern int f(int i);
static int g(int i);
int h(int i);
```
函数f具有外部链接，函数g具有内部链接，而函数h（默认情况下）具有外部链接。**由于g具有内部链接，所以在定义它的函数之外不能直接调用它。（把g声明为static不能完全阻止在别的文件中对它进行调用，通过函数指针进行间接调用仍然是可能的。）**

声明函数是extern的就如同声明变量是auto的一样，两者都没有作用。基于这个原因，代码示例中都不在函数声明上使用extern。然而，需要知道这种用法也是无害的。

**另一方面，声明函数是static是十分有用的。事实上，当声明不打算被其他文件调用的任意函数时，建议使用static存储类型。这样做的好处包含以下两点。**
- 更容易维护
	把函数f声明为static存储类型保证在函数定义出现的文件之外函数f都是不可见的。因此，以后修改程序的人可以知道对函数f的变化不会影响其他文件中的函数。（一个例外是：另一个文件中的函数如果传入了指向函数f的指针，它可能会受到函数f变化的影响。幸运的是，这种问题很容易通过检查定义函数f的文件来实现，因为传递f的函数一定也定义在此文件中。）
- 减少了“名字空间污染”
	由于声明为static的函数具有内部链接，所以可以在其他文件中重新使用这些函数的名字。虽然我们不太可能会为一些其他目的故意重新使用函数名字，但是在大规模程序中这种现象是很难避免的。带有外部链接的大量函数名可能导致“名字空间污染”，即不同文件中的名字意外地发生了冲突。使用static存储类型可以有效修复此类问题。

**函数的形式参数具有和auto变量相同的性质：自动存储期限、块作用域和无链接。唯一能用于形式参数的存储类型是register。**


### 小结
在这四种存储类型中，最重要的是extern和static。auto没有任何效果，而现代编译器已经使register变得不如以前重要了。

## 类型限定符
C语言中一共有两种类型限定符：const和volatile。（C99还有第三种类型限定符，即restrict，它只用于指针（17.8节受限指针））。因为volatile只用在底层编程中，所以将此限定符的讨论推迟到20.3节。const用来声明一些类似于变量的对象，但这些变量是“只读”的。程序可以访问const型对象的值，但是无法改变它的值。例如，下面这个声明创建了名为n的const型对象，且此对象的值为10：
```c
const int n = 10;
```
而下列声明产生了名为tax_brackets的const型数组：
```c
const int tax_brackets[] = {750,2250,3750,5250,7000};
```
把对象声明为const有以下几个好处。
- const是文档格式
	声明对象是const类型可以提示任何阅读程序的人，该对象的值不会改变。
- 编译器可以检查程序没有特意地试图改变该对象的值
- 当为特定类型的应用（特别是嵌入式系统）编写程序时，编译器可以用单词const来识别需要存储到ROM（只读存储器）中的数据。

乍一看，CONST好像与前面章节中用于创建常量名的#define指令一样。然而，实际上#define和const之间有明显的差异。
- 可以用#define指令为数值、字符或字符串常量创建名字。const可用于产生任何类型的只读对象，包括数组、指针、结构和联合。

- const对象遵循与变量相同的作用域规则，而用#define创建的常量不受这些规则的限制。特别是，不能用#define创建具有块作用域的常量。

- 和宏的值不同，const对象的值可以在调试器中看到。

- **不同于宏，const对象不可以用于常量表达式。例如，由于数组边界必须是常量表达式，所以不能写成下列形式：**

  ```c
  const int n = 10;
  int a[n];		/* WRONG */
  ```

  在C99中，如果a具有自动存储期限，那么这个例子是合法的——它会被视为变长数组；但是如果a具有静态存储期限，那么这个例子是不合法的。

- **对const对象应用取地址运算符（&）是合法的，因为它有地址。宏没有地址。**

**没有绝对的原则说明何时使用`#define`以及何时使用`const`。这里建议对表示数或字符的常量使用`#define`。这样就可以把这些常量作为数组维数，并且在switch语句或其他要求常量表达式的地方使用它们。**



## 声明符

声明符包含标识符（声明的变量或函数的名字），标识符的前边可能有符号`*`，后边可能有`[]`或`()`。通过把`*`、`[]`和`()`组合在一起，可以创建复杂说明符。



在了解较为复杂的声明符之前，先来复习一下前面讲过的声明符的知识。在最简单的情况下，声明符就是标识符，就如同下面例子中的i：

```c
int i;
```

声明符还可以包含符号`*`、`[]`和`()`。

- 用`*`开头的声明符表示指针。

  ```c
  int *p;
  ```

- 用`[]`结尾的声明符表示数组：

  ```c
  int a[10];
  ```

  如果数组是形式参数，或者数组有初始化式，再或者数组的存储类型为extern，那么方括号内可以为空：

  ```c
  extern int a[];
  ```

  因为a是在程序的别处定义的，所以这里编译器不需要知道数组的长度。（在多维数组中，只有第一维的方括号可以为空。）C99为数组形式参数声明中方括号内的内容提供了两种额外的选项。一个是关键字static，后面跟着的表达式指明数组的最小长度；另一个是符号`*`，它可以用在函数原型中以指示变长数组参数。

- 用`()`结尾的声明符表示函数：

  ```c
  int abs(int);
  void swap(int *,int *);
  int find_largest(int [],int);
  ```

  甚至圆括号内可以为空：

  ```c
  int abs();
  void swap();
  int find_largest();
  ```

  最后这组声明指明了abs、swap和find_largest的返回类型，但是没有提供有关它们的实际参数的信息。**圆括号内置为空不等同于把单词void放置在圆括号内，后者说明没有实际参数。**圆括号内为空的这种函数声明风格正在迅速消失，它比C89的原型形式差，因为它不允许编译器检查函数调用是否有正确的实际参数。

  如果所有的声明符都这样简单，那么C语言的编程将一蹴而就。可惜的是，实际程序中的声明符往往组合了符号`*`、`[]`和`()`。之前已经见过这类组合的示例了。我们知道下列语句声明了一个数组，此数组的元素是10个指向整数的指针：

  ```c
  int *ap[10];
  ```

  我们还知道下列语句声明了一个函数，此函数有一个float型的实际参数，并且返回指向float型值的指针：

  ```c
  float *fp(float);
  ```

  此外，17.7节还学过下面这条语句，它用来声明一个指向函数的指针，此函数有int型实际参数和void型返回值：

  ```c
  void (*pf)(int);
  ```



### 解释复杂声明

到目前为止，在声明符的理解方面还没有遇到太多的麻烦。但是，下面这个声明符是什么意思呢？

```c
int *(*x[10])(void);
```

这个声明符组合了`*`、`[]`和`()`，所以x是指针、数组还是函数并不明显。



幸运的是，无论多么费解，有下面两条简单的规则可以用来理解任何声明。

- **始终从内往外读声明符。**

  **换句话说，定位声明的标识符，并且从此处开始解释声明。**

- **在作选择时，始终使`[]`和`()`优先于`*`**

  **如果`*`在标识符的前面，而标识符后面跟着`[]`，那么标识符表示数组而不是指针。同样地，如果`*`在标识符的前面，而标识符后边跟着`()`，那么标识符表示函数而不是指针。（当然，可以使用圆括号来使`[]`和`()`相对于`*`的优先级无效。）**



首先把这些规则应用于简单的示例。在声明：

```c
int *ap[10];
```

中，ap是标识符。由于`*`在ap的前面，且后边跟着`[]`，而`[]`优先级高，所以ap是指针数组。在下列声明中，

```c
float *fp(float);
```

fp是标识符。由于`*`在标识符的前面，且后边跟着`()`，而`()`优先级高，所以fp是返回指针的函数。



下列声明是一个小陷阱：

```c
void (*pf)(int);
```

由于`*pf`包含在圆括号内，所以pf一定是指针。但是`(*pf)`后边跟着`(int)`，所以pf必须指向函数，且此函数带有int型的实际参数。单词void表明了此函数的返回类型。



正如最后那个例子所示，理解复杂的声明符经常需要从标识符的一边折返到另一边：

```c
void (*pf)(int);
```

在这个例子中，首先需要找到`pf的类型`：

1. `(*pf)`决定了这是个指针
2. `(*pf)`右侧的`(int)`决定了这是具有int型实际参数的函数。
3. 最前面的`void`决定了这个函数返回`void`型值。



下面用这种折返方法来解释最开始那个复杂的声明：

```c
int *(*x[10])(void);
```

首先，定位声明的标识符(`x`)。在`x`前有`*`，而后边又跟着`[]`。因为`[]`优先级高于`*`，所以取右侧（x是数组）。接下来，从左侧找到数组中元素的类型（指针）。再接下来，到右侧找到数组中的每个指针所指向的数据类型（不带实际参数的函数）。最后，回到左侧看每个函数返回的内容（指向int型的指针）。过程如下：

1. 首先根据`(*x[10])`可以确定x的类型是指针数组
2. 再根据`(*x[10])`右侧的`(void)`确定指针数组中的每个指针元素指向的是不带实际参数的函数
3. 最后再根据`(*x[10])`左侧的`int *`确定指针数组中的每个元素指向的函数返回的值是指向int型的指针



要想熟练掌握C语言中的声明需要花费些时间并且要多练习。唯一的好消息是在C语言中有不能声明的特定内容。函数不能返回数组：

```c
int f(int)[];	/** WRONG **/
```

函数不能返回函数：

```c
int g(int)(int);	/** WRONG **/
```

函数型的数组也是不可能的：

```c
int a[10](int);		/** WRONG **/
```

**在上述情形中，可以用指针来获得所需的效果。函数不能返回数组，但可以返回指向数组的指针；函数不能返回函数，但可以返回指向函数的指针；函数型的数组不合法，但是数组可以包含指向函数的指针。**（17.7节有一个这样的数组示例。）



### 使用类型定义来简化声明



