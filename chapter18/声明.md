# 声明
声明在C语言编程中起着核心的作用。通过声明变量和函数，可以在检查程序潜在的错误以及把程序翻译成目标代码两方面为编译器提供至关重要的信息。

前面几章已经提供了声明的示例，但是没有完整地描述，本章将弥补这个缺憾。本章会探讨可以用于声明的复杂选项，并且显示变量声明和函数声明之间的几个共同点。此外，本章还为存储期限、作用域以及链接这些重要概念提供了坚实的基础。

第一节介绍声明的一般语法，这是之前一直在回避的问题。接下来的4节将集中讨论声明中出现的数据项：存储类型、类型限定符、声明符和初始化式。最后还将讨论inline关键字，它可以用在C99函数声明中。

## 声明的语法
声明为编译器提供有关标识符含义的信息。当编写：
```c
int i;
```
时，是在告诉编译器：名字i表示当前作用域内数据类型为int的变量。声明
```c
float f(float);
```
则是在告诉编译器：f是一个返回值为float型的函数，并且此函数有一个实际参数，此参数类型也为float型。

一般地，声明具有下列形式：
```
声明说明符 声明符;
```
声明说明符描述声明的变量或函数的性质。声明符给出了它们的名字，并且可以提供关于其性质的额外信息。

声明说明符分为以下三大类：
- 存储类型
	**存储类型一共有4种：auto、static、extern和register。在声明中最多可以出现一种存储类型。如果存储类型存在，则必须把它放置在最前面。**
- 类型限定符
	**C89只有两种类型限定符：const和volatile。C99还有一个限定符restrict。声明可以包含零个或多个限定符。**
- 类型说明符
	关键字void、char、short、int、long、float、double、signed和unsigned都是类型说明符。这些单词可以组合使用，如第7章所述。这些单词出现的顺序并不重要（int undesigned long和 long unsigned int完全一样）。类型说明符也包括结构、联合和枚举的说明（例如，`struct point{int x,y;}`、`struct {int x,y}`或者`struct point`）。用typedef创建的类型名也是类型说明符。


**（C99还有第四种声明说明符，即函数说明符，它只适用于函数声明。这一类说明符只有一个，即关键字inline。）** 类型限定符和类型说明符必须跟随在存储类型的右边，但是两者的顺序没有限制。出于书写风格的考虑，这里会将类型限定符放置在类型说明符的前面。

声明符包括标识符（简单变量的名字）、后面跟随`[]`的标识符（数组名）、前放置`*`的标识符（指针名）和后边跟随`()`的标识符（函数名）。声明符之间用逗号分隔。表示变量的声明符后面可以跟随初始化式。

来看一些说明这些规则的例子。下面是一个带有存储类型和三个声明符的声明：
```c
static float x,y,*p;
```
在这个例子中，`static`是存储类型，`float`是类型说明符，`x`、`y`和`*p`是声明符。

下列声明有类型限定符但是没有存储类型。此外，它还有初始化式：
```c
const char month[] = "January";
```
在这个例子中，`const`是类型限定符，`char`是类型说明符，`month[]`是声明符，`"January"`则是初始化式。


下列声明既有存储类型也有类型限定符。此外，它还有三个类型说明符，当然它们的顺序并不重要：
```c
extern const unsigned long int a[10];
```
在这个例子中，`extern`是存储类型，`const`是类型限定符，`unsigned`、`long`、`int`是类型说明符，`a[10]`是声明符。

和变量声明一样，函数声明也有存储类型、类型限定符和类型说明符。下列声明具有存储类型和类型说明符：
```c
extern int square(int);
```
在这个例子中，`extern`是存储类型，`int`是类型说明符，`square`是声明符。

## 存储类型
**存储类型可以用于变量以及较小范围的形式参数的说明。现在集中讨论变量的存储类型。**

回顾一下10.3节的内容，术语“块”（block）表示函数体（花括号包含的部分）或者复合语句（可能包含声明）。在C99中，选择语句（if和switch）、循环语句（while、do和for）以及它们所控制的“内部”语句也被视为块，尽管本质上有一些差别。

### 变量的性质
C程序中的每个变量都具有以下3个性质。
- 存储期限
	**变量的存储期限决定了为变量预留和内存被释放的时间。具有自动存储期限的变量在所属块被执行时获得内存单元，并在块终止时释放内存单元，从而会导致变量失去值。具有静态存储期限的变量在程序运行期间占有同一个的存储单元，也就允许变量无限期地保留它的值。**
- 作用域
	**变量的作用域是指可以引用变量的那部分程序文本。变量可以有块作用域（变量从声明的地方一直到所在块的末尾都是可见的）或者文件作用域（变量从声明的地方一直到所在文件的末尾都是可见的）。**
- 链接
	**变量的链接确定了程序的不同部分可以共享此变量的范围。具有外部链接的变量可以被程序中的几个（或许全部）文件共享。具有内部链接的变量只能属于单独一个文件，但是此文件中的函数可以共享这个变量。（如果具有相同名字的变量出现在另一个文件中，那么系统会把它作为不同的变量来处理。）无链接的变量属于单独一个函数，而且根本不能被共享。**

变量的默认存储期限、作用域和链接都依赖于变量声明的位置。
- **在块（包括函数体）内部声明的变量具有自动存储期限、块作用域，并且无链接。**
- **在程序的最外层（任意块外部）声明的变量具有静态存储期限、文件作用域和外部链接。**

下面的例子说明了变量i和变量j的默认性质：
```c
/**
* 静态存储期限
* 文件作用域
* 外部链接
*/
int i;

void f(void){
	/**
	* 自动存储期限
	* 块作用域
	* 无链接
	*/
	int j;
}
```

对许多变量而言，默认的存储期限、作用域和链接是符合要求的。当这些性质无法满足要求时，可以通过指定明确的存储类型（auto、static、extern和register）来改变变量的性质。


### auto存储类型
auto存储类型只对属于块的变量有效。auto变量具有自动存储期限、块作用域，并且无链接。auto存储类型几乎从来不用明确地指明，因为对于在块内声明的变量，它是默认的。

### static存储类型
static存储类型可以用于全部变量，而无需考虑变量声明的位置。但是，作用于块外部声明的变量和块内部声明的变量时会有不同的效果。当用在块外部时，单词static说明变量具有内部链接。当用在块内部时，static把变量的存储期限从自动的变成了静态的。下面的例子说明了把变量i和变量j声明为static所产生的效果：
```c
/**
* 静态存储期限
* 文件作用域
* 内部链接
**/
static int i;

/**
* 静态存储期限
* 块作用域
* 无链接
**/
void f(void){
	static int j;
}
```
在用于块外部的声明时，static本质上使变量只在声明它的文件内可见。只有出现在同一文件中的函数可以看到此变量。在下面的例子中，函数f1和函数f2都可以访问变量i，但是其他文件中的函数不可以：
```c
static int i;

void f1(void){
	/* has access to i */
}

void f2(void){
	/* has access to i */
}
```
static的此种用法可以用来实现一种称为信息隐藏的技术。

块内声明的static变量在程序执行期间驻留在同一存储单元内。和每次程序所在块就会丢失值的自动变量不同，static变量会无限期地保留值。static变量具有以下一些有趣的性质。
- 块内的static变量只在程序执行前进行一次初始化，而auto变量则会在每次出现时进行初始化（假设它有初始化式）。
- 每次函数被递归调用时，它都会获得一组新的auto变量。但是，如果函数含有static变量，那么此函数的全部调用都可以共享这个static变量。
- **虽然函数不应该返回指向auto变量的指针，但是函数返回指向static变量的指针是没有错误的。**

声明函数中的一个变量为static，这样做允许函数在“隐藏”区域内的调用之间保留信息。隐藏区域是程序其他部分无法访问到的地方。然而，更经常的做法是用static来使程序更加有效。思考下列函数：
```c
char digit_to_hex_char(int digit)
{
	const char_hex_chars[16] = "0123456789ABCDEF";
	return hex_chars[digit];	
}
```
每次调用digit_to_hex_char函数时，都会把字符0123456789ABCDEF复制给数组hex_chars来对其进行初始化。现在，把数组设为static的：
```c
char digit_to_hex_char(int digit)
{
	static const char_hex_chars[16] = "0123456789ABCDEF";
	return hex_chars[digit];
}
```
**由于static型变量只进行一次初始化，这样做就改进了digit_to_hex_char函数的速度。**

### extern存储类型
**extern存储类型使几个源文件可以共享同一个变量。** 15.2节介绍了使用extern的基本概念，所以这里的讨论不会太多。回顾讲过的内容可以知道，下列声明给编译器提供的信息是，i是int型变量：
```c
extern int i;
```
**但是这样不会导致编译器为变量i分配存储单元。用C语言的术语来说，上述声明不是变量i的定义，它只是提示编译器需要访问定义在别处的变量（可能稍后在同一文件中，更常见的是在另一个文件中）。变量在程序中可以有多次声明，但只能有一次定义。**

**变量的extern声明不是定义这一规则有一个例外。** 对变量进行初始化的extern声明是变量的定义。例如，声明：
```c
extern int i = 0;
```
等效于：
```c
int i =0;
```
**这条规则可以防止多个extrern声明用不同方法对变量进行初始化。**

extern声明中的变量始终具有静态存储权限。变量的作用域依赖于声明的位置。如果声明在块内部，那么变量具有块作用域。否则，变量具有文件作用域：
```c
/*
* 静态存储权限
* 文件作用域
* 什么链接？
*/
extern int i;

void f(void)
{
	/**
	* 静态存储期限
	* 块作用域
	* 什么链接？
	*/
	extern int j;
}
```
**确定extern型变量的链接有一定难度。如果变量在文件中较早的位置（任何函数定义的外部）声明为static，那么它具有内部链接；否则（通常情况下），变量具有外部链接。**


### register存储类型
声明变量具有register存储类型就要求编译器把变量存储在寄存器中，而不是像其他变量一样保留在内存中。（寄存器是驻留在计算机CPU中的存储单元。存储在寄存器中的数据会比存储在普通内存中的数据访问和更新的速度更快。）指明变量的存储类型是register是一种请求，而不是命令。编译器可以选择把register型变量存储在内存中。

**register存储类型只对声明在块内的变量有效。register变量具有和auto变量一样的存储期限、作用域和链接。但是，register变量缺乏auto变量所具有的一种性质：由于寄存器没有地址，所以对register变量使用取地址运算符&是非法的。即使编译器选择把变量存储在内存中，这一限制仍适用。**

**register存储类型最好用于需要频繁进行访问或更新的变量。例如，在for语句中的循环控制变量就比较适合声明为register：**
```c
int sum_array(int a[],int n)
{
	register int i;
	int sum = 0;

	for(i = 0;i < n;i++)
		sum += a[i];
	return sum;
}
```
现在register存储类型已经不像以前那样在C程序中流行了。**当今的编译器比早期的C语言编译器复杂多了，许多编译器可以自动确定哪些变量保留在寄存器中可以获得最大的好处。不过，使用register仍然可以为编译器优化程序性能提供有用的信息。特别的，编译器知道不能对register变量取地址，因而不能用指针对其进行修改。在这一方面，register关键字与C99的restrict关键字相关。**

### 函数的存储类型
**和变量声明一样，函数声明（定义）也可以包括存储类型，但是选项只有extern和static。在函数声明开始处的单词extern说明函数具有外部链接，也就是允许其他文件调用此函数：static说明是内部链接，也就是说只能在定义函数的文件内部调用此函数。如果不指明函数的存储类型，那么会假设函数具有外部链接。**


思考下面的函数声明：
```c
extern int f(int i);
static int g(int i);
int h(int i);
```
函数f具有外部链接，函数g具有内部链接，而函数h（默认情况下）具有外部链接。**由于g具有内部链接，所以在定义它的函数之外不能直接调用它。（把g声明为static不能完全阻止在别的文件中对它进行调用，通过函数指针进行间接调用仍然是可能的。）**

声明函数是extern的就如同声明变量是auto的一样，两者都没有作用。基于这个原因，代码示例中都不在函数声明上使用extern。然而，需要知道这种用法也是无害的。

**另一方面，声明函数是static是十分有用的。事实上，当声明不打算被其他文件调用的任意函数时，建议使用static存储类型。这样做的好处包含以下两点。**
- 更容易维护
	把函数f声明为static存储类型保证在函数定义出现的文件之外函数f都是不可见的。因此，以后修改程序的人可以知道对函数f的变化不会影响其他文件中的函数。（一个例外是：另一个文件中的函数如果传入了指向函数f的指针，它可能会受到函数f变化的影响。幸运的是，这种问题很容易通过检查定义函数f的文件来实现，因为传递f的函数一定也定义在此文件中。）
- 减少了“名字空间污染”
	由于声明为static的函数具有内部链接，所以可以在其他文件中重新使用这些函数的名字。虽然我们不太可能会为一些其他目的故意重新使用函数名字，但是在大规模程序中这种现象是很难避免的。带有外部链接的大量函数名可能导致“名字空间污染”，即不同文件中的名字意外地发生了冲突。使用static存储类型可以有效修复此类问题。

**函数的形式参数具有和auto变量相同的性质：自动存储期限、块作用域和无链接。唯一能用于形式参数的存储类型是register。**


