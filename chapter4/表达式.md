# 表达式

C语言的一个特点就是它更多地强调表达式而不是语句，表达式是表示如何计算值的公式。最简单的表达式是变量和常量。变量表示程序运行时需要计算的值，常量表示不变的值，更加复杂的表达式把运算符用于操作数（操作数自身就是表达式）。在表达式a+(b*c)中，运算符+用于操作数a和（b * c），而这两者自身又都是表达式。



运算符是构建表达式的基本工具，C语言拥有异常丰富的运算符。首先，C提供了基本运算符，这类运算符在大多数编程语言中都有：

- 算术运算符

  包括加、减、乘和除

- 关系运算符

  进行诸如“i比0大”这样的比较运算

- 逻辑运算符

  实现诸如“i比0大并且i比10小”这样的关系运算。



## 算术运算符

算术运算符是许多编程语言中都广泛应用的一种运算符，这类运算符可以执行加法、减法、乘法和除法。如下所示：

一元运算符：

- +

  一元正号运算符

- -

  一元负号运算符



二元运算符：

- 加法类

  - +

    加法运算符

  - -

    减法运算符

- 乘法类

  - *

    乘法运算符

  - /

    除法运算符

  - %

    求余运算符



除%运算符之外，上面的二元运算符既允许操作数是整数也允许操作数是浮点数，两者混合也是可以的。当把int型操作数和float型操作数混合在一起时，运算结果是float型的。因此，9+2.5f的值为11.5，而6.7f/2的值为3.35。



运算符/和运算符%需要特别注意以下几点：

- 运算符/可能产生意外的结果。当两个操作数都是整数时，运算符/会丢掉分数部分来“截取”结果。因此，1/2的结果是0而不是0.5。
- 运算符%要求操作数是整数。如果两个操作数中有一个不是整数，程序将无法编译通过。
- 把零用作/或%的右操作数会导致未定义的行为。
- 当运算符/和运算符%用于负操作数时，其结果难以确定。根据C89标准，如果两个操作数中有一个为负数，那么除法的结果既可以向上取整也可以向下取整（例如，-9/7的结果既可以是-1也可以是-2。）在C89中，如果i或者j是负数，i/j的符号与具体实现有关。（例如，-9/7的值可能是-2或者5。）但是在C99中，除法的结果总是向零截取的（因此-9/7的结果是-1），i%j的值的符号与i的相同（因此-9%7的值是-2）。



**“由实现定义”的行为**

术语“由实现定义”出现频率很高，值得讨论一下。C标准故意对C语言的部分内容未加指定，并认为其细节可以由“实现”来具体定义。所谓实现是指程序在特定的平台上编译、链接和执行所需要的软件。因此，根据实现的不同，程序的行为可能会稍有差异。C89中运算符/和运算符%对负操作数的行为就是一个由实现定义行为的例子。



留下语言的一部分内容未加指定看起来可能有点奇怪，甚至很危险，但这正反映了C语言的基本理念。C语言的目标之一是高效，这常常意味着要与硬件行为相匹配。-9除以7时，有些CPU产生的结果是-1，有些为-2。C89标准简单地反映了这一现实。



最好避免编写依赖于由实现定义的行为的程序。如果不可能做到，起码要仔细查阅手册——C标准要求在文档中说明由实现定义的行为。



**运算符的优先级和结合性**

当表达式包含多个运算符时，其含义可能不是一目了然的。解决这个问题的一个方法就是添加圆括号。作为通用规则，C语言允许在所有表达式中用圆括号进行分组。



不使用圆括号的情况下，C语言采用运算符优先级规则来解决这种隐含的二义性问题。算术运算符的相对优先级如下：

- 最高优先级

  +、-（一元运算符）

  % * / 

- 最低优先级

  +、-（二元运算符）



### 计算通用产品代码的校验位

美国和加拿大的货物生产商都会在超市销售的每件商品上放置一个条形码。这种被称为通用产品代码的条形码可以识别生产商和产品。每个条形码表示一个12位的数，通常这个数会打印在条形码下面。例如，`0 13800 15173 5`出现在条形码的下方。其中第一个数字表示商品的种类。第一组5位数字用来标识生产商。第二组5位数字用来标识产品（包括包装尺寸）。最后一位数字是“校验位”，它唯一的目的是用来帮助识别前面数字中的错误。如果条形码扫描出现错误，那么前11位数字可能会和最后一位数字不匹配，超市扫描机将拒绝整个条形码。



下面是一种计算校验位的方法：首先把第1位、第3位、第5位、第7位、第9位和第11位数字相加；然后把第2位、第4位、第6位、第8位和第10位数字相加；接着把第一次加法的结果乘以3，再和第二次加法的结果相加；随后再把上述结果减去1；相减后的结果除以10取余数；最后用9减去上一步骤中得到的余数。



还是用`0 13800 15173 5`的例子，由`0+3+0+1+1+3`得到第一个和的结果8，由`1+8+0+5+7`得到第二个和21。把第一个和乘以3后再加上第二个和得到45，减1得到44。把这个值除以10取余数为4。再用9减去余数4，结果为5。



下面编写一个程序来计算任意通用产品代码的混淆位。要求用户录入通用产品代码的前11位数字，然后程序显示出相应的校验位。为了避免混淆，要求用户分3部分录入数字：左边的第一个数字、第一组5位数字以及第二组5位数字。程序会话的形式如下所示：

```
Enter the first (single) digit: 0
Enter first group of five digits: 13800
Enter second group of five digits: 15173
Check digit: 5
```



**程序不是按一个五位数来读取每组5位数字的，而是将它们读作5个一位数。把数看成一个个独立的数字进行读取更为方便，而且也无需担心由于五位数过大而无法存储到int型变量中。（某些编译器限定int型变量的最大值为32 767。）为了读取单个的数字，使用带有`%1d`转换说明的scanf函数，其中`%1d`匹配只有一位的整数。**完整程upc.c如下：

```c
#include <stdio.h>

int main(void) {
    int d,i1,i2,i3,i4,i5,j1,j2,j3,j4,j5,
        first_sum,second_sum,total;

    printf("Enter the first (single) digit: ");
    scanf("%1d",&d);
    printf("Enter first group of five digits: ");
    scanf("%1d%1d%1d%1d%1d",&i1,&i2,&i3,&i4,&i5);
    printf("Enter second group of five digits: ");
    scanf("%1d%1d%1d%1d%1d",&j1,&j2,&j3,&j4,&j5);

    first_sum = d + i2 + i4 + j1 + j3 + j5;
    second_sum = i1 + i3 + i5 + j2 + j4;
    total = 3 * first_sum + second_sum;

    printf("Check digit: %d\n",9 - ((total - 1) % 10));

    return 0;
}
```



## 赋值运算符

求出表达式的值以后常常需要将其存储到变量中，以便将来使用。C语言的=（简单赋值）运算符可以用于此目的。为了更新已经存储在变量中的值，C语言还提供了一种复合赋值运算符。



### 简单赋值

表达式v=e的赋值效果是求出表达式e的值，并把此值复制给v。



如果v和e的类型不同，那么赋值运算发生时会把e的值转化为v的类型：

```c
int i;
float f;

i = 72.99f;  // i is now 72
f = 136;     // f is now 136.0
```

类型转换的问题以后再讨论



在许多编程语言中，赋值是语句；然而，**在C语言中，赋值就像+那样是运算符。换句话说，赋值操作产生结果，**这就如同两个数相加产生结果一样。赋值运算符v=e的值就是赋值运算符后v的值。因此，表达式i=72.99f的值是72（不是72.99）。



### 左值

大多数C语言运算符允许它们的操作数是变量、常量或者包含其他运算符的表达式。然而，**赋值运算符要求它的左操作数必须是左值。左值表示存储在计算机内存中的对象，而不是常量或计算的结果。变量是左值，而诸如10或2*i这样的表达式则不是左值。**目前为止，变量是已知的唯一左值；后面会介绍其他类型的左值。



### 复合赋值

利用变量的原有值计算出新值并重新赋值给这个变量在C语言程序中是非常普遍的。例如，下面这条语句就是把变量i的值加上2后再赋值给它自己：

```c
i = i+2;
```

C语言的复合赋值运算符允许缩短这个语句以及类似的语句。使用+=运算符，可以将上面的表达式简写为：

```c
i +=2;
```

同理，还有`-=`、`*=`、`/=`、`%=`等复合赋值运算符。



## 自增运算符和自减运算符

最常用于变量的两种运算是“自增”和“自减”。当然，也可以通过下列方式完成这类操作：

``` c
i = i+1;
j = j-1;
```

而C语言允许用++（自增）和--（自减）运算符将这些语句缩得更短些。



乍一看，简化的原因仅仅是使用了自增和自减运算符：++表示操作数加1，而--表示操作数减1。但是，这是一种误导，实际上自增和自减运算符的使用是很复杂的。复杂的原因之一就是，++和--运算符既可以作为前缀运算符（如++i和--i）使用也可以作为后缀运算符（i++和i--）使用。程序的正确性可能和选取合适的运算符形式紧密相关。



复杂的另一个原因是，和赋值运算符一样，++和--也有副作用：它们会改变操作数的值。计算表达式++i（“前缀自增”）的结果是i+1，而副作用的效果是自增i：

```c
i = 1;
printf("i is %d\n",++i);   // prints i is 2
printf("i is %d\n",i);     // prints i is 2
```

计算表达式i++（“后缀自增”）的结果是i，但是会引发i随后进行自增：

```c
i = 1;
printf("i is %d\n",i++);   // prints i is 1
printf("i is %d\n",i);     // prints i is 2
```

第一个printf函数显示了i自增前的原始值，第二个printf函数显示了i变化后的新值。正如这些例子说明的那样，++i意味着“立即自增i”，而i++则意味着“现在先用i的原始值，稍后再自增i”。这个”稍后“有多久呢？C语言标准没有给出精确的时间，但是可以放心地假设i将在下一条语句执行前进行自增。



--运算符具有相似的特性：

```c
i=1;
printf("i is %d\n",--i); // prints "i is 0"
printf("i is %d\n",i);   // prints "i is 0"

i = 1;
printf("i is %d\n",i--); // prints "i is 1"
printf("i is %d\n",i);   // prints "i is 0"
```



需要记住的是，后缀++和后缀--比一元的正号、负号优先级高，而且都是左结合的。前缀++和前缀--与一元的正号、负号优先级相同，而且都是右结合的。



## 表达式语句

C语言有一条不同寻常的规则，那就是任何表达式都可以用作语句。换句话说，不论表达式是什么类型，计算什么结果，都可以通过在后面添加分号的方式将其转换成语句。例如，可以把表达式++i转换成语句：

```c
++i;
```

执行这条语句时，i先进行自增，然后把新产生的i值取出（与放在表达式中的效果一样）。但是，由于++i不是更长的表达式的一部分，所以它的值会被丢弃，执行下一条语句。（当然，对i的改变是持久的。）



